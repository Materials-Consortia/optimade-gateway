{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OPTIMADE Gateway \u00b6 A REST API server acting as a gateway for databases with an OPTIMADE API, handling the distribution and collection of a single query to several different OPTIMADE databases. The design outline is available here . Known limitations \u00b6 Here follows a list of known limitations and oddities of the current OPTIMADE gateway code. Pagination \u00b6 Pagination is a bit awkward in its current implementation state. When using the page_limit query parameter for a gateway query for gateways with multiple databases, i.e., for GET /gateways/{gateway ID}/structures and GET /queries/{query ID} , the resulting entry-resource number is the product of the page_limit value and the number of databases in the gateway (maximum). This is because the page_limit query parameter is passed straight through to the external database requests, and the returned entries are stitched together for the gateway response. So effectively, when querying GET /gateways/{gateway with N databases}/structures?page_limit=5 the resulting (maximum) number of entries returned in the response (the size of the data array in the response) will be N x 5, and not 5 as would otherwise be expected. The intention is to fix this in the future, either through short-time caching of external database responses, or figuring out if there is a usable algorithm that doesn't extend the number of external requests (and therefore the gateway response times) by too much. Sorting \u00b6 Sorting is supported for all the gateway's own resources, i.e., in the /gateways , /databases , and /queries endpoints. But sorting is not supported for the results from external OPTIMADE databases. This means the sort query parameter has no effect in the GET /gateways/{gateway ID}/structures and GET /queries/{query ID} endpoints. This shortcoming is a direct result of the current page_limit query parameter handling, and the limitation of the same . License, copyright & funding support \u00b6 All code in this repository was originally written by Casper Welzel Andersen ( @CasperWA ). The design for the gateway as outlined in design.md was a joint effort between Casper Welzel Andersen & Carl Simon Adorf ( @csadorf ). All files in this repository are licensed under the MIT license with copyright \u00a9 2021 Casper Welzel Andersen & THEOS, EPFL. Funding support \u00b6 This work was funded by THEOS , EPFL and the MarketPlace project . The MarketPlace project is funded by Horizon 2020 under H2020-NMBP-25-2017 call with Grant agreement number: 760173.","title":"OPTIMADE Gateway"},{"location":"#optimade-gateway","text":"A REST API server acting as a gateway for databases with an OPTIMADE API, handling the distribution and collection of a single query to several different OPTIMADE databases. The design outline is available here .","title":"OPTIMADE Gateway"},{"location":"#known-limitations","text":"Here follows a list of known limitations and oddities of the current OPTIMADE gateway code.","title":"Known limitations"},{"location":"#pagination","text":"Pagination is a bit awkward in its current implementation state. When using the page_limit query parameter for a gateway query for gateways with multiple databases, i.e., for GET /gateways/{gateway ID}/structures and GET /queries/{query ID} , the resulting entry-resource number is the product of the page_limit value and the number of databases in the gateway (maximum). This is because the page_limit query parameter is passed straight through to the external database requests, and the returned entries are stitched together for the gateway response. So effectively, when querying GET /gateways/{gateway with N databases}/structures?page_limit=5 the resulting (maximum) number of entries returned in the response (the size of the data array in the response) will be N x 5, and not 5 as would otherwise be expected. The intention is to fix this in the future, either through short-time caching of external database responses, or figuring out if there is a usable algorithm that doesn't extend the number of external requests (and therefore the gateway response times) by too much.","title":"Pagination"},{"location":"#sorting","text":"Sorting is supported for all the gateway's own resources, i.e., in the /gateways , /databases , and /queries endpoints. But sorting is not supported for the results from external OPTIMADE databases. This means the sort query parameter has no effect in the GET /gateways/{gateway ID}/structures and GET /queries/{query ID} endpoints. This shortcoming is a direct result of the current page_limit query parameter handling, and the limitation of the same .","title":"Sorting"},{"location":"#license-copyright-funding-support","text":"All code in this repository was originally written by Casper Welzel Andersen ( @CasperWA ). The design for the gateway as outlined in design.md was a joint effort between Casper Welzel Andersen & Carl Simon Adorf ( @csadorf ). All files in this repository are licensed under the MIT license with copyright \u00a9 2021 Casper Welzel Andersen & THEOS, EPFL.","title":"License, copyright &amp; funding support"},{"location":"#funding-support","text":"This work was funded by THEOS , EPFL and the MarketPlace project . The MarketPlace project is funded by Horizon 2020 under H2020-NMBP-25-2017 call with Grant agreement number: 760173.","title":"Funding support"},{"location":"CHANGELOG/","text":"Changelog \u00b6 v0.4.0 (2022-09-28) \u00b6 Full Changelog Merged pull requests: Update dependencies #301 ( CasperWA ) v0.3.0 (2022-09-19) \u00b6 Full Changelog Fixed bugs: FastAPI safety issues #281 pylint rules seems to be stricter #253 Fix type for auto-merge workflow #238 Pushing in automerge CI workflow not working #179 Auto-merge CD workflow not working #177 Resetting ci/dependabot-updates branch failing #174 Single dependabot PR workflow failing #167 Update mcdb name #296 ( CasperWA ) Closed issues: More verbose in main push CI job #184 Add pre-commit hooks autoupdate to CI #183 Merged pull requests: Update dependencies #300 ( CasperWA ) Update dependencies #298 ( CasperWA ) Update dependencies #293 ( CasperWA ) Update dependencies #290 ( CasperWA ) Update dependencies #288 ( CasperWA ) Update dependencies #286 ( CasperWA ) Update dependencies #285 ( CasperWA ) Update dependencies #282 ( CasperWA ) Remove no-self-use disables #280 ( CasperWA ) Update dependencies #277 ( CasperWA ) Update dependencies #271 ( CasperWA ) Update dependencies #269 ( CasperWA ) Update dependencies #267 ( CasperWA ) Update dependencies #264 ( CasperWA ) Update dependencies #262 ( CasperWA ) Update dependencies #261 ( CasperWA ) Update dependencies #258 ( CasperWA ) Update dependencies #250 ( CasperWA ) Update dependencies #248 ( CasperWA ) Update dependencies #246 ( CasperWA ) Update dependencies #242 ( CasperWA ) Use ID! type instead of String! #239 ( CasperWA ) Update dependencies #237 ( CasperWA ) Update dependencies #235 ( CasperWA ) Update dependencies #232 ( CasperWA ) Update dependencies #227 ( CasperWA ) Update dependencies #223 ( CasperWA ) Update dependencies #219 ( CasperWA ) Update dependencies #217 ( CasperWA ) Update dependencies #210 ( CasperWA ) Update dependencies #209 ( CasperWA ) Update dependencies #207 ( CasperWA ) Update dependencies #205 ( CasperWA ) Update dependencies #202 ( CasperWA ) Update dependencies #198 ( CasperWA ) Update dependencies #197 ( CasperWA ) Update dependencies #196 ( CasperWA ) Be more verbose in CI/CD workflows #191 ( CasperWA ) Update pre-commit hooks in dependabot CI #186 ( CasperWA ) Update dependencies #182 ( CasperWA ) Use PAT for pushing to activate CI jobs #181 ( CasperWA ) Use push action for pushing to dependabot branch #180 ( CasperWA ) Use ref instead of sha #178 ( CasperWA ) Update dependencies #173 ( CasperWA ) Wrap def in quotations and change to single quote #168 ( CasperWA ) v0.2.2 (2021-10-05) \u00b6 Full Changelog Fixed bugs: Fix auto-merge workflow to actually run #165 Reset ci/dependabot-updates after merging ci/update-dependencies #131 Closed issues: Activate auto-merge for Dependabot PRs #162 Move automatic ci/update-dependencies PR to Tuesday or Friday #160 Merged pull requests: Move check for dependabot head branch to job #166 ( CasperWA ) New auto-merge CI for dependabot PRs #163 ( CasperWA ) Reset ci/dependabot-updates branch upon merge to main #161 ( CasperWA ) v0.2.1 (2021-10-04) \u00b6 Full Changelog Implemented enhancements: Run keep-up-to-date workflow immediately with push #140 Update to versioned documentation #132 Use bandit , pylint , safety , and mypy #119 ( CasperWA ) Fixed bugs: GH Release action overwrites release description #155 Fix condition in main docs deployment #152 Properly authenticate the use of gh api in workflow #150 Double documentation deploy during release #145 Allow beta/alpha releases #143 Use protected-push action for keep-up-to-date workflow #138 Workflow not working #133 Attempt with fetch-depth 0 #154 ( CasperWA ) Set git config before mike deploy #144 ( CasperWA ) Use git push instead of action #136 ( CasperWA ) Closed issues: Update cron timings for dependency workflows #147 Use gh-pages in documentation deploy workflows #142 Merged pull requests: Update dependencies #159 ( CasperWA ) Deploy docs to gh-pages branch #157 ( CasperWA ) Use GH CLI instead of release action #156 ( CasperWA ) Fix conditional docs main build #153 ( CasperWA ) Add GITHUB_TOKEN env var to authenticate gh CLI #151 ( CasperWA ) Fix double docs deployment on release #149 ( CasperWA ) Update cron times #148 ( CasperWA ) Update dependencies #146 ( CasperWA ) Run up-to-date workflow immediately upon push #141 ( CasperWA ) Push via CasperWA/push-protected action #139 ( CasperWA ) Use versioned documentation #137 ( CasperWA ) Fetch everything and ensure correct checkout #135 ( CasperWA ) Attempt to fix workflow #134 ( CasperWA ) Run dependabot workflow more often #130 ( CasperWA ) Only update permanent dependabot branch after CI #127 ( CasperWA ) Don't use env outside of usable scope #126 ( CasperWA ) Setup dependabot automation #125 ( CasperWA ) Don't load providers on startup by default #121 ( CasperWA ) Update pylint requirement from ~=2.10 to ~=2.11 #120 ( dependabot[bot] ) v0.2.0 (2021-09-07) \u00b6 Full Changelog Implemented enhancements: Minor re-design #82 ( CasperWA ) Fixed bugs: Fix CD - remnants from #82 #117 Merged pull requests: Remove references to docker_config.json #118 ( CasperWA ) Return to major version tags (where available) for GH Actions #114 ( CasperWA ) Update dependencies #112 ( CasperWA ) Update pytest-httpx requirement from ~=0.12.0 to ~=0.12.1 #108 ( dependabot[bot] ) Update dependencies #107 ( CasperWA ) Update dependencies & GH Actions #104 ( CasperWA ) Update dependencies and GH Actions #99 ( CasperWA ) Update dependencies #96 ( CasperWA ) Bump codecov/codecov-action from 1.5.0 to 1.5.2 #83 ( dependabot[bot] ) Update dependencies + GH Actions #81 ( CasperWA ) Update optimade[server] requirement from ~=0.14.0 to ~=0.15.0 #79 ( dependabot[bot] ) Bump mkdocs-material from 7.1.3 to 7.1.4 #67 ( dependabot[bot] ) Update auto-changelog-action to v1.4 #65 ( CasperWA ) v0.1.2 (2021-05-01) \u00b6 Full Changelog Fixed bugs: CD is still wrong #63 Merged pull requests: Fix tag version retrieval #64 ( CasperWA ) v0.1.1 (2021-05-01) \u00b6 Full Changelog Fixed bugs: CD workflow not releasing latest documentation build #61 Merged pull requests: Use ref variable for actions/checkout #62 ( CasperWA ) v0.1.0 (2021-05-01) \u00b6 Full Changelog Implemented enhancements: Create a /search endpoint #40 Sorting #20 Add test and update code for creating queries accordingly #38 ( CasperWA ) Asynchronous queued queries #34 ( CasperWA ) Add extra endpoints #27 ( CasperWA ) Versioned base URLs #12 ( CasperWA ) Dockerfile and docker-compose #11 ( CasperWA ) Establish /gateways/{id}/structures endpoint #10 ( CasperWA ) Tests and GET /gateways #7 ( CasperWA ) Fixed bugs: Make tests more loose for model assertion #24 ( CasperWA ) Closed issues: Documentation #53 Setup mock implementations for testing the gateway #32 Finalize the APIs - Determine fate of CLI #16 Further abstract and modularize the code #15 Update docker CI job #13 Don't use GH version of optimade package #8 Merged pull requests: Change to v0.1.0-rc.1 #60 ( CasperWA ) Don't sort for external DB requests #59 ( CasperWA ) Update dependencies #58 ( CasperWA ) Create documentation site #54 ( CasperWA ) Update dependencies #52 ( CasperWA ) Implement /databases for registering and handling known OPTIMADE databases #49 ( CasperWA ) Change epfl-theos -> Materials-Consortia & update codecov CI step #48 ( CasperWA ) Update pytest-asyncio requirement from ~=0.14.0 to ~=0.15.0 #47 ( dependabot[bot] ) Add license, copyright and funding information #46 ( CasperWA ) Update dependencies #45 ( CasperWA ) Set up the /search endpoint #41 ( CasperWA ) Use pytest-httpx to mock external responses #39 ( CasperWA ) Update optimade requirement from ~=0.13.3 to ~=0.14.0 #37 ( dependabot[bot] ) Update httpx requirement from ~=0.17.0 to ~=0.17.1 #36 ( dependabot[bot] ) Use latest MongoDB v4 (v4.4) #33 ( CasperWA ) Update dependencies #31 ( CasperWA ) Update httpx requirement from ~=0.16.1 to ~=0.17.0 #28 ( dependabot[bot] ) Update dependencies #26 ( CasperWA ) Update optimade and docker CI job #14 ( CasperWA ) Various updates #9 ( CasperWA ) Update dependencies #6 ( CasperWA ) * This Changelog was automatically generated by github_changelog_generator","title":"Changelog"},{"location":"CHANGELOG/#changelog","text":"","title":"Changelog"},{"location":"CHANGELOG/#v040-2022-09-28","text":"Full Changelog Merged pull requests: Update dependencies #301 ( CasperWA )","title":"v0.4.0 (2022-09-28)"},{"location":"CHANGELOG/#v030-2022-09-19","text":"Full Changelog Fixed bugs: FastAPI safety issues #281 pylint rules seems to be stricter #253 Fix type for auto-merge workflow #238 Pushing in automerge CI workflow not working #179 Auto-merge CD workflow not working #177 Resetting ci/dependabot-updates branch failing #174 Single dependabot PR workflow failing #167 Update mcdb name #296 ( CasperWA ) Closed issues: More verbose in main push CI job #184 Add pre-commit hooks autoupdate to CI #183 Merged pull requests: Update dependencies #300 ( CasperWA ) Update dependencies #298 ( CasperWA ) Update dependencies #293 ( CasperWA ) Update dependencies #290 ( CasperWA ) Update dependencies #288 ( CasperWA ) Update dependencies #286 ( CasperWA ) Update dependencies #285 ( CasperWA ) Update dependencies #282 ( CasperWA ) Remove no-self-use disables #280 ( CasperWA ) Update dependencies #277 ( CasperWA ) Update dependencies #271 ( CasperWA ) Update dependencies #269 ( CasperWA ) Update dependencies #267 ( CasperWA ) Update dependencies #264 ( CasperWA ) Update dependencies #262 ( CasperWA ) Update dependencies #261 ( CasperWA ) Update dependencies #258 ( CasperWA ) Update dependencies #250 ( CasperWA ) Update dependencies #248 ( CasperWA ) Update dependencies #246 ( CasperWA ) Update dependencies #242 ( CasperWA ) Use ID! type instead of String! #239 ( CasperWA ) Update dependencies #237 ( CasperWA ) Update dependencies #235 ( CasperWA ) Update dependencies #232 ( CasperWA ) Update dependencies #227 ( CasperWA ) Update dependencies #223 ( CasperWA ) Update dependencies #219 ( CasperWA ) Update dependencies #217 ( CasperWA ) Update dependencies #210 ( CasperWA ) Update dependencies #209 ( CasperWA ) Update dependencies #207 ( CasperWA ) Update dependencies #205 ( CasperWA ) Update dependencies #202 ( CasperWA ) Update dependencies #198 ( CasperWA ) Update dependencies #197 ( CasperWA ) Update dependencies #196 ( CasperWA ) Be more verbose in CI/CD workflows #191 ( CasperWA ) Update pre-commit hooks in dependabot CI #186 ( CasperWA ) Update dependencies #182 ( CasperWA ) Use PAT for pushing to activate CI jobs #181 ( CasperWA ) Use push action for pushing to dependabot branch #180 ( CasperWA ) Use ref instead of sha #178 ( CasperWA ) Update dependencies #173 ( CasperWA ) Wrap def in quotations and change to single quote #168 ( CasperWA )","title":"v0.3.0 (2022-09-19)"},{"location":"CHANGELOG/#v022-2021-10-05","text":"Full Changelog Fixed bugs: Fix auto-merge workflow to actually run #165 Reset ci/dependabot-updates after merging ci/update-dependencies #131 Closed issues: Activate auto-merge for Dependabot PRs #162 Move automatic ci/update-dependencies PR to Tuesday or Friday #160 Merged pull requests: Move check for dependabot head branch to job #166 ( CasperWA ) New auto-merge CI for dependabot PRs #163 ( CasperWA ) Reset ci/dependabot-updates branch upon merge to main #161 ( CasperWA )","title":"v0.2.2 (2021-10-05)"},{"location":"CHANGELOG/#v021-2021-10-04","text":"Full Changelog Implemented enhancements: Run keep-up-to-date workflow immediately with push #140 Update to versioned documentation #132 Use bandit , pylint , safety , and mypy #119 ( CasperWA ) Fixed bugs: GH Release action overwrites release description #155 Fix condition in main docs deployment #152 Properly authenticate the use of gh api in workflow #150 Double documentation deploy during release #145 Allow beta/alpha releases #143 Use protected-push action for keep-up-to-date workflow #138 Workflow not working #133 Attempt with fetch-depth 0 #154 ( CasperWA ) Set git config before mike deploy #144 ( CasperWA ) Use git push instead of action #136 ( CasperWA ) Closed issues: Update cron timings for dependency workflows #147 Use gh-pages in documentation deploy workflows #142 Merged pull requests: Update dependencies #159 ( CasperWA ) Deploy docs to gh-pages branch #157 ( CasperWA ) Use GH CLI instead of release action #156 ( CasperWA ) Fix conditional docs main build #153 ( CasperWA ) Add GITHUB_TOKEN env var to authenticate gh CLI #151 ( CasperWA ) Fix double docs deployment on release #149 ( CasperWA ) Update cron times #148 ( CasperWA ) Update dependencies #146 ( CasperWA ) Run up-to-date workflow immediately upon push #141 ( CasperWA ) Push via CasperWA/push-protected action #139 ( CasperWA ) Use versioned documentation #137 ( CasperWA ) Fetch everything and ensure correct checkout #135 ( CasperWA ) Attempt to fix workflow #134 ( CasperWA ) Run dependabot workflow more often #130 ( CasperWA ) Only update permanent dependabot branch after CI #127 ( CasperWA ) Don't use env outside of usable scope #126 ( CasperWA ) Setup dependabot automation #125 ( CasperWA ) Don't load providers on startup by default #121 ( CasperWA ) Update pylint requirement from ~=2.10 to ~=2.11 #120 ( dependabot[bot] )","title":"v0.2.1 (2021-10-04)"},{"location":"CHANGELOG/#v020-2021-09-07","text":"Full Changelog Implemented enhancements: Minor re-design #82 ( CasperWA ) Fixed bugs: Fix CD - remnants from #82 #117 Merged pull requests: Remove references to docker_config.json #118 ( CasperWA ) Return to major version tags (where available) for GH Actions #114 ( CasperWA ) Update dependencies #112 ( CasperWA ) Update pytest-httpx requirement from ~=0.12.0 to ~=0.12.1 #108 ( dependabot[bot] ) Update dependencies #107 ( CasperWA ) Update dependencies & GH Actions #104 ( CasperWA ) Update dependencies and GH Actions #99 ( CasperWA ) Update dependencies #96 ( CasperWA ) Bump codecov/codecov-action from 1.5.0 to 1.5.2 #83 ( dependabot[bot] ) Update dependencies + GH Actions #81 ( CasperWA ) Update optimade[server] requirement from ~=0.14.0 to ~=0.15.0 #79 ( dependabot[bot] ) Bump mkdocs-material from 7.1.3 to 7.1.4 #67 ( dependabot[bot] ) Update auto-changelog-action to v1.4 #65 ( CasperWA )","title":"v0.2.0 (2021-09-07)"},{"location":"CHANGELOG/#v012-2021-05-01","text":"Full Changelog Fixed bugs: CD is still wrong #63 Merged pull requests: Fix tag version retrieval #64 ( CasperWA )","title":"v0.1.2 (2021-05-01)"},{"location":"CHANGELOG/#v011-2021-05-01","text":"Full Changelog Fixed bugs: CD workflow not releasing latest documentation build #61 Merged pull requests: Use ref variable for actions/checkout #62 ( CasperWA )","title":"v0.1.1 (2021-05-01)"},{"location":"CHANGELOG/#v010-2021-05-01","text":"Full Changelog Implemented enhancements: Create a /search endpoint #40 Sorting #20 Add test and update code for creating queries accordingly #38 ( CasperWA ) Asynchronous queued queries #34 ( CasperWA ) Add extra endpoints #27 ( CasperWA ) Versioned base URLs #12 ( CasperWA ) Dockerfile and docker-compose #11 ( CasperWA ) Establish /gateways/{id}/structures endpoint #10 ( CasperWA ) Tests and GET /gateways #7 ( CasperWA ) Fixed bugs: Make tests more loose for model assertion #24 ( CasperWA ) Closed issues: Documentation #53 Setup mock implementations for testing the gateway #32 Finalize the APIs - Determine fate of CLI #16 Further abstract and modularize the code #15 Update docker CI job #13 Don't use GH version of optimade package #8 Merged pull requests: Change to v0.1.0-rc.1 #60 ( CasperWA ) Don't sort for external DB requests #59 ( CasperWA ) Update dependencies #58 ( CasperWA ) Create documentation site #54 ( CasperWA ) Update dependencies #52 ( CasperWA ) Implement /databases for registering and handling known OPTIMADE databases #49 ( CasperWA ) Change epfl-theos -> Materials-Consortia & update codecov CI step #48 ( CasperWA ) Update pytest-asyncio requirement from ~=0.14.0 to ~=0.15.0 #47 ( dependabot[bot] ) Add license, copyright and funding information #46 ( CasperWA ) Update dependencies #45 ( CasperWA ) Set up the /search endpoint #41 ( CasperWA ) Use pytest-httpx to mock external responses #39 ( CasperWA ) Update optimade requirement from ~=0.13.3 to ~=0.14.0 #37 ( dependabot[bot] ) Update httpx requirement from ~=0.17.0 to ~=0.17.1 #36 ( dependabot[bot] ) Use latest MongoDB v4 (v4.4) #33 ( CasperWA ) Update dependencies #31 ( CasperWA ) Update httpx requirement from ~=0.16.1 to ~=0.17.0 #28 ( dependabot[bot] ) Update dependencies #26 ( CasperWA ) Update optimade and docker CI job #14 ( CasperWA ) Various updates #9 ( CasperWA ) Update dependencies #6 ( CasperWA ) * This Changelog was automatically generated by github_changelog_generator","title":"v0.1.0 (2021-05-01)"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2021 Casper Welzel Andersen & THEOS, EPFL Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"design/","text":"Design of the OPTIMADE gateway \u00b6 The OPTIMADE gateway is intended to be implemented into the MarketPlace platform. Therefore, it should implement the MarketPlace Data Source API, as well as endpoints needed for the gateway capabilities themselves. To this end, the following sections defines/recaps these APIs and capabilities. MarketPlace Data Source API \u00b6 The MarketPlace Data Source API developed in T2.2 of the MarketPlace project. It can be found on the Fraunhofer GitLab here . Outline of the currently defined endpoints. Note, if there is no HTTP method next to the endpoint, it is not an available and reachable endpoint. /marketplace/ /schemas/ ( GET ) /{schema_id}/ /attributes ( GET ) /export ( POST ) /search ( POST ) OPTIMADE gateway API \u00b6 The suggested OPTIMADE gateway API. This API is based on the expected capabilities outlined below . /optimade/ Methods : GET Behavior : Introspective/static metadata overview of server. /query/ Methods : POST or GET Behavior : Orchestrate an OPTIMADE query. /gateways/ Methods : GET Behavior : Standard reponse : Introspective/static metadata overview of all gateways. Using special query parameter : Create/retrieve and return unique gateway ID. /{gateway_id}/ Methods : POST or GET Behavior : Create/retrieve search ID and return unique search ID. Start asynchronous search task. Either: /queries/ Methods : None Behavior : Disallowed. Note : This endpoint could support GET requests with similar functionality and behavior as for /gateways/ ? This would move some functionality away from /{gateway_id}/ to this endpoint. Making /{gateway_id}/ act as a mix of /query/ and /gateways/ in terms of orchestrating the search and returning introspective/static metadata about the gateway. /{search_id}/ Methods : GET Behavior : Return current results according to state of asynchronous search task. or: /{search_id}/ Methods : GET Behavior : Return current results according to state of asynchronous search task. OPTIMADE gateway capabilities \u00b6 Searching in multiple OPTIMADE databases . Utilize the OPTIMADE filter language . Retrieve entries (OPTIMADE structures) as JSON-serialized CUDS . Not a required capability for the base gateway API . Design ideas and comments by Simon Adorf ( @csadorf ) \u00b6 I think the way you would achieve the \u201cselection\u201d of databases is by creating provider-specific endpoints like this: GET /gateway?providers=abc,def,xyz This will return a deterministic gateway id related to specific set of providers, which you will then use for further queries like this: GET /gateway/{gateway_id}/structures/ etc. The gateway id would provide introspection, so /gateway/{gateway_id} returns some information about the gateway (supported OPTIMADE API, list of providers) etc. You would cache the gateway id in the client, so you don\u2019t have to make two requests for each query. If you don\u2019t provide a list of providers, the current default set is used. But this ensures that the REST API is actually stateless, because one gateway is always tied to a specific set of providers even if the default list is changed. Obviously, if you use a gateway that includes providers that are no longer available you would respond with code 503 or so. This design solves the issue of how to provide a gateway that implements the OPTIMADE API and allows for the selection of providers. I assume your results are paginated, so IMO \u2014 unless you request a specific order \u2014 you should just return results as they come in. You need to implement this gateway asynchronously anyways so it really does not matter whether you include slow providers or not. Of course, this changes if the user requests a specific order, but that\u2019s just how it is. From a user perspective it would make sense to me that such a query across multiple providers may take a while. You should definitely define a timeout for each gateway where if a provider does not respond by then, the result is returned regardless of whether the provider has responded. Or you respond with a time out code. Searching \u00b6 Taking Simon's comments into account, the search capability should be: Asynchronous; and Dynamic. The asynchronicity comes from creating web calls (possibly using CORS) to each (chosen) database asynchronously, collating the results in a single (gateway) endpoint. The dynamics here relate to the suggested dynamic creation (and possible deletion) of gateway IDs under a /gateway -endpoint. GET requests \u00b6 Essentially, for each search, a new gateway will be created (if needed) with a unique ID. This unique ID will constitue the content of the initial response after performing a search, so that the user can go to the new gateway ID-specific endpoint to retrieve the results. To make this easier for the user, the server could automatically redirect the user after creating the endpoint. Here the response will contain the currently retrieved results as well as som metadata information about how the search is going and a general overview. This would ideally result in the following search sequence: The final GET request can be repeated to retrieve more results during the timeline of the search happening, and to retrieve the final list of results in a set time period after the search has finished. POST requests \u00b6 One could also think of using POST requests instead, containing the OPTIMADE query parameters alongside with other information, mainly utilized for the /gateway/{unique ID} -endpoints. The response could contain a link or simply redirect to a /gateway/{unique ID}/{search unique ID} -endpoint. The latter part could also be done for the GET approach, since a specific gateway should support multiple unique simultaneous searched. Since the searches are asynchronous, the results don't come back from all resources simultaneously, thus demanding an extra endpoint, where the continuously updating results can be found - as well as the final list of results for a specific search. This differs from the section above, where a GET request should contain query parameters in the URL and this will be correlated with an ongoing (unique) search in the backend, which would potentially allow different users to experience the same loading of results if they performed the same search in the same gateway, even at slightly different times during the searching period. A sequence would ideally look this: Conclusion \u00b6 The best approach here would be to create unique search IDs under each unique gateway, pertaining to a specific search. In the same way that gateways may be reused, search results may be reused. However, to ensure the \"freshness\" of the data, the \"live\"-period for any unique search should be significantly smaller than that of any unique gateway. POST requests may be preferred due to the ability of combining OPTIMADE-specific query data and gateway-specific data. Suggested search sequence diagram : Design discussions (17.12.2020) \u00b6 To be backwards compatible (where each gateway may represent a fully fledged OPTIMADE database), make /gateways/{unique ID}/ redirect to /gateways/{unique ID}/structures/ . Note, remove CUDS as a required capability, content negotiation might be with different means than a URL query parameter. Caching \u00b6 Caching should be segmented for each database. For each new user query that retrieves and caches individual resources from a database, the lifetime of the cached resource should be updated to the set default (or what is determined by caching headers from the side of the database). Either the CacheControl or requests-cache packages will be utilized for caching. Since the time it takes for an OPTIMADE database to change its content varies, but is mainly quite long, individual search life times ( /gateways/{gateway ID}(/queries)/{search ID}/ ) can be \"long\", e.g., a couple of hours. However, these two ways of \"caching\" should be separate. It should always be possible to forcefully ensure a \"fresh\" search. OPTIMADE filter language \u00b6 The filter language will be reused as the filter language for any search in any gateway. The filter language is defined in the OPTIMADE specification . Retrieval formats \u00b6 All responses will be in JSON (for now). To choose the retrieval format of the structure, a query parameter will be dedicated for the /{search unique ID} endpoint. OPTIMADE \u00b6 The standard OPTIMADE format for defining structures will be reused for listing the structure entries. See the OPTIMADE specification for a list of properties defining the structures entry. When returning the results in this format, the whole response should be compliant with a standard OPTIMADE response as is expected in the /structures -endpoint. CUDS \u00b6 Utilizing the optimade2cuds Python package in the SimOPTIMADE repository on the Fraunhofer GitLab for the MarketPlace project, the resulting OPTIMADE structure can be converted to Python CUDS objects. From there they can be serialized to JSON representations (using the OSP-Core package) and returned as a search result response. External API calls \u00b6 When making external API calls, i.e., requesting the various OPTIMADE databases, this is technically done in a concurrent.futures.ThreadPoolExecutor . This is mainly done to not block the main OS thread, where the asyncio event loop is running . This is the event loop that handles incoming gateway requests. While the number of databases may not be significant, the response times can still vary and by using a ThreadPoolExecutor , the gateway is ready for more heavy use out-of-the-box. Another key reason to use a ThreadPoolExecutor (instead of Starlette's - and therefore FastAPI's - BackgroundTask ) is for testing with the pytest framework. When using BackgroundTask the response cannot be properly mocked and instead blocks the main OS thread. Perhaps this could be solved by implementing the same solution as has been done for now, namely running a time.sleep function call in a ThreadPoolExecutor , in the mocked response callback, but the benefits of using a ThreadPoolExecutor also for the actual queries outweigh this in the long run. For further considerations a ProcessPoolExecutor might even be considered, but it shouldn't be necessary as the work done is IO blocking, not CPU blocking. The possible speed-up should not be significant. Further reading and considerations on this subject Multithreading vs. Multiprocessing in Python by Amine Baatout is a good read. Another source of inspiration was found in this StackOverflow post response . Other ideas - a queue \u00b6 Throughout the process of figuring this out, other ideas were on the table. One was to setup an asyncio.Queue - either a single \"unbuffered channel\" queue for the whole lifetime of the server, or one each per request. This would effectively split up the perform_query in producer/worker functions. For some nice reading on this, check out Latency in Asynchronous Python by Chris Wellons ( null program ). Since the ThreadPoolExecutor solution solves the issue of the analogous \"heartbeat\" function not losing its responsivenes, i.e., the asyncio event loop not being blocked, and it would work with the current code implementation, I opted for this solution instead. But I recon a queue solution would work similarly, but perhaps with slightly less gateway API responsiveness during heavy load, since it all still runs in the same event loop.","title":"Design of the OPTIMADE gateway"},{"location":"design/#design-of-the-optimade-gateway","text":"The OPTIMADE gateway is intended to be implemented into the MarketPlace platform. Therefore, it should implement the MarketPlace Data Source API, as well as endpoints needed for the gateway capabilities themselves. To this end, the following sections defines/recaps these APIs and capabilities.","title":"Design of the OPTIMADE gateway"},{"location":"design/#marketplace-data-source-api","text":"The MarketPlace Data Source API developed in T2.2 of the MarketPlace project. It can be found on the Fraunhofer GitLab here . Outline of the currently defined endpoints. Note, if there is no HTTP method next to the endpoint, it is not an available and reachable endpoint. /marketplace/ /schemas/ ( GET ) /{schema_id}/ /attributes ( GET ) /export ( POST ) /search ( POST )","title":"MarketPlace Data Source API"},{"location":"design/#optimade-gateway-api","text":"The suggested OPTIMADE gateway API. This API is based on the expected capabilities outlined below . /optimade/ Methods : GET Behavior : Introspective/static metadata overview of server. /query/ Methods : POST or GET Behavior : Orchestrate an OPTIMADE query. /gateways/ Methods : GET Behavior : Standard reponse : Introspective/static metadata overview of all gateways. Using special query parameter : Create/retrieve and return unique gateway ID. /{gateway_id}/ Methods : POST or GET Behavior : Create/retrieve search ID and return unique search ID. Start asynchronous search task. Either: /queries/ Methods : None Behavior : Disallowed. Note : This endpoint could support GET requests with similar functionality and behavior as for /gateways/ ? This would move some functionality away from /{gateway_id}/ to this endpoint. Making /{gateway_id}/ act as a mix of /query/ and /gateways/ in terms of orchestrating the search and returning introspective/static metadata about the gateway. /{search_id}/ Methods : GET Behavior : Return current results according to state of asynchronous search task. or: /{search_id}/ Methods : GET Behavior : Return current results according to state of asynchronous search task.","title":"OPTIMADE gateway API"},{"location":"design/#optimade-gateway-capabilities","text":"Searching in multiple OPTIMADE databases . Utilize the OPTIMADE filter language . Retrieve entries (OPTIMADE structures) as JSON-serialized CUDS . Not a required capability for the base gateway API .","title":"OPTIMADE gateway capabilities"},{"location":"design/#design-ideas-and-comments-by-simon-adorf-csadorf","text":"I think the way you would achieve the \u201cselection\u201d of databases is by creating provider-specific endpoints like this: GET /gateway?providers=abc,def,xyz This will return a deterministic gateway id related to specific set of providers, which you will then use for further queries like this: GET /gateway/{gateway_id}/structures/ etc. The gateway id would provide introspection, so /gateway/{gateway_id} returns some information about the gateway (supported OPTIMADE API, list of providers) etc. You would cache the gateway id in the client, so you don\u2019t have to make two requests for each query. If you don\u2019t provide a list of providers, the current default set is used. But this ensures that the REST API is actually stateless, because one gateway is always tied to a specific set of providers even if the default list is changed. Obviously, if you use a gateway that includes providers that are no longer available you would respond with code 503 or so. This design solves the issue of how to provide a gateway that implements the OPTIMADE API and allows for the selection of providers. I assume your results are paginated, so IMO \u2014 unless you request a specific order \u2014 you should just return results as they come in. You need to implement this gateway asynchronously anyways so it really does not matter whether you include slow providers or not. Of course, this changes if the user requests a specific order, but that\u2019s just how it is. From a user perspective it would make sense to me that such a query across multiple providers may take a while. You should definitely define a timeout for each gateway where if a provider does not respond by then, the result is returned regardless of whether the provider has responded. Or you respond with a time out code.","title":"Design ideas and comments by Simon Adorf (@csadorf)"},{"location":"design/#searching","text":"Taking Simon's comments into account, the search capability should be: Asynchronous; and Dynamic. The asynchronicity comes from creating web calls (possibly using CORS) to each (chosen) database asynchronously, collating the results in a single (gateway) endpoint. The dynamics here relate to the suggested dynamic creation (and possible deletion) of gateway IDs under a /gateway -endpoint.","title":"Searching"},{"location":"design/#get-requests","text":"Essentially, for each search, a new gateway will be created (if needed) with a unique ID. This unique ID will constitue the content of the initial response after performing a search, so that the user can go to the new gateway ID-specific endpoint to retrieve the results. To make this easier for the user, the server could automatically redirect the user after creating the endpoint. Here the response will contain the currently retrieved results as well as som metadata information about how the search is going and a general overview. This would ideally result in the following search sequence: The final GET request can be repeated to retrieve more results during the timeline of the search happening, and to retrieve the final list of results in a set time period after the search has finished.","title":"GET requests"},{"location":"design/#post-requests","text":"One could also think of using POST requests instead, containing the OPTIMADE query parameters alongside with other information, mainly utilized for the /gateway/{unique ID} -endpoints. The response could contain a link or simply redirect to a /gateway/{unique ID}/{search unique ID} -endpoint. The latter part could also be done for the GET approach, since a specific gateway should support multiple unique simultaneous searched. Since the searches are asynchronous, the results don't come back from all resources simultaneously, thus demanding an extra endpoint, where the continuously updating results can be found - as well as the final list of results for a specific search. This differs from the section above, where a GET request should contain query parameters in the URL and this will be correlated with an ongoing (unique) search in the backend, which would potentially allow different users to experience the same loading of results if they performed the same search in the same gateway, even at slightly different times during the searching period. A sequence would ideally look this:","title":"POST requests"},{"location":"design/#conclusion","text":"The best approach here would be to create unique search IDs under each unique gateway, pertaining to a specific search. In the same way that gateways may be reused, search results may be reused. However, to ensure the \"freshness\" of the data, the \"live\"-period for any unique search should be significantly smaller than that of any unique gateway. POST requests may be preferred due to the ability of combining OPTIMADE-specific query data and gateway-specific data. Suggested search sequence diagram :","title":"Conclusion"},{"location":"design/#design-discussions-17122020","text":"To be backwards compatible (where each gateway may represent a fully fledged OPTIMADE database), make /gateways/{unique ID}/ redirect to /gateways/{unique ID}/structures/ . Note, remove CUDS as a required capability, content negotiation might be with different means than a URL query parameter.","title":"Design discussions (17.12.2020)"},{"location":"design/#caching","text":"Caching should be segmented for each database. For each new user query that retrieves and caches individual resources from a database, the lifetime of the cached resource should be updated to the set default (or what is determined by caching headers from the side of the database). Either the CacheControl or requests-cache packages will be utilized for caching. Since the time it takes for an OPTIMADE database to change its content varies, but is mainly quite long, individual search life times ( /gateways/{gateway ID}(/queries)/{search ID}/ ) can be \"long\", e.g., a couple of hours. However, these two ways of \"caching\" should be separate. It should always be possible to forcefully ensure a \"fresh\" search.","title":"Caching"},{"location":"design/#optimade-filter-language","text":"The filter language will be reused as the filter language for any search in any gateway. The filter language is defined in the OPTIMADE specification .","title":"OPTIMADE filter language"},{"location":"design/#retrieval-formats","text":"All responses will be in JSON (for now). To choose the retrieval format of the structure, a query parameter will be dedicated for the /{search unique ID} endpoint.","title":"Retrieval formats"},{"location":"design/#optimade","text":"The standard OPTIMADE format for defining structures will be reused for listing the structure entries. See the OPTIMADE specification for a list of properties defining the structures entry. When returning the results in this format, the whole response should be compliant with a standard OPTIMADE response as is expected in the /structures -endpoint.","title":"OPTIMADE"},{"location":"design/#cuds","text":"Utilizing the optimade2cuds Python package in the SimOPTIMADE repository on the Fraunhofer GitLab for the MarketPlace project, the resulting OPTIMADE structure can be converted to Python CUDS objects. From there they can be serialized to JSON representations (using the OSP-Core package) and returned as a search result response.","title":"CUDS"},{"location":"design/#external-api-calls","text":"When making external API calls, i.e., requesting the various OPTIMADE databases, this is technically done in a concurrent.futures.ThreadPoolExecutor . This is mainly done to not block the main OS thread, where the asyncio event loop is running . This is the event loop that handles incoming gateway requests. While the number of databases may not be significant, the response times can still vary and by using a ThreadPoolExecutor , the gateway is ready for more heavy use out-of-the-box. Another key reason to use a ThreadPoolExecutor (instead of Starlette's - and therefore FastAPI's - BackgroundTask ) is for testing with the pytest framework. When using BackgroundTask the response cannot be properly mocked and instead blocks the main OS thread. Perhaps this could be solved by implementing the same solution as has been done for now, namely running a time.sleep function call in a ThreadPoolExecutor , in the mocked response callback, but the benefits of using a ThreadPoolExecutor also for the actual queries outweigh this in the long run. For further considerations a ProcessPoolExecutor might even be considered, but it shouldn't be necessary as the work done is IO blocking, not CPU blocking. The possible speed-up should not be significant. Further reading and considerations on this subject Multithreading vs. Multiprocessing in Python by Amine Baatout is a good read. Another source of inspiration was found in this StackOverflow post response .","title":"External API calls"},{"location":"design/#other-ideas-a-queue","text":"Throughout the process of figuring this out, other ideas were on the table. One was to setup an asyncio.Queue - either a single \"unbuffered channel\" queue for the whole lifetime of the server, or one each per request. This would effectively split up the perform_query in producer/worker functions. For some nice reading on this, check out Latency in Asynchronous Python by Chris Wellons ( null program ). Since the ThreadPoolExecutor solution solves the issue of the analogous \"heartbeat\" function not losing its responsivenes, i.e., the asyncio event loop not being blocked, and it would work with the current code implementation, I opted for this solution instead. But I recon a queue solution would work similarly, but perhaps with slightly less gateway API responsiveness during heavy load, since it all still runs in the same event loop.","title":"Other ideas - a queue"},{"location":"api_reference/events/","text":"events \u00b6 ASGI app events. These events can be run at application startup or shutdown. The specific events are listed in EVENTS along with their respected proper invocation time. EVENTS : Sequence [ Tuple [ str , Callable [[], Coroutine [ Any , Any , None ]]]] = (( 'startup' , ci_dev_startup ), ( 'startup' , load_optimade_providers_databases )) module-attribute \u00b6 A tuple of all pairs of events and event functions. To use this tuple of tuples: from fastapi import FastAPI APP = FastAPI () for event , func in EVENTS : APP . add_event_handler ( event , func ) ci_dev_startup () async \u00b6 Function to run at app startup - only relevant for CI or development to add test data. Source code in optimade_gateway/events.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 async def ci_dev_startup () -> None : \"\"\"Function to run at app startup - only relevant for CI or development to add test data.\"\"\" if bool ( os . getenv ( \"CI\" , \"\" )): LOGGER . info ( \"CI detected - Will load test gateways (after dropping the collection)!\" ) elif os . getenv ( \"OPTIMADE_MONGO_DATABASE\" , \"\" ) == \"optimade_gateway_dev\" : LOGGER . info ( \"Running in development mode - Will load test gateways (after dropping the\" \"collection)!\" ) else : LOGGER . debug ( \"Not in CI or development mode - will start normally.\" ) return # Add test gateways import json from pathlib import Path from optimade_gateway.mongo.database import MONGO_DB test_data = ( Path ( __file__ ) . parent . parent . joinpath ( \".ci/test_gateways.json\" ) . resolve () ) await MONGO_DB [ CONFIG . gateways_collection ] . drop () if await MONGO_DB [ CONFIG . gateways_collection ] . count_documents ({}) != 0 : raise RuntimeError ( f \"Unexpectedly found documents in the { CONFIG . gateways_collection !r} Mongo\" \" collection after dropping it ! Found number of documents: \" f \" { await MONGO_DB [ CONFIG . gateways_collection ] . count_documents ({}) } \" ) if not test_data . exists (): raise FileNotFoundError ( f \"Could not find test data file with test gateways at { test_data } !\" ) with open ( test_data , encoding = \"utf8\" ) as handle : data = json . load ( handle ) await MONGO_DB [ CONFIG . gateways_collection ] . insert_many ( data ) load_optimade_providers_databases () async \u00b6 Load in the providers' OPTIMADE databases from Materials-Consortia Utilize the Materials-Consortia list of OPTIMADE providers at https://providers.optimade.org . Load in all databases with a valid base URL. Source code in optimade_gateway/events.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 async def load_optimade_providers_databases () -> None : # pylint: disable=too-many-branches,too-many-statements,too-many-locals \"\"\"Load in the providers' OPTIMADE databases from Materials-Consortia Utilize the Materials-Consortia list of OPTIMADE providers at [https://providers.optimade.org](https://providers.optimade.org). Load in all databases with a valid base URL. \"\"\" import asyncio import httpx from optimade import __api_version__ from optimade.models import LinksResponse from optimade.models.links import LinkType from optimade.server.routers.utils import BASE_URL_PREFIXES from optimade_gateway.common.utils import clean_python_types , get_resource_attribute from optimade_gateway.models.databases import DatabaseCreate from optimade_gateway.queries.perform import db_get_all_resources from optimade_gateway.routers.utils import resource_factory if not CONFIG . load_optimade_providers_databases : LOGGER . debug ( \"Will not load databases from Materials-Consortia list of providers.\" ) return if TYPE_CHECKING or bool ( os . getenv ( \"MKDOCS_BUILD\" , \"\" )): # pragma: no cover providers : \"Union[httpx.Response, LinksResponse]\" async with httpx . AsyncClient () as client : providers = await client . get ( f \"https://providers.optimade.org/v { __api_version__ . split ( '.' , maxsplit = 1 )[ 0 ] } \" \"/links\" ) if providers . is_error : LOGGER . warning ( \"Response from Materials-Consortia's list of OPTIMADE providers was not \" \"successful (status code != 200). No databases will therefore be added at \" \"server startup.\" ) return LOGGER . info ( \"Registering Materials-Consortia list of OPTIMADE providers' databases.\" ) providers = LinksResponse ( ** providers . json ()) valid_providers = [] for provider in providers . data : if get_resource_attribute ( provider , \"id\" ) in ( \"exmpl\" , \"optimade\" ): LOGGER . info ( \"- %s (id= %r ) - Skipping: Not a real provider.\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) continue if not get_resource_attribute ( provider , \"attributes.base_url\" ): LOGGER . info ( \"- %s (id= %r ) - Skipping: No base URL information.\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) continue valid_providers . append ( provider ) # Run queries to each database using the supported major versioned base URL to get a # list of the provider's databases. # There is no need to use ThreadPoolExecutor here, since we want this to block # everything and then finish, before the server actually starts up. provider_queries = [ asyncio . create_task ( db_get_all_resources ( database = provider , endpoint = \"links\" , response_model = LinksResponse , ) ) for provider in valid_providers ] for query in asyncio . as_completed ( provider_queries ): provider_databases , provider = await query LOGGER . info ( \"- %s (id= %r ) - Processing\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) if not provider_databases : LOGGER . info ( \" - No OPTIMADE databases found.\" ) continue provider_databases = [ db for db in provider_databases if await clean_python_types ( get_resource_attribute ( db , \"attributes.link_type\" , \"\" ) ) == LinkType . CHILD . value ] if not provider_databases : LOGGER . info ( \" - No OPTIMADE databases found.\" ) continue for database in provider_databases : if not get_resource_attribute ( database , \"attributes.base_url\" ): LOGGER . info ( \" - %s (id= %r ) - Skipping: No base URL information.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), ) continue LOGGER . info ( \" - %s (id= %r ) - Checking versioned base URL and /structures\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), ) async with httpx . AsyncClient () as client : try : db_response = await client . get ( f \" { str ( get_resource_attribute ( database , 'attributes.base_url' )) . rstrip ( '/' ) } \" # pylint: disable=line-too-long f \" { BASE_URL_PREFIXES [ 'major' ] } /structures\" , ) except httpx . ReadTimeout : LOGGER . info ( \" - %s (id= %r ) - Skipping: Timeout while requesting \" \" %s /structures.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), BASE_URL_PREFIXES [ \"major\" ], ) continue if db_response . status_code != 200 : LOGGER . info ( \" - %s (id= %r ) - Skipping: Response from %s /structures is not \" \"200 OK.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), BASE_URL_PREFIXES [ \"major\" ], ) continue new_id = ( f \" { get_resource_attribute ( provider , 'id' ) } \" f \"/ { get_resource_attribute ( database , 'id' ) } \" if len ( provider_databases ) > 1 else get_resource_attribute ( database , \"id\" ) ) registered_database , _ = await resource_factory ( DatabaseCreate ( id = new_id , ** await clean_python_types ( get_resource_attribute ( database , \"attributes\" , {}) ), ) ) LOGGER . info ( \" - %s (id= %r ) - Registered database with id= %r \" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), registered_database . id , )","title":"events"},{"location":"api_reference/events/#events","text":"ASGI app events. These events can be run at application startup or shutdown. The specific events are listed in EVENTS along with their respected proper invocation time.","title":"events"},{"location":"api_reference/events/#optimade_gateway.events.EVENTS","text":"A tuple of all pairs of events and event functions. To use this tuple of tuples: from fastapi import FastAPI APP = FastAPI () for event , func in EVENTS : APP . add_event_handler ( event , func )","title":"EVENTS"},{"location":"api_reference/events/#optimade_gateway.events.ci_dev_startup","text":"Function to run at app startup - only relevant for CI or development to add test data. Source code in optimade_gateway/events.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 async def ci_dev_startup () -> None : \"\"\"Function to run at app startup - only relevant for CI or development to add test data.\"\"\" if bool ( os . getenv ( \"CI\" , \"\" )): LOGGER . info ( \"CI detected - Will load test gateways (after dropping the collection)!\" ) elif os . getenv ( \"OPTIMADE_MONGO_DATABASE\" , \"\" ) == \"optimade_gateway_dev\" : LOGGER . info ( \"Running in development mode - Will load test gateways (after dropping the\" \"collection)!\" ) else : LOGGER . debug ( \"Not in CI or development mode - will start normally.\" ) return # Add test gateways import json from pathlib import Path from optimade_gateway.mongo.database import MONGO_DB test_data = ( Path ( __file__ ) . parent . parent . joinpath ( \".ci/test_gateways.json\" ) . resolve () ) await MONGO_DB [ CONFIG . gateways_collection ] . drop () if await MONGO_DB [ CONFIG . gateways_collection ] . count_documents ({}) != 0 : raise RuntimeError ( f \"Unexpectedly found documents in the { CONFIG . gateways_collection !r} Mongo\" \" collection after dropping it ! Found number of documents: \" f \" { await MONGO_DB [ CONFIG . gateways_collection ] . count_documents ({}) } \" ) if not test_data . exists (): raise FileNotFoundError ( f \"Could not find test data file with test gateways at { test_data } !\" ) with open ( test_data , encoding = \"utf8\" ) as handle : data = json . load ( handle ) await MONGO_DB [ CONFIG . gateways_collection ] . insert_many ( data )","title":"ci_dev_startup()"},{"location":"api_reference/events/#optimade_gateway.events.load_optimade_providers_databases","text":"Load in the providers' OPTIMADE databases from Materials-Consortia Utilize the Materials-Consortia list of OPTIMADE providers at https://providers.optimade.org . Load in all databases with a valid base URL. Source code in optimade_gateway/events.py 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 async def load_optimade_providers_databases () -> None : # pylint: disable=too-many-branches,too-many-statements,too-many-locals \"\"\"Load in the providers' OPTIMADE databases from Materials-Consortia Utilize the Materials-Consortia list of OPTIMADE providers at [https://providers.optimade.org](https://providers.optimade.org). Load in all databases with a valid base URL. \"\"\" import asyncio import httpx from optimade import __api_version__ from optimade.models import LinksResponse from optimade.models.links import LinkType from optimade.server.routers.utils import BASE_URL_PREFIXES from optimade_gateway.common.utils import clean_python_types , get_resource_attribute from optimade_gateway.models.databases import DatabaseCreate from optimade_gateway.queries.perform import db_get_all_resources from optimade_gateway.routers.utils import resource_factory if not CONFIG . load_optimade_providers_databases : LOGGER . debug ( \"Will not load databases from Materials-Consortia list of providers.\" ) return if TYPE_CHECKING or bool ( os . getenv ( \"MKDOCS_BUILD\" , \"\" )): # pragma: no cover providers : \"Union[httpx.Response, LinksResponse]\" async with httpx . AsyncClient () as client : providers = await client . get ( f \"https://providers.optimade.org/v { __api_version__ . split ( '.' , maxsplit = 1 )[ 0 ] } \" \"/links\" ) if providers . is_error : LOGGER . warning ( \"Response from Materials-Consortia's list of OPTIMADE providers was not \" \"successful (status code != 200). No databases will therefore be added at \" \"server startup.\" ) return LOGGER . info ( \"Registering Materials-Consortia list of OPTIMADE providers' databases.\" ) providers = LinksResponse ( ** providers . json ()) valid_providers = [] for provider in providers . data : if get_resource_attribute ( provider , \"id\" ) in ( \"exmpl\" , \"optimade\" ): LOGGER . info ( \"- %s (id= %r ) - Skipping: Not a real provider.\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) continue if not get_resource_attribute ( provider , \"attributes.base_url\" ): LOGGER . info ( \"- %s (id= %r ) - Skipping: No base URL information.\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) continue valid_providers . append ( provider ) # Run queries to each database using the supported major versioned base URL to get a # list of the provider's databases. # There is no need to use ThreadPoolExecutor here, since we want this to block # everything and then finish, before the server actually starts up. provider_queries = [ asyncio . create_task ( db_get_all_resources ( database = provider , endpoint = \"links\" , response_model = LinksResponse , ) ) for provider in valid_providers ] for query in asyncio . as_completed ( provider_queries ): provider_databases , provider = await query LOGGER . info ( \"- %s (id= %r ) - Processing\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) if not provider_databases : LOGGER . info ( \" - No OPTIMADE databases found.\" ) continue provider_databases = [ db for db in provider_databases if await clean_python_types ( get_resource_attribute ( db , \"attributes.link_type\" , \"\" ) ) == LinkType . CHILD . value ] if not provider_databases : LOGGER . info ( \" - No OPTIMADE databases found.\" ) continue for database in provider_databases : if not get_resource_attribute ( database , \"attributes.base_url\" ): LOGGER . info ( \" - %s (id= %r ) - Skipping: No base URL information.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), ) continue LOGGER . info ( \" - %s (id= %r ) - Checking versioned base URL and /structures\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), ) async with httpx . AsyncClient () as client : try : db_response = await client . get ( f \" { str ( get_resource_attribute ( database , 'attributes.base_url' )) . rstrip ( '/' ) } \" # pylint: disable=line-too-long f \" { BASE_URL_PREFIXES [ 'major' ] } /structures\" , ) except httpx . ReadTimeout : LOGGER . info ( \" - %s (id= %r ) - Skipping: Timeout while requesting \" \" %s /structures.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), BASE_URL_PREFIXES [ \"major\" ], ) continue if db_response . status_code != 200 : LOGGER . info ( \" - %s (id= %r ) - Skipping: Response from %s /structures is not \" \"200 OK.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), BASE_URL_PREFIXES [ \"major\" ], ) continue new_id = ( f \" { get_resource_attribute ( provider , 'id' ) } \" f \"/ { get_resource_attribute ( database , 'id' ) } \" if len ( provider_databases ) > 1 else get_resource_attribute ( database , \"id\" ) ) registered_database , _ = await resource_factory ( DatabaseCreate ( id = new_id , ** await clean_python_types ( get_resource_attribute ( database , \"attributes\" , {}) ), ) ) LOGGER . info ( \" - %s (id= %r ) - Registered database with id= %r \" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), registered_database . id , )","title":"load_optimade_providers_databases()"},{"location":"api_reference/exception_handlers/","text":"exception_handlers \u00b6 ASGI app exception handlers. These are in addition to the exception handlers available in OPTIMADE Python tools. For more information see https://www.optimade.org/optimade-python-tools/api_reference/server/exception_handlers/. request_validation_exception_handler ( request , exc ) async \u00b6 Special handler if a RequestValidationError comes from wrong POST data Source code in optimade_gateway/exception_handlers.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 async def request_validation_exception_handler ( request : \"Request\" , exc : \"RequestValidationError\" ) -> \"JSONResponse\" : \"\"\"Special handler if a `RequestValidationError` comes from wrong `POST` data\"\"\" status_code = 500 if request . method in ( \"POST\" , \"post\" ): status_code = 400 errors = set () for error in exc . errors (): pointer = \"/\" + \"/\" . join ([ str ( _ ) for _ in error [ \"loc\" ]]) source = ErrorSource ( pointer = pointer ) code = error [ \"type\" ] detail = error [ \"msg\" ] errors . add ( OptimadeError ( detail = detail , status = status_code , title = str ( exc . __class__ . __name__ ), source = source , code = code , ) ) return general_exception ( request , exc , status_code = status_code , errors = list ( errors ))","title":"exception_handlers"},{"location":"api_reference/exception_handlers/#exception_handlers","text":"ASGI app exception handlers. These are in addition to the exception handlers available in OPTIMADE Python tools. For more information see https://www.optimade.org/optimade-python-tools/api_reference/server/exception_handlers/.","title":"exception_handlers"},{"location":"api_reference/exception_handlers/#optimade_gateway.exception_handlers.request_validation_exception_handler","text":"Special handler if a RequestValidationError comes from wrong POST data Source code in optimade_gateway/exception_handlers.py 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 async def request_validation_exception_handler ( request : \"Request\" , exc : \"RequestValidationError\" ) -> \"JSONResponse\" : \"\"\"Special handler if a `RequestValidationError` comes from wrong `POST` data\"\"\" status_code = 500 if request . method in ( \"POST\" , \"post\" ): status_code = 400 errors = set () for error in exc . errors (): pointer = \"/\" + \"/\" . join ([ str ( _ ) for _ in error [ \"loc\" ]]) source = ErrorSource ( pointer = pointer ) code = error [ \"type\" ] detail = error [ \"msg\" ] errors . add ( OptimadeError ( detail = detail , status = status_code , title = str ( exc . __class__ . __name__ ), source = source , code = code , ) ) return general_exception ( request , exc , status_code = status_code , errors = list ( errors ))","title":"request_validation_exception_handler()"},{"location":"api_reference/main/","text":"main \u00b6 The initialization of the ASGI FastAPI application. APP = FastAPI ( title = 'OPTIMADE Gateway' , description = 'A gateway server to query multiple OPTIMADE databases.' , version = __version__ ) module-attribute \u00b6 The FastAPI ASGI application. get_root ( request ) async \u00b6 GET / Introspective overview of gateway server. Note Temporarily redirecting to GET /docs . Source code in optimade_gateway/main.py 24 25 26 27 28 29 30 31 32 33 34 35 @APP . get ( \"/\" , include_in_schema = False ) async def get_root ( request : Request ) -> RedirectResponse : \"\"\"`GET /` Introspective overview of gateway server. !!! note Temporarily redirecting to `GET /docs`. \"\"\" return RedirectResponse ( request . url . replace ( path = f \" { request . url . path . strip ( '/' ) } /docs\" ) )","title":"main"},{"location":"api_reference/main/#main","text":"The initialization of the ASGI FastAPI application.","title":"main"},{"location":"api_reference/main/#optimade_gateway.main.APP","text":"The FastAPI ASGI application.","title":"APP"},{"location":"api_reference/main/#optimade_gateway.main.get_root","text":"GET / Introspective overview of gateway server. Note Temporarily redirecting to GET /docs . Source code in optimade_gateway/main.py 24 25 26 27 28 29 30 31 32 33 34 35 @APP . get ( \"/\" , include_in_schema = False ) async def get_root ( request : Request ) -> RedirectResponse : \"\"\"`GET /` Introspective overview of gateway server. !!! note Temporarily redirecting to `GET /docs`. \"\"\" return RedirectResponse ( request . url . replace ( path = f \" { request . url . path . strip ( '/' ) } /docs\" ) )","title":"get_root()"},{"location":"api_reference/middleware/","text":"middleware \u00b6 ASGI app middleware. These are in addition to the middleware available in OPTIMADE Python tools. For more information see https://www.optimade.org/optimade-python-tools/api_reference/server/middleware/. CheckWronglyVersionedBaseUrlsGateways \u00b6 Bases: BaseHTTPMiddleware If a non-supported versioned base URL is supplied to a gateway return 553 Version Not Supported . Source code in optimade_gateway/middleware.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class CheckWronglyVersionedBaseUrlsGateways ( BaseHTTPMiddleware ): \"\"\"If a non-supported versioned base URL is supplied to a gateway return `553 Version Not Supported`.\"\"\" @staticmethod async def check_url ( url : \"URL\" ): \"\"\"Check URL path for versioned part. Parameters: url: A complete `urllib`-parsed raw URL. Raises: VersionNotSupported: If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. \"\"\" base_url = get_base_url ( url ) optimade_path = f \" { url . scheme } :// { url . netloc }{ url . path } \" [ len ( base_url ) :] match = re . match ( r \"^/gateways/[^/\\s]+(?P<version>/v[0-9]+(\\.[0-9]+){0,2}).*\" , optimade_path ) if match is not None : if match . group ( \"version\" ) not in BASE_URL_PREFIXES . values (): raise VersionNotSupported ( detail = ( f \"The parsed versioned base URL { match . group ( 'version' ) !r} from \" f \" { url } is not supported by this implementation. \" \"Supported versioned base URLs are: \" f \" { ', ' . join ( BASE_URL_PREFIXES . values ()) } \" ) ) async def dispatch ( self , request : \"Request\" , call_next ): if request . url . path : await self . check_url ( request . url ) response = await call_next ( request ) return response check_url ( url ) async staticmethod \u00b6 Check URL path for versioned part. Parameters: Name Type Description Default url URL A complete urllib -parsed raw URL. required Raises: Type Description VersionNotSupported If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. Source code in optimade_gateway/middleware.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @staticmethod async def check_url ( url : \"URL\" ): \"\"\"Check URL path for versioned part. Parameters: url: A complete `urllib`-parsed raw URL. Raises: VersionNotSupported: If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. \"\"\" base_url = get_base_url ( url ) optimade_path = f \" { url . scheme } :// { url . netloc }{ url . path } \" [ len ( base_url ) :] match = re . match ( r \"^/gateways/[^/\\s]+(?P<version>/v[0-9]+(\\.[0-9]+){0,2}).*\" , optimade_path ) if match is not None : if match . group ( \"version\" ) not in BASE_URL_PREFIXES . values (): raise VersionNotSupported ( detail = ( f \"The parsed versioned base URL { match . group ( 'version' ) !r} from \" f \" { url } is not supported by this implementation. \" \"Supported versioned base URLs are: \" f \" { ', ' . join ( BASE_URL_PREFIXES . values ()) } \" ) )","title":"middleware"},{"location":"api_reference/middleware/#middleware","text":"ASGI app middleware. These are in addition to the middleware available in OPTIMADE Python tools. For more information see https://www.optimade.org/optimade-python-tools/api_reference/server/middleware/.","title":"middleware"},{"location":"api_reference/middleware/#optimade_gateway.middleware.CheckWronglyVersionedBaseUrlsGateways","text":"Bases: BaseHTTPMiddleware If a non-supported versioned base URL is supplied to a gateway return 553 Version Not Supported . Source code in optimade_gateway/middleware.py 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 class CheckWronglyVersionedBaseUrlsGateways ( BaseHTTPMiddleware ): \"\"\"If a non-supported versioned base URL is supplied to a gateway return `553 Version Not Supported`.\"\"\" @staticmethod async def check_url ( url : \"URL\" ): \"\"\"Check URL path for versioned part. Parameters: url: A complete `urllib`-parsed raw URL. Raises: VersionNotSupported: If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. \"\"\" base_url = get_base_url ( url ) optimade_path = f \" { url . scheme } :// { url . netloc }{ url . path } \" [ len ( base_url ) :] match = re . match ( r \"^/gateways/[^/\\s]+(?P<version>/v[0-9]+(\\.[0-9]+){0,2}).*\" , optimade_path ) if match is not None : if match . group ( \"version\" ) not in BASE_URL_PREFIXES . values (): raise VersionNotSupported ( detail = ( f \"The parsed versioned base URL { match . group ( 'version' ) !r} from \" f \" { url } is not supported by this implementation. \" \"Supported versioned base URLs are: \" f \" { ', ' . join ( BASE_URL_PREFIXES . values ()) } \" ) ) async def dispatch ( self , request : \"Request\" , call_next ): if request . url . path : await self . check_url ( request . url ) response = await call_next ( request ) return response","title":"CheckWronglyVersionedBaseUrlsGateways"},{"location":"api_reference/middleware/#optimade_gateway.middleware.CheckWronglyVersionedBaseUrlsGateways.check_url","text":"Check URL path for versioned part. Parameters: Name Type Description Default url URL A complete urllib -parsed raw URL. required Raises: Type Description VersionNotSupported If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. Source code in optimade_gateway/middleware.py 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 @staticmethod async def check_url ( url : \"URL\" ): \"\"\"Check URL path for versioned part. Parameters: url: A complete `urllib`-parsed raw URL. Raises: VersionNotSupported: If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. \"\"\" base_url = get_base_url ( url ) optimade_path = f \" { url . scheme } :// { url . netloc }{ url . path } \" [ len ( base_url ) :] match = re . match ( r \"^/gateways/[^/\\s]+(?P<version>/v[0-9]+(\\.[0-9]+){0,2}).*\" , optimade_path ) if match is not None : if match . group ( \"version\" ) not in BASE_URL_PREFIXES . values (): raise VersionNotSupported ( detail = ( f \"The parsed versioned base URL { match . group ( 'version' ) !r} from \" f \" { url } is not supported by this implementation. \" \"Supported versioned base URLs are: \" f \" { ', ' . join ( BASE_URL_PREFIXES . values ()) } \" ) )","title":"check_url()"},{"location":"api_reference/warnings/","text":"warnings \u00b6 Server warnings. The warnings in this module will all be caught by middleware and added to the response under meta.warnings . OptimadeGatewayWarning \u00b6 Bases: OptimadeWarning Base Warning for the optimade-gateway package. Source code in optimade_gateway/warnings.py 9 10 class OptimadeGatewayWarning ( OptimadeWarning ): \"\"\"Base Warning for the `optimade-gateway` package.\"\"\" SortNotSupported \u00b6 Bases: OptimadeGatewayWarning Sorting (the sort query parameter) is currently not supported for gateway queries to external OPTIMADE databases. See https://optimade.org/optimade-gateway#sorting for more information. Source code in optimade_gateway/warnings.py 13 14 15 16 class SortNotSupported ( OptimadeGatewayWarning ): \"\"\"Sorting (the `sort` query parameter) is currently not supported for gateway queries to external OPTIMADE databases. See https://optimade.org/optimade-gateway#sorting for more information.\"\"\"","title":"warnings"},{"location":"api_reference/warnings/#warnings","text":"Server warnings. The warnings in this module will all be caught by middleware and added to the response under meta.warnings .","title":"warnings"},{"location":"api_reference/warnings/#optimade_gateway.warnings.OptimadeGatewayWarning","text":"Bases: OptimadeWarning Base Warning for the optimade-gateway package. Source code in optimade_gateway/warnings.py 9 10 class OptimadeGatewayWarning ( OptimadeWarning ): \"\"\"Base Warning for the `optimade-gateway` package.\"\"\"","title":"OptimadeGatewayWarning"},{"location":"api_reference/warnings/#optimade_gateway.warnings.SortNotSupported","text":"Bases: OptimadeGatewayWarning Sorting (the sort query parameter) is currently not supported for gateway queries to external OPTIMADE databases. See https://optimade.org/optimade-gateway#sorting for more information. Source code in optimade_gateway/warnings.py 13 14 15 16 class SortNotSupported ( OptimadeGatewayWarning ): \"\"\"Sorting (the `sort` query parameter) is currently not supported for gateway queries to external OPTIMADE databases. See https://optimade.org/optimade-gateway#sorting for more information.\"\"\"","title":"SortNotSupported"},{"location":"api_reference/common/config/","text":"config \u00b6 Configuration of the FastAPI server. ServerConfig \u00b6 Bases: OptimadeServerConfig This class stores server config parameters in a way that can be easily extended for new config file types. Source code in optimade_gateway/common/config.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class ServerConfig ( OptimadeServerConfig ): \"\"\"This class stores server config parameters in a way that can be easily extended for new config file types. \"\"\" databases_collection : str = Field ( \"databases\" , description = \"Mongo collection name for `/databases` endpoint resources.\" , ) gateways_collection : str = Field ( \"gateways\" , description = \"Mongo collection name for `/gateways` endpoint resources.\" , ) queries_collection : str = Field ( \"queries\" , description = \"Mongo collection name for `/queries` endpoint resources.\" , ) load_optimade_providers_databases : bool = Field ( True , description = ( \"Whether or not to load all valid OPTIMADE providers' databases from the \" \"[Materials-Consortia list of OPTIMADE providers]\" \"(https://providers.optimade.org) on server startup.\" ), ) @validator ( \"mongo_uri\" ) def replace_with_env_vars ( cls , value : str ) -> str : \"\"\"Replace string variables with environment variables, if possible\"\"\" res = value for match in re . finditer ( r \"\\{[^ {} ]+\\}\" , value ): string_var = match . group ()[ 1 : - 1 ] env_var = os . getenv ( string_var , os . getenv ( string_var . upper (), os . getenv ( string_var . lower ())) ) if env_var is not None : res = res . replace ( match . group (), env_var ) else : warn ( OptimadeGatewayWarning ( detail = ( \"Could not find an environment variable for \" f \" { match . group () !r} from mongo_uri: { value } \" ) ) ) return res replace_with_env_vars ( value ) \u00b6 Replace string variables with environment variables, if possible Source code in optimade_gateway/common/config.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @validator ( \"mongo_uri\" ) def replace_with_env_vars ( cls , value : str ) -> str : \"\"\"Replace string variables with environment variables, if possible\"\"\" res = value for match in re . finditer ( r \"\\{[^ {} ]+\\}\" , value ): string_var = match . group ()[ 1 : - 1 ] env_var = os . getenv ( string_var , os . getenv ( string_var . upper (), os . getenv ( string_var . lower ())) ) if env_var is not None : res = res . replace ( match . group (), env_var ) else : warn ( OptimadeGatewayWarning ( detail = ( \"Could not find an environment variable for \" f \" { match . group () !r} from mongo_uri: { value } \" ) ) ) return res","title":"config"},{"location":"api_reference/common/config/#config","text":"Configuration of the FastAPI server.","title":"config"},{"location":"api_reference/common/config/#optimade_gateway.common.config.ServerConfig","text":"Bases: OptimadeServerConfig This class stores server config parameters in a way that can be easily extended for new config file types. Source code in optimade_gateway/common/config.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 class ServerConfig ( OptimadeServerConfig ): \"\"\"This class stores server config parameters in a way that can be easily extended for new config file types. \"\"\" databases_collection : str = Field ( \"databases\" , description = \"Mongo collection name for `/databases` endpoint resources.\" , ) gateways_collection : str = Field ( \"gateways\" , description = \"Mongo collection name for `/gateways` endpoint resources.\" , ) queries_collection : str = Field ( \"queries\" , description = \"Mongo collection name for `/queries` endpoint resources.\" , ) load_optimade_providers_databases : bool = Field ( True , description = ( \"Whether or not to load all valid OPTIMADE providers' databases from the \" \"[Materials-Consortia list of OPTIMADE providers]\" \"(https://providers.optimade.org) on server startup.\" ), ) @validator ( \"mongo_uri\" ) def replace_with_env_vars ( cls , value : str ) -> str : \"\"\"Replace string variables with environment variables, if possible\"\"\" res = value for match in re . finditer ( r \"\\{[^ {} ]+\\}\" , value ): string_var = match . group ()[ 1 : - 1 ] env_var = os . getenv ( string_var , os . getenv ( string_var . upper (), os . getenv ( string_var . lower ())) ) if env_var is not None : res = res . replace ( match . group (), env_var ) else : warn ( OptimadeGatewayWarning ( detail = ( \"Could not find an environment variable for \" f \" { match . group () !r} from mongo_uri: { value } \" ) ) ) return res","title":"ServerConfig"},{"location":"api_reference/common/config/#optimade_gateway.common.config.ServerConfig.replace_with_env_vars","text":"Replace string variables with environment variables, if possible Source code in optimade_gateway/common/config.py 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 @validator ( \"mongo_uri\" ) def replace_with_env_vars ( cls , value : str ) -> str : \"\"\"Replace string variables with environment variables, if possible\"\"\" res = value for match in re . finditer ( r \"\\{[^ {} ]+\\}\" , value ): string_var = match . group ()[ 1 : - 1 ] env_var = os . getenv ( string_var , os . getenv ( string_var . upper (), os . getenv ( string_var . lower ())) ) if env_var is not None : res = res . replace ( match . group (), env_var ) else : warn ( OptimadeGatewayWarning ( detail = ( \"Could not find an environment variable for \" f \" { match . group () !r} from mongo_uri: { value } \" ) ) ) return res","title":"replace_with_env_vars()"},{"location":"api_reference/common/exceptions/","text":"exceptions \u00b6 Specific OPTIMADE Gateway Python exceptions. OptimadeGatewayError \u00b6 Bases: Exception General OPTIMADE Gateway exception. Source code in optimade_gateway/common/exceptions.py 5 6 class OptimadeGatewayError ( Exception ): \"\"\"General OPTIMADE Gateway exception.\"\"\"","title":"exceptions"},{"location":"api_reference/common/exceptions/#exceptions","text":"Specific OPTIMADE Gateway Python exceptions.","title":"exceptions"},{"location":"api_reference/common/exceptions/#optimade_gateway.common.exceptions.OptimadeGatewayError","text":"Bases: Exception General OPTIMADE Gateway exception. Source code in optimade_gateway/common/exceptions.py 5 6 class OptimadeGatewayError ( Exception ): \"\"\"General OPTIMADE Gateway exception.\"\"\"","title":"OptimadeGatewayError"},{"location":"api_reference/common/logger/","text":"logger \u00b6 Logging to both file and console disable_logging () \u00b6 Temporarily disable logging. Usage: from optimade_gateway.common.logger import disable_logging # Do stuff, logging to all handlers. # ... with disable_logging (): # Do stuff, without logging to any handlers. # ... # Do stuff, logging to all handlers now re-enabled. # ... Source code in optimade_gateway/common/logger.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @contextmanager def disable_logging (): \"\"\"Temporarily disable logging. Usage: ```python from optimade_gateway.common.logger import disable_logging # Do stuff, logging to all handlers. # ... with disable_logging(): # Do stuff, without logging to any handlers. # ... # Do stuff, logging to all handlers now re-enabled. # ... ``` \"\"\" try : # Disable logging lower than CRITICAL level logging . disable ( logging . CRITICAL ) yield finally : # Re-enable logging to desired levels logging . disable ( logging . NOTSET )","title":"logger"},{"location":"api_reference/common/logger/#logger","text":"Logging to both file and console","title":"logger"},{"location":"api_reference/common/logger/#optimade_gateway.common.logger.disable_logging","text":"Temporarily disable logging. Usage: from optimade_gateway.common.logger import disable_logging # Do stuff, logging to all handlers. # ... with disable_logging (): # Do stuff, without logging to any handlers. # ... # Do stuff, logging to all handlers now re-enabled. # ... Source code in optimade_gateway/common/logger.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 @contextmanager def disable_logging (): \"\"\"Temporarily disable logging. Usage: ```python from optimade_gateway.common.logger import disable_logging # Do stuff, logging to all handlers. # ... with disable_logging(): # Do stuff, without logging to any handlers. # ... # Do stuff, logging to all handlers now re-enabled. # ... ``` \"\"\" try : # Disable logging lower than CRITICAL level logging . disable ( logging . CRITICAL ) yield finally : # Re-enable logging to desired levels logging . disable ( logging . NOTSET )","title":"disable_logging()"},{"location":"api_reference/common/utils/","text":"utils \u00b6 Common utility functions. These functions may be used in general throughout the OPTIMADE Gateway Python code. clean_python_types ( data ) async \u00b6 Turn any types into MongoDB-friendly Python types. Use dict() method for Pydantic models. Use value property for Enums. Turn tuples and sets into lists. Source code in optimade_gateway/common/utils.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 async def clean_python_types ( data : \"Any\" ) -> \"Any\" : \"\"\"Turn any types into MongoDB-friendly Python types. Use `dict()` method for Pydantic models. Use `value` property for Enums. Turn tuples and sets into lists. \"\"\" res : \"Any\" = None if isinstance ( data , ( list , tuple , set )): res = [] for datum in data : res . append ( await clean_python_types ( datum )) elif isinstance ( data , dict ): res = {} for key in list ( data . keys ()): res [ key ] = await clean_python_types ( data [ key ]) elif isinstance ( data , BaseModel ): # Pydantic model res = await clean_python_types ( data . dict ()) elif isinstance ( data , Enum ): res = await clean_python_types ( data . value ) elif isinstance ( data , type ): res = await clean_python_types ( f \" { data . __module__ } . { data . __name__ } \" ) else : # Unknown or other basic type, e.g., str, int, etc. res = data return res get_resource_attribute ( resource , field , default = None , disambiguate = True ) \u00b6 Return a resource's field's value Get the field value no matter if the resource is a pydantic model or a Python dictionary. Determine ambiguous field values and return them if desired ( disambiguate ). For example, if \"attributes.base_url\" is requested for a LinksResource it can be either a string, a Link model or a dictionary resembling the Link model. Parameters: Name Type Description Default resource Union[BaseModel, Dict[str, Any], None] The resource, from which to get the field value. required field str The resource field. This can be a dot-separated nested field, e.g., \"attributes.base_url\" . required default Any The default value to return if field does not exist. None disambiguate bool Whether or not to \"shortcut\" a field value. For example, for attributes.base_url , if True , this would return the string value or the value of it's \"href\" key. True Returns: Type Description Any The resource's field's value. Source code in optimade_gateway/common/utils.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def get_resource_attribute ( resource : \"Union[BaseModel, Dict[str, Any], None]\" , field : str , default : \"Any\" = None , disambiguate : bool = True , ) -> \"Any\" : \"\"\"Return a resource's field's value Get the field value no matter if the resource is a pydantic model or a Python dictionary. Determine ambiguous field values and return them if desired (`disambiguate`). For example, if [`\"attributes.base_url\"`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResourceAttributes.base_url) is requested for a [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) it can be either a string, a [`Link`](https://www.optimade.org/optimade-python-tools/api_reference/models/jsonapi/#optimade.models.jsonapi.Link) model or a dictionary resembling the `Link` model. Parameters: resource: The resource, from which to get the field value. field: The resource field. This can be a dot-separated nested field, e.g., `\"attributes.base_url\"`. default: The default value to return if `field` does not exist. disambiguate: Whether or not to \"shortcut\" a field value. For example, for `attributes.base_url`, if `True`, this would return the string value or the value of it's `\"href\"` key. Returns: The resource's field's value. \"\"\" if isinstance ( resource , BaseModel ): _get_attr = getattr elif isinstance ( resource , dict ): def _get_attr ( mapping : dict , key : str , default : \"Any\" ) -> \"Any\" : # type: ignore[misc] return mapping . get ( key , default ) elif resource is None : # Allow passing `None`, but simply return `default` return default else : raise TypeError ( \"resource must be either a pydantic model or a Python dictionary, it was of \" f \"type { type ( resource ) !r} \" ) fields = field . split ( \".\" ) for _ in fields [: - 1 ]: resource = _get_attr ( resource , _ , {}) field = fields [ - 1 ] value = _get_attr ( resource , field , default ) if disambiguate : if field in ( \"base_url\" , \"next\" , \"prev\" , \"last\" , \"first\" ): if not isinstance ( value , str ): value = _get_attr ( value , \"href\" , default ) return value","title":"utils"},{"location":"api_reference/common/utils/#utils","text":"Common utility functions. These functions may be used in general throughout the OPTIMADE Gateway Python code.","title":"utils"},{"location":"api_reference/common/utils/#optimade_gateway.common.utils.clean_python_types","text":"Turn any types into MongoDB-friendly Python types. Use dict() method for Pydantic models. Use value property for Enums. Turn tuples and sets into lists. Source code in optimade_gateway/common/utils.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 async def clean_python_types ( data : \"Any\" ) -> \"Any\" : \"\"\"Turn any types into MongoDB-friendly Python types. Use `dict()` method for Pydantic models. Use `value` property for Enums. Turn tuples and sets into lists. \"\"\" res : \"Any\" = None if isinstance ( data , ( list , tuple , set )): res = [] for datum in data : res . append ( await clean_python_types ( datum )) elif isinstance ( data , dict ): res = {} for key in list ( data . keys ()): res [ key ] = await clean_python_types ( data [ key ]) elif isinstance ( data , BaseModel ): # Pydantic model res = await clean_python_types ( data . dict ()) elif isinstance ( data , Enum ): res = await clean_python_types ( data . value ) elif isinstance ( data , type ): res = await clean_python_types ( f \" { data . __module__ } . { data . __name__ } \" ) else : # Unknown or other basic type, e.g., str, int, etc. res = data return res","title":"clean_python_types()"},{"location":"api_reference/common/utils/#optimade_gateway.common.utils.get_resource_attribute","text":"Return a resource's field's value Get the field value no matter if the resource is a pydantic model or a Python dictionary. Determine ambiguous field values and return them if desired ( disambiguate ). For example, if \"attributes.base_url\" is requested for a LinksResource it can be either a string, a Link model or a dictionary resembling the Link model. Parameters: Name Type Description Default resource Union[BaseModel, Dict[str, Any], None] The resource, from which to get the field value. required field str The resource field. This can be a dot-separated nested field, e.g., \"attributes.base_url\" . required default Any The default value to return if field does not exist. None disambiguate bool Whether or not to \"shortcut\" a field value. For example, for attributes.base_url , if True , this would return the string value or the value of it's \"href\" key. True Returns: Type Description Any The resource's field's value. Source code in optimade_gateway/common/utils.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 def get_resource_attribute ( resource : \"Union[BaseModel, Dict[str, Any], None]\" , field : str , default : \"Any\" = None , disambiguate : bool = True , ) -> \"Any\" : \"\"\"Return a resource's field's value Get the field value no matter if the resource is a pydantic model or a Python dictionary. Determine ambiguous field values and return them if desired (`disambiguate`). For example, if [`\"attributes.base_url\"`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResourceAttributes.base_url) is requested for a [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) it can be either a string, a [`Link`](https://www.optimade.org/optimade-python-tools/api_reference/models/jsonapi/#optimade.models.jsonapi.Link) model or a dictionary resembling the `Link` model. Parameters: resource: The resource, from which to get the field value. field: The resource field. This can be a dot-separated nested field, e.g., `\"attributes.base_url\"`. default: The default value to return if `field` does not exist. disambiguate: Whether or not to \"shortcut\" a field value. For example, for `attributes.base_url`, if `True`, this would return the string value or the value of it's `\"href\"` key. Returns: The resource's field's value. \"\"\" if isinstance ( resource , BaseModel ): _get_attr = getattr elif isinstance ( resource , dict ): def _get_attr ( mapping : dict , key : str , default : \"Any\" ) -> \"Any\" : # type: ignore[misc] return mapping . get ( key , default ) elif resource is None : # Allow passing `None`, but simply return `default` return default else : raise TypeError ( \"resource must be either a pydantic model or a Python dictionary, it was of \" f \"type { type ( resource ) !r} \" ) fields = field . split ( \".\" ) for _ in fields [: - 1 ]: resource = _get_attr ( resource , _ , {}) field = fields [ - 1 ] value = _get_attr ( resource , field , default ) if disambiguate : if field in ( \"base_url\" , \"next\" , \"prev\" , \"last\" , \"first\" ): if not isinstance ( value , str ): value = _get_attr ( value , \"href\" , default ) return value","title":"get_resource_attribute()"},{"location":"api_reference/mappers/base/","text":"base \u00b6 Base resource mapper. Based on the BaseResourceMapper in OPTIMADE Python tools. BaseResourceMapper \u00b6 Bases: OptimadeBaseResourceMapper Generic Resource Mapper that defines and performs the mapping between objects in the database and the resource objects defined by the specification. Note This is a \"wrapped\" sub-class to make certain methods asynchronous. Attributes: Name Type Description ALIASES a tuple of aliases between OPTIMADE field names and the field names in the database , e.g. ((\"elements\", \"custom_elements_field\")) . LENGTH_ALIASES a tuple of aliases between a field name and another field that defines its length, to be used when querying, e.g. ((\"elements\", \"nelements\")) . e.g. ((\"elements\", \"custom_elements_field\")) . ENTRY_RESOURCE_CLASS The entry type that this mapper corresponds to. PROVIDER_FIELDS a tuple of extra field names that this mapper should support when querying with the database prefix. TOP_LEVEL_NON_ATTRIBUTES_FIELDS the set of top-level field names common to all endpoints. SUPPORTED_PREFIXES The set of prefixes registered by this mapper. ALL_ATTRIBUTES The set of attributes defined across the entry resource class and the server configuration. ENTRY_RESOURCE_ATTRIBUTES A dictionary of attributes and their definitions defined by the schema of the entry resource class. ENDPOINT The expected endpoint name for this resource, as defined by the type in the schema of the entry resource class. Source code in optimade_gateway/mappers/base.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BaseResourceMapper ( OptimadeBaseResourceMapper ): \"\"\" Generic Resource Mapper that defines and performs the mapping between objects in the database and the resource objects defined by the specification. Note: This is a \"wrapped\" sub-class to make certain methods asynchronous. Attributes: ALIASES: a tuple of aliases between OPTIMADE field names and the field names in the database , e.g. `((\"elements\", \"custom_elements_field\"))`. LENGTH_ALIASES: a tuple of aliases between a field name and another field that defines its length, to be used when querying, e.g. `((\"elements\", \"nelements\"))`. e.g. `((\"elements\", \"custom_elements_field\"))`. ENTRY_RESOURCE_CLASS: The entry type that this mapper corresponds to. PROVIDER_FIELDS: a tuple of extra field names that this mapper should support when querying with the database prefix. TOP_LEVEL_NON_ATTRIBUTES_FIELDS: the set of top-level field names common to all endpoints. SUPPORTED_PREFIXES: The set of prefixes registered by this mapper. ALL_ATTRIBUTES: The set of attributes defined across the entry resource class and the server configuration. ENTRY_RESOURCE_ATTRIBUTES: A dictionary of attributes and their definitions defined by the schema of the entry resource class. ENDPOINT: The expected endpoint name for this resource, as defined by the `type` in the schema of the entry resource class. \"\"\" @classmethod async def adeserialize ( cls , results : \"Union[dict, Iterable[dict]]\" ) -> \"Union[List[EntryResource], EntryResource]\" : \"\"\"Asynchronous version of the `deserialize()` class method. Parameters: results: A list of or a single dictionary, representing an entry-endpoint resource. Returns: The deserialized list of or single pydantic resource model for the input `results`. \"\"\" return super ( BaseResourceMapper , cls ) . deserialize ( results ) @classmethod def map_back ( cls , doc : dict ) -> dict : from optimade.server.routers.utils import BASE_URL_PREFIXES if \"_id\" in doc : _id = str ( doc . pop ( \"_id\" )) if \"id\" not in doc : doc [ \"id\" ] = _id doc [ \"links\" ] = { \"self\" : AnyUrl ( url = ( f \" { CONFIG . base_url . strip ( '/' ) }{ BASE_URL_PREFIXES [ 'major' ] } \" f \"/ { cls . ENDPOINT } / { doc [ 'id' ] } \" ), scheme = CONFIG . base_url . split ( \"://\" , maxsplit = 1 )[ 0 ], host = CONFIG . base_url . split ( \"://\" , maxsplit = 2 )[ 1 ] . split ( \"/\" )[ 0 ], ) } return super () . map_back ( doc ) adeserialize ( results ) async classmethod \u00b6 Asynchronous version of the deserialize() class method. Parameters: Name Type Description Default results Union[dict, Iterable[dict]] A list of or a single dictionary, representing an entry-endpoint resource. required Returns: Type Description Union[List[EntryResource], EntryResource] The deserialized list of or single pydantic resource model for the input Union[List[EntryResource], EntryResource] results . Source code in optimade_gateway/mappers/base.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @classmethod async def adeserialize ( cls , results : \"Union[dict, Iterable[dict]]\" ) -> \"Union[List[EntryResource], EntryResource]\" : \"\"\"Asynchronous version of the `deserialize()` class method. Parameters: results: A list of or a single dictionary, representing an entry-endpoint resource. Returns: The deserialized list of or single pydantic resource model for the input `results`. \"\"\" return super ( BaseResourceMapper , cls ) . deserialize ( results )","title":"base"},{"location":"api_reference/mappers/base/#base","text":"Base resource mapper. Based on the BaseResourceMapper in OPTIMADE Python tools.","title":"base"},{"location":"api_reference/mappers/base/#optimade_gateway.mappers.base.BaseResourceMapper","text":"Bases: OptimadeBaseResourceMapper Generic Resource Mapper that defines and performs the mapping between objects in the database and the resource objects defined by the specification. Note This is a \"wrapped\" sub-class to make certain methods asynchronous. Attributes: Name Type Description ALIASES a tuple of aliases between OPTIMADE field names and the field names in the database , e.g. ((\"elements\", \"custom_elements_field\")) . LENGTH_ALIASES a tuple of aliases between a field name and another field that defines its length, to be used when querying, e.g. ((\"elements\", \"nelements\")) . e.g. ((\"elements\", \"custom_elements_field\")) . ENTRY_RESOURCE_CLASS The entry type that this mapper corresponds to. PROVIDER_FIELDS a tuple of extra field names that this mapper should support when querying with the database prefix. TOP_LEVEL_NON_ATTRIBUTES_FIELDS the set of top-level field names common to all endpoints. SUPPORTED_PREFIXES The set of prefixes registered by this mapper. ALL_ATTRIBUTES The set of attributes defined across the entry resource class and the server configuration. ENTRY_RESOURCE_ATTRIBUTES A dictionary of attributes and their definitions defined by the schema of the entry resource class. ENDPOINT The expected endpoint name for this resource, as defined by the type in the schema of the entry resource class. Source code in optimade_gateway/mappers/base.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 class BaseResourceMapper ( OptimadeBaseResourceMapper ): \"\"\" Generic Resource Mapper that defines and performs the mapping between objects in the database and the resource objects defined by the specification. Note: This is a \"wrapped\" sub-class to make certain methods asynchronous. Attributes: ALIASES: a tuple of aliases between OPTIMADE field names and the field names in the database , e.g. `((\"elements\", \"custom_elements_field\"))`. LENGTH_ALIASES: a tuple of aliases between a field name and another field that defines its length, to be used when querying, e.g. `((\"elements\", \"nelements\"))`. e.g. `((\"elements\", \"custom_elements_field\"))`. ENTRY_RESOURCE_CLASS: The entry type that this mapper corresponds to. PROVIDER_FIELDS: a tuple of extra field names that this mapper should support when querying with the database prefix. TOP_LEVEL_NON_ATTRIBUTES_FIELDS: the set of top-level field names common to all endpoints. SUPPORTED_PREFIXES: The set of prefixes registered by this mapper. ALL_ATTRIBUTES: The set of attributes defined across the entry resource class and the server configuration. ENTRY_RESOURCE_ATTRIBUTES: A dictionary of attributes and their definitions defined by the schema of the entry resource class. ENDPOINT: The expected endpoint name for this resource, as defined by the `type` in the schema of the entry resource class. \"\"\" @classmethod async def adeserialize ( cls , results : \"Union[dict, Iterable[dict]]\" ) -> \"Union[List[EntryResource], EntryResource]\" : \"\"\"Asynchronous version of the `deserialize()` class method. Parameters: results: A list of or a single dictionary, representing an entry-endpoint resource. Returns: The deserialized list of or single pydantic resource model for the input `results`. \"\"\" return super ( BaseResourceMapper , cls ) . deserialize ( results ) @classmethod def map_back ( cls , doc : dict ) -> dict : from optimade.server.routers.utils import BASE_URL_PREFIXES if \"_id\" in doc : _id = str ( doc . pop ( \"_id\" )) if \"id\" not in doc : doc [ \"id\" ] = _id doc [ \"links\" ] = { \"self\" : AnyUrl ( url = ( f \" { CONFIG . base_url . strip ( '/' ) }{ BASE_URL_PREFIXES [ 'major' ] } \" f \"/ { cls . ENDPOINT } / { doc [ 'id' ] } \" ), scheme = CONFIG . base_url . split ( \"://\" , maxsplit = 1 )[ 0 ], host = CONFIG . base_url . split ( \"://\" , maxsplit = 2 )[ 1 ] . split ( \"/\" )[ 0 ], ) } return super () . map_back ( doc )","title":"BaseResourceMapper"},{"location":"api_reference/mappers/base/#optimade_gateway.mappers.base.BaseResourceMapper.adeserialize","text":"Asynchronous version of the deserialize() class method. Parameters: Name Type Description Default results Union[dict, Iterable[dict]] A list of or a single dictionary, representing an entry-endpoint resource. required Returns: Type Description Union[List[EntryResource], EntryResource] The deserialized list of or single pydantic resource model for the input Union[List[EntryResource], EntryResource] results . Source code in optimade_gateway/mappers/base.py 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 @classmethod async def adeserialize ( cls , results : \"Union[dict, Iterable[dict]]\" ) -> \"Union[List[EntryResource], EntryResource]\" : \"\"\"Asynchronous version of the `deserialize()` class method. Parameters: results: A list of or a single dictionary, representing an entry-endpoint resource. Returns: The deserialized list of or single pydantic resource model for the input `results`. \"\"\" return super ( BaseResourceMapper , cls ) . deserialize ( results )","title":"adeserialize()"},{"location":"api_reference/mappers/databases/","text":"databases \u00b6 Resource mapper for resources under /databases . These resources are LinksResource s. DatabasesMapper \u00b6 Bases: LinksMapper /databases -endpoint resources mapper. Source code in optimade_gateway/mappers/databases.py 9 10 11 12 class DatabasesMapper ( LinksMapper ): \"\"\"`/databases`-endpoint resources mapper.\"\"\" ENDPOINT = \"databases\"","title":"databases"},{"location":"api_reference/mappers/databases/#databases","text":"Resource mapper for resources under /databases . These resources are LinksResource s.","title":"databases"},{"location":"api_reference/mappers/databases/#optimade_gateway.mappers.databases.DatabasesMapper","text":"Bases: LinksMapper /databases -endpoint resources mapper. Source code in optimade_gateway/mappers/databases.py 9 10 11 12 class DatabasesMapper ( LinksMapper ): \"\"\"`/databases`-endpoint resources mapper.\"\"\" ENDPOINT = \"databases\"","title":"DatabasesMapper"},{"location":"api_reference/mappers/gateways/","text":"gateways \u00b6 Resource mapper for GatewayResource . GatewaysMapper \u00b6 Bases: BaseResourceMapper GatewayResource mapper. Source code in optimade_gateway/mappers/gateways.py 7 8 9 10 11 class GatewaysMapper ( BaseResourceMapper ): \"\"\"[`GatewayResource`][optimade_gateway.models.gateways.GatewayResource] mapper.\"\"\" ENDPOINT = \"gateways\" ENTRY_RESOURCE_CLASS = GatewayResource","title":"gateways"},{"location":"api_reference/mappers/gateways/#gateways","text":"Resource mapper for GatewayResource .","title":"gateways"},{"location":"api_reference/mappers/gateways/#optimade_gateway.mappers.gateways.GatewaysMapper","text":"Bases: BaseResourceMapper GatewayResource mapper. Source code in optimade_gateway/mappers/gateways.py 7 8 9 10 11 class GatewaysMapper ( BaseResourceMapper ): \"\"\"[`GatewayResource`][optimade_gateway.models.gateways.GatewayResource] mapper.\"\"\" ENDPOINT = \"gateways\" ENTRY_RESOURCE_CLASS = GatewayResource","title":"GatewaysMapper"},{"location":"api_reference/mappers/links/","text":"links \u00b6 Replicate of LinksMapper in OPTIMADE Python tools. LinksMapper \u00b6 Bases: BaseResourceMapper Replicate of LinksMapper in OPTIMADE Python tools. This is based on the OPTIMADE Gateway BaseResourceMapper however. Source code in optimade_gateway/mappers/links.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class LinksMapper ( BaseResourceMapper ): \"\"\"Replicate of [`LinksMapper`](https://www.optimade.org/optimade-python-tools/api_reference/server/mappers/links/#optimade.server.mappers.links.LinksMapper) in OPTIMADE Python tools. This is based on the OPTIMADE Gateway [`BaseResourceMapper`][optimade_gateway.mappers.base.BaseResourceMapper] however. \"\"\" ENDPOINT = \"links\" ENTRY_RESOURCE_CLASS = LinksResource @classmethod def map_back ( cls , doc : dict ) -> dict : type_ = doc . get ( \"type\" , None ) or \"links\" newdoc = super () . map_back ( doc ) newdoc [ \"type\" ] = type_ return newdoc","title":"links"},{"location":"api_reference/mappers/links/#links","text":"Replicate of LinksMapper in OPTIMADE Python tools.","title":"links"},{"location":"api_reference/mappers/links/#optimade_gateway.mappers.links.LinksMapper","text":"Bases: BaseResourceMapper Replicate of LinksMapper in OPTIMADE Python tools. This is based on the OPTIMADE Gateway BaseResourceMapper however. Source code in optimade_gateway/mappers/links.py 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 class LinksMapper ( BaseResourceMapper ): \"\"\"Replicate of [`LinksMapper`](https://www.optimade.org/optimade-python-tools/api_reference/server/mappers/links/#optimade.server.mappers.links.LinksMapper) in OPTIMADE Python tools. This is based on the OPTIMADE Gateway [`BaseResourceMapper`][optimade_gateway.mappers.base.BaseResourceMapper] however. \"\"\" ENDPOINT = \"links\" ENTRY_RESOURCE_CLASS = LinksResource @classmethod def map_back ( cls , doc : dict ) -> dict : type_ = doc . get ( \"type\" , None ) or \"links\" newdoc = super () . map_back ( doc ) newdoc [ \"type\" ] = type_ return newdoc","title":"LinksMapper"},{"location":"api_reference/mappers/queries/","text":"queries \u00b6 Resource mapper for QueryResource . QueryMapper \u00b6 Bases: BaseResourceMapper QueryResource mapper. Source code in optimade_gateway/mappers/queries.py 7 8 9 10 11 class QueryMapper ( BaseResourceMapper ): \"\"\"[`QueryResource`][optimade_gateway.models.queries.QueryResource] mapper.\"\"\" ENDPOINT = \"queries\" ENTRY_RESOURCE_CLASS = QueryResource","title":"queries"},{"location":"api_reference/mappers/queries/#queries","text":"Resource mapper for QueryResource .","title":"queries"},{"location":"api_reference/mappers/queries/#optimade_gateway.mappers.queries.QueryMapper","text":"Bases: BaseResourceMapper QueryResource mapper. Source code in optimade_gateway/mappers/queries.py 7 8 9 10 11 class QueryMapper ( BaseResourceMapper ): \"\"\"[`QueryResource`][optimade_gateway.models.queries.QueryResource] mapper.\"\"\" ENDPOINT = \"queries\" ENTRY_RESOURCE_CLASS = QueryResource","title":"QueryMapper"},{"location":"api_reference/models/databases/","text":"databases \u00b6 Pydantic models/schemas for the LinksResource used in /databases DatabaseCreate \u00b6 Bases: EntryResourceCreate , LinksResourceAttributes Model for creating new LinksResources representing /databases resources in the MongoDB. Required fields: name base_url Original required fields for a LinksResourceAttributes model: name description link_type Source code in optimade_gateway/models/databases.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class DatabaseCreate ( EntryResourceCreate , LinksResourceAttributes ): \"\"\"Model for creating new LinksResources representing `/databases` resources in the MongoDB. Required fields: - `name` - `base_url` Original required fields for a [`LinksResourceAttributes`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResourceAttributes) model: - `name` - `description` - `link_type` \"\"\" description : Optional [ str ] base_url : Union [ AnyUrl , Link ] homepage : Optional [ Union [ AnyUrl , Link ]] = StrictField ( None , description = ( \"JSON API links object, pointing to a homepage URL for this implementation.\" ), ) link_type : Optional [ LinkType ] = StrictField ( None , title = \"Link Type\" , description = ( \"The type of the linked relation. \\n MUST be one of these values: 'child', \" \"'root', 'external', 'providers'.\" ), ) @validator ( \"link_type\" ) def ensure_database_link_type ( cls , value : LinkType ) -> LinkType : \"\"\"Ensure databases are not index meta-database-only types I.e., ensure they're not of type `\"root\"` or `\"providers\"`. !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for \" f \"gateway-usable database resources. Given link_type: { value } \" ) return value base_url : Union [ AnyUrl , Link ] class-attribute \u00b6 description : Optional [ str ] class-attribute \u00b6 homepage : Optional [ Union [ AnyUrl , Link ]] = StrictField ( None , description = 'JSON API links object, pointing to a homepage URL for this implementation.' ) class-attribute \u00b6 link_type : Optional [ LinkType ] = StrictField ( None , title = 'Link Type' , description = \"The type of the linked relation. \\n MUST be one of these values: 'child', 'root', 'external', 'providers'.\" ) class-attribute \u00b6 ensure_database_link_type ( value ) \u00b6 Ensure databases are not index meta-database-only types I.e., ensure they're not of type \"root\" or \"providers\" . Note Both \"external\" and \"child\" can still represent index meta-dbs, but \"root\" and \"providers\" can not represent \"regular\" dbs. Source code in optimade_gateway/models/databases.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @validator ( \"link_type\" ) def ensure_database_link_type ( cls , value : LinkType ) -> LinkType : \"\"\"Ensure databases are not index meta-database-only types I.e., ensure they're not of type `\"root\"` or `\"providers\"`. !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for \" f \"gateway-usable database resources. Given link_type: { value } \" ) return value","title":"databases"},{"location":"api_reference/models/databases/#databases","text":"Pydantic models/schemas for the LinksResource used in /databases","title":"databases"},{"location":"api_reference/models/databases/#optimade_gateway.models.databases.DatabaseCreate","text":"Bases: EntryResourceCreate , LinksResourceAttributes Model for creating new LinksResources representing /databases resources in the MongoDB. Required fields: name base_url Original required fields for a LinksResourceAttributes model: name description link_type Source code in optimade_gateway/models/databases.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 class DatabaseCreate ( EntryResourceCreate , LinksResourceAttributes ): \"\"\"Model for creating new LinksResources representing `/databases` resources in the MongoDB. Required fields: - `name` - `base_url` Original required fields for a [`LinksResourceAttributes`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResourceAttributes) model: - `name` - `description` - `link_type` \"\"\" description : Optional [ str ] base_url : Union [ AnyUrl , Link ] homepage : Optional [ Union [ AnyUrl , Link ]] = StrictField ( None , description = ( \"JSON API links object, pointing to a homepage URL for this implementation.\" ), ) link_type : Optional [ LinkType ] = StrictField ( None , title = \"Link Type\" , description = ( \"The type of the linked relation. \\n MUST be one of these values: 'child', \" \"'root', 'external', 'providers'.\" ), ) @validator ( \"link_type\" ) def ensure_database_link_type ( cls , value : LinkType ) -> LinkType : \"\"\"Ensure databases are not index meta-database-only types I.e., ensure they're not of type `\"root\"` or `\"providers\"`. !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for \" f \"gateway-usable database resources. Given link_type: { value } \" ) return value","title":"DatabaseCreate"},{"location":"api_reference/models/databases/#optimade_gateway.models.databases.DatabaseCreate.base_url","text":"","title":"base_url"},{"location":"api_reference/models/databases/#optimade_gateway.models.databases.DatabaseCreate.description","text":"","title":"description"},{"location":"api_reference/models/databases/#optimade_gateway.models.databases.DatabaseCreate.homepage","text":"","title":"homepage"},{"location":"api_reference/models/databases/#optimade_gateway.models.databases.DatabaseCreate.link_type","text":"","title":"link_type"},{"location":"api_reference/models/databases/#optimade_gateway.models.databases.DatabaseCreate.ensure_database_link_type","text":"Ensure databases are not index meta-database-only types I.e., ensure they're not of type \"root\" or \"providers\" . Note Both \"external\" and \"child\" can still represent index meta-dbs, but \"root\" and \"providers\" can not represent \"regular\" dbs. Source code in optimade_gateway/models/databases.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 @validator ( \"link_type\" ) def ensure_database_link_type ( cls , value : LinkType ) -> LinkType : \"\"\"Ensure databases are not index meta-database-only types I.e., ensure they're not of type `\"root\"` or `\"providers\"`. !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for \" f \"gateway-usable database resources. Given link_type: { value } \" ) return value","title":"ensure_database_link_type()"},{"location":"api_reference/models/gateways/","text":"gateways \u00b6 Pydantic models/schemas for the Gateways resource. GatewayCreate \u00b6 Bases: EntryResourceCreate , GatewayResourceAttributes Model for creating new Gateway resources in the MongoDB Source code in optimade_gateway/models/gateways.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class GatewayCreate ( EntryResourceCreate , GatewayResourceAttributes ): \"\"\"Model for creating new Gateway resources in the MongoDB\"\"\" id : Optional [ str ] = OptimadeField ( None , description = \"\"\"An entry's ID as defined in section Definition of Terms. - **Type**: string. - **Requirements/Conventions**: - **Support**: MUST be supported by all implementations, MUST NOT be `null`. - **Query**: MUST be a queryable property with support for all mandatory filter features. - **Response**: REQUIRED in the response. - **Gateway-specific**: MUST NOT contain a forward slash (`/`). - **Examples**: - `\"db_1234567\"` - `\"cod_2000000\"` - `\"cod_2000000@1234567\"` - `\"nomad_L1234567890\"` - `\"42\"`\"\"\" , support = SupportLevel . MUST , queryable = SupportLevel . MUST , regex = r \"^[^/]*$\" , # This regex is the special addition ) database_ids : Optional [ Set [ str ]] = Field ( None , description = \"A unique list of database IDs for registered databases.\" ) databases : Optional [ List [ LinksResource ]] # type: ignore @root_validator def specify_databases ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `databases` must be non-empty. Both together is also fine. \"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"databases\" )): raise ValueError ( \"Either 'database_ids' or 'databases' MUST be specified\" ) return values database_ids : Optional [ Set [ str ]] = Field ( None , description = 'A unique list of database IDs for registered databases.' ) class-attribute \u00b6 databases : Optional [ List [ LinksResource ]] class-attribute \u00b6 id : Optional [ str ] = OptimadeField ( None , description = 'An entry \\' s ID as defined in section Definition of Terms. \\n\\n - **Type**: string. \\n\\n - **Requirements/Conventions**: \\n - **Support**: MUST be supported by all implementations, MUST NOT be `null`. \\n - **Query**: MUST be a queryable property with support for all mandatory filter \\n features. \\n - **Response**: REQUIRED in the response. \\n - **Gateway-specific**: MUST NOT contain a forward slash (`/`). \\n\\n - **Examples**: \\n - `\"db_1234567\"` \\n - `\"cod_2000000\"` \\n - `\"cod_2000000@1234567\"` \\n - `\"nomad_L1234567890\"` \\n - `\"42\"`' , support = SupportLevel . MUST , queryable = SupportLevel . MUST , regex = '^[^/]*$' ) class-attribute \u00b6 specify_databases ( values ) \u00b6 Either database_ids or databases must be non-empty. Both together is also fine. Source code in optimade_gateway/models/gateways.py 145 146 147 148 149 150 151 152 @root_validator def specify_databases ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `databases` must be non-empty. Both together is also fine. \"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"databases\" )): raise ValueError ( \"Either 'database_ids' or 'databases' MUST be specified\" ) return values GatewayResource \u00b6 Bases: EntryResource OPTIMADE gateway A resource representing a dynamic collection of OPTIMADE databases. The gateway can be treated as any other OPTIMADE gateway, but the entries are an aggregate of multiple databases. The id of each aggregated resource will reflect the originating database. Source code in optimade_gateway/models/gateways.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 class GatewayResource ( EntryResource ): \"\"\"OPTIMADE gateway A resource representing a dynamic collection of OPTIMADE databases. The gateway can be treated as any other OPTIMADE gateway, but the entries are an aggregate of multiple databases. The `id` of each aggregated resource will reflect the originating database. \"\"\" id : str = OptimadeField ( ... , description = \"\"\"An entry's ID as defined in section Definition of Terms. - **Type**: string. - **Requirements/Conventions**: - **Support**: MUST be supported by all implementations, MUST NOT be `null`. - **Query**: MUST be a queryable property with support for all mandatory filter features. - **Response**: REQUIRED in the response. - **Gateway-specific**: MUST NOT contain a forward slash (`/`). - **Examples**: - `\"db_1234567\"` - `\"cod_2000000\"` - `\"cod_2000000@1234567\"` - `\"nomad_L1234567890\"` - `\"42\"`\"\"\" , support = SupportLevel . MUST , queryable = SupportLevel . MUST , regex = r \"^[^/]*$\" , ) type : str = Field ( \"gateways\" , const = True , description = \"The name of the type of an entry.\" , regex = \"^gateways$\" , ) attributes : GatewayResourceAttributes attributes : GatewayResourceAttributes class-attribute \u00b6 id : str = OptimadeField ( Ellipsis , description = 'An entry \\' s ID as defined in section Definition of Terms. \\n\\n - **Type**: string. \\n\\n - **Requirements/Conventions**: \\n - **Support**: MUST be supported by all implementations, MUST NOT be `null`. \\n - **Query**: MUST be a queryable property with support for all mandatory filter \\n features. \\n - **Response**: REQUIRED in the response. \\n - **Gateway-specific**: MUST NOT contain a forward slash (`/`). \\n\\n - **Examples**: \\n - `\"db_1234567\"` \\n - `\"cod_2000000\"` \\n - `\"cod_2000000@1234567\"` \\n - `\"nomad_L1234567890\"` \\n - `\"42\"`' , support = SupportLevel . MUST , queryable = SupportLevel . MUST , regex = '^[^/]*$' ) class-attribute \u00b6 type : str = Field ( 'gateways' , const = True , description = 'The name of the type of an entry.' , regex = '^gateways$' ) class-attribute \u00b6 GatewayResourceAttributes \u00b6 Bases: EntryResourceAttributes Attributes for an OPTIMADE gateway Source code in optimade_gateway/models/gateways.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class GatewayResourceAttributes ( EntryResourceAttributes ): \"\"\"Attributes for an OPTIMADE gateway\"\"\" databases : List [ LinksResource ] = Field ( ... , description = \"List of databases (OPTIMADE 'links') to be queried in this gateway.\" , ) @validator ( \"databases\" , each_item = True ) def no_index_databases ( cls , value : LinksResource ) -> LinksResource : \"\"\"Ensure databases are not of type `\"root\"` or `\"providers\"` !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value . attributes . link_type in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for \" f \"gateway resources. Given database: { value } \" ) return value @validator ( \"databases\" ) def unique_base_urls ( cls , value : List [ LinksResource ]) -> List [ LinksResource ]: \"\"\"Remove extra entries with repeated base_urls\"\"\" db_base_urls = [ _ . attributes . base_url for _ in value ] unique_base_urls = set ( db_base_urls ) if len ( db_base_urls ) == len ( unique_base_urls ): return value repeated_base_urls = [ _ for _ in unique_base_urls if db_base_urls . count ( _ ) > 1 ] new_databases = [ _ for _ in value if _ . attributes . base_url not in repeated_base_urls ] for base_url in repeated_base_urls : new_databases . append ( [ _ for _ in value if _ . attributes . base_url == base_url ][ 0 ] ) warnings . warn ( \"Removed extra database entries for a gateway, because the base_url was \" \"repeated. The first found database entry was kept, while the others were \" f \"removed. Original number of databases: { len ( value ) } . New number of \" f \"databases: { len ( new_databases ) } Repeated base_urls (number of repeats): \" \" {} \" . format ( [ f \" { base_url } ( { db_base_urls . count ( base_url ) } )\" for base_url in repeated_base_urls ] ), OptimadeGatewayWarning , ) return new_databases databases : List [ LinksResource ] = Field ( Ellipsis , description = \"List of databases (OPTIMADE 'links') to be queried in this gateway.\" ) class-attribute \u00b6 no_index_databases ( value ) \u00b6 Ensure databases are not of type \"root\" or \"providers\" Note Both \"external\" and \"child\" can still represent index meta-dbs, but \"root\" and \"providers\" can not represent \"regular\" dbs. Source code in optimade_gateway/models/gateways.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @validator ( \"databases\" , each_item = True ) def no_index_databases ( cls , value : LinksResource ) -> LinksResource : \"\"\"Ensure databases are not of type `\"root\"` or `\"providers\"` !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value . attributes . link_type in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for \" f \"gateway resources. Given database: { value } \" ) return value unique_base_urls ( value ) \u00b6 Remove extra entries with repeated base_urls Source code in optimade_gateway/models/gateways.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @validator ( \"databases\" ) def unique_base_urls ( cls , value : List [ LinksResource ]) -> List [ LinksResource ]: \"\"\"Remove extra entries with repeated base_urls\"\"\" db_base_urls = [ _ . attributes . base_url for _ in value ] unique_base_urls = set ( db_base_urls ) if len ( db_base_urls ) == len ( unique_base_urls ): return value repeated_base_urls = [ _ for _ in unique_base_urls if db_base_urls . count ( _ ) > 1 ] new_databases = [ _ for _ in value if _ . attributes . base_url not in repeated_base_urls ] for base_url in repeated_base_urls : new_databases . append ( [ _ for _ in value if _ . attributes . base_url == base_url ][ 0 ] ) warnings . warn ( \"Removed extra database entries for a gateway, because the base_url was \" \"repeated. The first found database entry was kept, while the others were \" f \"removed. Original number of databases: { len ( value ) } . New number of \" f \"databases: { len ( new_databases ) } Repeated base_urls (number of repeats): \" \" {} \" . format ( [ f \" { base_url } ( { db_base_urls . count ( base_url ) } )\" for base_url in repeated_base_urls ] ), OptimadeGatewayWarning , ) return new_databases","title":"gateways"},{"location":"api_reference/models/gateways/#gateways","text":"Pydantic models/schemas for the Gateways resource.","title":"gateways"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayCreate","text":"Bases: EntryResourceCreate , GatewayResourceAttributes Model for creating new Gateway resources in the MongoDB Source code in optimade_gateway/models/gateways.py 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 class GatewayCreate ( EntryResourceCreate , GatewayResourceAttributes ): \"\"\"Model for creating new Gateway resources in the MongoDB\"\"\" id : Optional [ str ] = OptimadeField ( None , description = \"\"\"An entry's ID as defined in section Definition of Terms. - **Type**: string. - **Requirements/Conventions**: - **Support**: MUST be supported by all implementations, MUST NOT be `null`. - **Query**: MUST be a queryable property with support for all mandatory filter features. - **Response**: REQUIRED in the response. - **Gateway-specific**: MUST NOT contain a forward slash (`/`). - **Examples**: - `\"db_1234567\"` - `\"cod_2000000\"` - `\"cod_2000000@1234567\"` - `\"nomad_L1234567890\"` - `\"42\"`\"\"\" , support = SupportLevel . MUST , queryable = SupportLevel . MUST , regex = r \"^[^/]*$\" , # This regex is the special addition ) database_ids : Optional [ Set [ str ]] = Field ( None , description = \"A unique list of database IDs for registered databases.\" ) databases : Optional [ List [ LinksResource ]] # type: ignore @root_validator def specify_databases ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `databases` must be non-empty. Both together is also fine. \"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"databases\" )): raise ValueError ( \"Either 'database_ids' or 'databases' MUST be specified\" ) return values","title":"GatewayCreate"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayCreate.database_ids","text":"","title":"database_ids"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayCreate.databases","text":"","title":"databases"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayCreate.id","text":"","title":"id"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayCreate.specify_databases","text":"Either database_ids or databases must be non-empty. Both together is also fine. Source code in optimade_gateway/models/gateways.py 145 146 147 148 149 150 151 152 @root_validator def specify_databases ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `databases` must be non-empty. Both together is also fine. \"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"databases\" )): raise ValueError ( \"Either 'database_ids' or 'databases' MUST be specified\" ) return values","title":"specify_databases()"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResource","text":"Bases: EntryResource OPTIMADE gateway A resource representing a dynamic collection of OPTIMADE databases. The gateway can be treated as any other OPTIMADE gateway, but the entries are an aggregate of multiple databases. The id of each aggregated resource will reflect the originating database. Source code in optimade_gateway/models/gateways.py 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 class GatewayResource ( EntryResource ): \"\"\"OPTIMADE gateway A resource representing a dynamic collection of OPTIMADE databases. The gateway can be treated as any other OPTIMADE gateway, but the entries are an aggregate of multiple databases. The `id` of each aggregated resource will reflect the originating database. \"\"\" id : str = OptimadeField ( ... , description = \"\"\"An entry's ID as defined in section Definition of Terms. - **Type**: string. - **Requirements/Conventions**: - **Support**: MUST be supported by all implementations, MUST NOT be `null`. - **Query**: MUST be a queryable property with support for all mandatory filter features. - **Response**: REQUIRED in the response. - **Gateway-specific**: MUST NOT contain a forward slash (`/`). - **Examples**: - `\"db_1234567\"` - `\"cod_2000000\"` - `\"cod_2000000@1234567\"` - `\"nomad_L1234567890\"` - `\"42\"`\"\"\" , support = SupportLevel . MUST , queryable = SupportLevel . MUST , regex = r \"^[^/]*$\" , ) type : str = Field ( \"gateways\" , const = True , description = \"The name of the type of an entry.\" , regex = \"^gateways$\" , ) attributes : GatewayResourceAttributes","title":"GatewayResource"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResource.attributes","text":"","title":"attributes"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResource.id","text":"","title":"id"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResource.type","text":"","title":"type"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResourceAttributes","text":"Bases: EntryResourceAttributes Attributes for an OPTIMADE gateway Source code in optimade_gateway/models/gateways.py 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class GatewayResourceAttributes ( EntryResourceAttributes ): \"\"\"Attributes for an OPTIMADE gateway\"\"\" databases : List [ LinksResource ] = Field ( ... , description = \"List of databases (OPTIMADE 'links') to be queried in this gateway.\" , ) @validator ( \"databases\" , each_item = True ) def no_index_databases ( cls , value : LinksResource ) -> LinksResource : \"\"\"Ensure databases are not of type `\"root\"` or `\"providers\"` !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value . attributes . link_type in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for \" f \"gateway resources. Given database: { value } \" ) return value @validator ( \"databases\" ) def unique_base_urls ( cls , value : List [ LinksResource ]) -> List [ LinksResource ]: \"\"\"Remove extra entries with repeated base_urls\"\"\" db_base_urls = [ _ . attributes . base_url for _ in value ] unique_base_urls = set ( db_base_urls ) if len ( db_base_urls ) == len ( unique_base_urls ): return value repeated_base_urls = [ _ for _ in unique_base_urls if db_base_urls . count ( _ ) > 1 ] new_databases = [ _ for _ in value if _ . attributes . base_url not in repeated_base_urls ] for base_url in repeated_base_urls : new_databases . append ( [ _ for _ in value if _ . attributes . base_url == base_url ][ 0 ] ) warnings . warn ( \"Removed extra database entries for a gateway, because the base_url was \" \"repeated. The first found database entry was kept, while the others were \" f \"removed. Original number of databases: { len ( value ) } . New number of \" f \"databases: { len ( new_databases ) } Repeated base_urls (number of repeats): \" \" {} \" . format ( [ f \" { base_url } ( { db_base_urls . count ( base_url ) } )\" for base_url in repeated_base_urls ] ), OptimadeGatewayWarning , ) return new_databases","title":"GatewayResourceAttributes"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResourceAttributes.databases","text":"","title":"databases"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResourceAttributes.no_index_databases","text":"Ensure databases are not of type \"root\" or \"providers\" Note Both \"external\" and \"child\" can still represent index meta-dbs, but \"root\" and \"providers\" can not represent \"regular\" dbs. Source code in optimade_gateway/models/gateways.py 24 25 26 27 28 29 30 31 32 33 34 35 36 37 @validator ( \"databases\" , each_item = True ) def no_index_databases ( cls , value : LinksResource ) -> LinksResource : \"\"\"Ensure databases are not of type `\"root\"` or `\"providers\"` !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value . attributes . link_type in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for \" f \"gateway resources. Given database: { value } \" ) return value","title":"no_index_databases()"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResourceAttributes.unique_base_urls","text":"Remove extra entries with repeated base_urls Source code in optimade_gateway/models/gateways.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 @validator ( \"databases\" ) def unique_base_urls ( cls , value : List [ LinksResource ]) -> List [ LinksResource ]: \"\"\"Remove extra entries with repeated base_urls\"\"\" db_base_urls = [ _ . attributes . base_url for _ in value ] unique_base_urls = set ( db_base_urls ) if len ( db_base_urls ) == len ( unique_base_urls ): return value repeated_base_urls = [ _ for _ in unique_base_urls if db_base_urls . count ( _ ) > 1 ] new_databases = [ _ for _ in value if _ . attributes . base_url not in repeated_base_urls ] for base_url in repeated_base_urls : new_databases . append ( [ _ for _ in value if _ . attributes . base_url == base_url ][ 0 ] ) warnings . warn ( \"Removed extra database entries for a gateway, because the base_url was \" \"repeated. The first found database entry was kept, while the others were \" f \"removed. Original number of databases: { len ( value ) } . New number of \" f \"databases: { len ( new_databases ) } Repeated base_urls (number of repeats): \" \" {} \" . format ( [ f \" { base_url } ( { db_base_urls . count ( base_url ) } )\" for base_url in repeated_base_urls ] ), OptimadeGatewayWarning , ) return new_databases","title":"unique_base_urls()"},{"location":"api_reference/models/queries/","text":"queries \u00b6 Pydantic models/schemas for the Queries resource. QUERY_PARAMETERS = EntryListingQueryParams () module-attribute \u00b6 Entry listing URL query parameters from the optimade package ( EntryListingQueryParams ). EndpointEntryType \u00b6 Bases: Enum Entry endpoint resource types, mapping to their pydantic models from the optimade package. Source code in optimade_gateway/models/queries.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class EndpointEntryType ( Enum ): \"\"\"Entry endpoint resource types, mapping to their pydantic models from the `optimade` package.\"\"\" REFERENCES = \"references\" STRUCTURES = \"structures\" def get_resource_model ( self ) -> Union [ ReferenceResource , StructureResource ]: \"\"\"Get the matching pydantic model for a resource.\"\"\" return { \"references\" : ReferenceResource , \"structures\" : StructureResource , }[ self . value ] def get_response_model ( self , single : bool = False ) -> Union [ ReferenceResponseMany , ReferenceResponseOne , StructureResponseMany , StructureResponseOne , ]: \"\"\"Get the matching pydantic model for a successful response.\"\"\" if single : return { \"references\" : ReferenceResponseOne , \"structures\" : StructureResponseOne , }[ self . value ] return { \"references\" : ReferenceResponseMany , \"structures\" : StructureResponseMany , }[ self . value ] REFERENCES = 'references' class-attribute \u00b6 STRUCTURES = 'structures' class-attribute \u00b6 get_resource_model () \u00b6 Get the matching pydantic model for a resource. Source code in optimade_gateway/models/queries.py 42 43 44 45 46 47 def get_resource_model ( self ) -> Union [ ReferenceResource , StructureResource ]: \"\"\"Get the matching pydantic model for a resource.\"\"\" return { \"references\" : ReferenceResource , \"structures\" : StructureResource , }[ self . value ] get_response_model ( single = False ) \u00b6 Get the matching pydantic model for a successful response. Source code in optimade_gateway/models/queries.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def get_response_model ( self , single : bool = False ) -> Union [ ReferenceResponseMany , ReferenceResponseOne , StructureResponseMany , StructureResponseOne , ]: \"\"\"Get the matching pydantic model for a successful response.\"\"\" if single : return { \"references\" : ReferenceResponseOne , \"structures\" : StructureResponseOne , }[ self . value ] return { \"references\" : ReferenceResponseMany , \"structures\" : StructureResponseMany , }[ self . value ] EntryResource \u00b6 Bases: OptimadeEntryResource Entry Resource ensuring datetimes are not naive. Source code in optimade_gateway/models/queries.py 152 153 154 155 156 157 158 159 160 161 162 class EntryResource ( OptimadeEntryResource ): \"\"\"Entry Resource ensuring datetimes are not naive.\"\"\" @validator ( \"attributes\" ) def ensure_non_naive_datetime ( cls , value : EntryResourceAttributes ) -> EntryResourceAttributes : \"\"\"Set timezone to UTC if datetime is naive.\"\"\" if value . last_modified and value . last_modified . tzinfo is None : value . last_modified = value . last_modified . replace ( tzinfo = timezone . utc ) return value ensure_non_naive_datetime ( value ) \u00b6 Set timezone to UTC if datetime is naive. Source code in optimade_gateway/models/queries.py 155 156 157 158 159 160 161 162 @validator ( \"attributes\" ) def ensure_non_naive_datetime ( cls , value : EntryResourceAttributes ) -> EntryResourceAttributes : \"\"\"Set timezone to UTC if datetime is naive.\"\"\" if value . last_modified and value . last_modified . tzinfo is None : value . last_modified = value . last_modified . replace ( tzinfo = timezone . utc ) return value GatewayQueryResponse \u00b6 Bases: Response Response from a Gateway Query. Source code in optimade_gateway/models/queries.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 class GatewayQueryResponse ( Response ): \"\"\"Response from a Gateway Query.\"\"\" data : Dict [ str , Union [ List [ EntryResource ], List [ Dict [ str , Any ]]]] = StrictField ( ... , uniqueItems = True , description = \"Outputted Data.\" ) meta : ResponseMeta = StrictField ( ... , description = \"A meta object containing non-standard information.\" ) errors : Optional [ List [ OptimadeError ]] = StrictField ( [], description = ( \"A list of OPTIMADE-specific JSON API error objects, where the field detail \" \"MUST be present.\" ), uniqueItems = True , ) included : Optional [ Union [ List [ EntryResource ], List [ Dict [ str , Any ]]]] = Field ( None , uniqueItems = True ) @classmethod def _remove_pre_root_validators ( cls ): \"\"\"Remove `either_data_meta_or_errors_must_be_set` pre root_validator. This will always be available through `meta`, and more importantly, `errors` should be allowed to be present always for this special response. \"\"\" pre_root_validators = [] for validator_ in cls . __pre_root_validators__ : if not str ( validator_ ) . startswith ( \"<function Response.either_data_meta_or_errors_must_be_set\" ): pre_root_validators . append ( validator_ ) cls . __pre_root_validators__ = pre_root_validators def __init__ ( self , ** data : Any ) -> None : \"\"\"Remove root_validator `either_data_meta_or_errors_must_be_set`.\"\"\" self . _remove_pre_root_validators () super () . __init__ ( ** data ) data : Dict [ str , Union [ List [ EntryResource ], List [ Dict [ str , Any ]]]] = StrictField ( Ellipsis , uniqueItems = True , description = 'Outputted Data.' ) class-attribute \u00b6 errors : Optional [ List [ OptimadeError ]] = StrictField ([], description = 'A list of OPTIMADE-specific JSON API error objects, where the field detail MUST be present.' , uniqueItems = True ) class-attribute \u00b6 included : Optional [ Union [ List [ EntryResource ], List [ Dict [ str , Any ]]]] = Field ( None , uniqueItems = True ) class-attribute \u00b6 meta : ResponseMeta = StrictField ( Ellipsis , description = 'A meta object containing non-standard information.' ) class-attribute \u00b6 __init__ ( ** data ) \u00b6 Remove root_validator either_data_meta_or_errors_must_be_set . Source code in optimade_gateway/models/queries.py 200 201 202 203 def __init__ ( self , ** data : Any ) -> None : \"\"\"Remove root_validator `either_data_meta_or_errors_must_be_set`.\"\"\" self . _remove_pre_root_validators () super () . __init__ ( ** data ) OptimadeQueryParameters \u00b6 Bases: BaseModel Common OPTIMADE entry listing endpoint query parameters. Source code in optimade_gateway/models/queries.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class OptimadeQueryParameters ( BaseModel ): \"\"\"Common OPTIMADE entry listing endpoint query parameters.\"\"\" filter : Optional [ str ] = Field ( QUERY_PARAMETERS . filter . default , description = QUERY_PARAMETERS . filter . description , ) response_format : Optional [ str ] = Field ( QUERY_PARAMETERS . response_format . default , description = QUERY_PARAMETERS . response_format . description , ) email_address : Optional [ EmailStr ] = Field ( QUERY_PARAMETERS . email_address . default , description = QUERY_PARAMETERS . email_address . description , ) response_fields : Optional [ str ] = Field ( QUERY_PARAMETERS . response_fields . default , description = QUERY_PARAMETERS . response_fields . description , regex = QUERY_PARAMETERS . response_fields . regex , ) sort : Optional [ str ] = Field ( QUERY_PARAMETERS . sort . default , description = QUERY_PARAMETERS . sort . description , regex = QUERY_PARAMETERS . sort . regex , ) page_limit : Optional [ int ] = Field ( QUERY_PARAMETERS . page_limit . default , description = QUERY_PARAMETERS . page_limit . description , ge = QUERY_PARAMETERS . page_limit . ge , ) page_offset : Optional [ int ] = Field ( QUERY_PARAMETERS . page_offset . default , description = QUERY_PARAMETERS . page_offset . description , ge = QUERY_PARAMETERS . page_offset . ge , ) page_number : Optional [ int ] = Field ( QUERY_PARAMETERS . page_number . default , description = QUERY_PARAMETERS . page_number . description , ge = QUERY_PARAMETERS . page_number . ge , ) page_cursor : Optional [ int ] = Field ( QUERY_PARAMETERS . page_cursor . default , description = QUERY_PARAMETERS . page_cursor . description , ge = QUERY_PARAMETERS . page_cursor . ge , ) page_above : Optional [ int ] = Field ( QUERY_PARAMETERS . page_above . default , description = QUERY_PARAMETERS . page_above . description , ge = QUERY_PARAMETERS . page_above . ge , ) page_below : Optional [ int ] = Field ( QUERY_PARAMETERS . page_below . default , description = QUERY_PARAMETERS . page_below . description , ge = QUERY_PARAMETERS . page_below . ge , ) include : Optional [ str ] = Field ( QUERY_PARAMETERS . include . default , description = QUERY_PARAMETERS . include . description , ) email_address : Optional [ EmailStr ] = Field ( QUERY_PARAMETERS . email_address . default , description = QUERY_PARAMETERS . email_address . description ) class-attribute \u00b6 filter : Optional [ str ] = Field ( QUERY_PARAMETERS . filter . default , description = QUERY_PARAMETERS . filter . description ) class-attribute \u00b6 include : Optional [ str ] = Field ( QUERY_PARAMETERS . include . default , description = QUERY_PARAMETERS . include . description ) class-attribute \u00b6 page_above : Optional [ int ] = Field ( QUERY_PARAMETERS . page_above . default , description = QUERY_PARAMETERS . page_above . description , ge = QUERY_PARAMETERS . page_above . ge ) class-attribute \u00b6 page_below : Optional [ int ] = Field ( QUERY_PARAMETERS . page_below . default , description = QUERY_PARAMETERS . page_below . description , ge = QUERY_PARAMETERS . page_below . ge ) class-attribute \u00b6 page_cursor : Optional [ int ] = Field ( QUERY_PARAMETERS . page_cursor . default , description = QUERY_PARAMETERS . page_cursor . description , ge = QUERY_PARAMETERS . page_cursor . ge ) class-attribute \u00b6 page_limit : Optional [ int ] = Field ( QUERY_PARAMETERS . page_limit . default , description = QUERY_PARAMETERS . page_limit . description , ge = QUERY_PARAMETERS . page_limit . ge ) class-attribute \u00b6 page_number : Optional [ int ] = Field ( QUERY_PARAMETERS . page_number . default , description = QUERY_PARAMETERS . page_number . description , ge = QUERY_PARAMETERS . page_number . ge ) class-attribute \u00b6 page_offset : Optional [ int ] = Field ( QUERY_PARAMETERS . page_offset . default , description = QUERY_PARAMETERS . page_offset . description , ge = QUERY_PARAMETERS . page_offset . ge ) class-attribute \u00b6 response_fields : Optional [ str ] = Field ( QUERY_PARAMETERS . response_fields . default , description = QUERY_PARAMETERS . response_fields . description , regex = QUERY_PARAMETERS . response_fields . regex ) class-attribute \u00b6 response_format : Optional [ str ] = Field ( QUERY_PARAMETERS . response_format . default , description = QUERY_PARAMETERS . response_format . description ) class-attribute \u00b6 sort : Optional [ str ] = Field ( QUERY_PARAMETERS . sort . default , description = QUERY_PARAMETERS . sort . description , regex = QUERY_PARAMETERS . sort . regex ) class-attribute \u00b6 QueryCreate \u00b6 Bases: EntryResourceCreate , QueryResourceAttributes Model for creating new Query resources in the MongoDB Source code in optimade_gateway/models/queries.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 class QueryCreate ( EntryResourceCreate , QueryResourceAttributes ): \"\"\"Model for creating new Query resources in the MongoDB\"\"\" state : Optional [ QueryState ] # type: ignore[assignment] endpoint : Optional [ EndpointEntryType ] # type: ignore[assignment] @validator ( \"query_parameters\" ) def sort_not_supported ( cls , value : OptimadeQueryParameters ) -> OptimadeQueryParameters : \"\"\"Warn and reset value if `sort` is supplied.\"\"\" if value . sort : warnings . warn ( SortNotSupported ()) value . sort = None return value endpoint : Optional [ EndpointEntryType ] class-attribute \u00b6 state : Optional [ QueryState ] class-attribute \u00b6 sort_not_supported ( value ) \u00b6 Warn and reset value if sort is supplied. Source code in optimade_gateway/models/queries.py 367 368 369 370 371 372 373 374 375 @validator ( \"query_parameters\" ) def sort_not_supported ( cls , value : OptimadeQueryParameters ) -> OptimadeQueryParameters : \"\"\"Warn and reset value if `sort` is supplied.\"\"\" if value . sort : warnings . warn ( SortNotSupported ()) value . sort = None return value QueryResource \u00b6 Bases: EntryResource OPTIMADE query resource for a gateway Source code in optimade_gateway/models/queries.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 class QueryResource ( EntryResource ): \"\"\"OPTIMADE query resource for a gateway\"\"\" type : str = Field ( \"queries\" , const = True , description = \"The name of the type of an entry.\" , regex = \"^queries$\" , ) attributes : QueryResourceAttributes async def response_as_optimade ( self , url : Optional [ Union [ urllib . parse . ParseResult , urllib . parse . SplitResult , StarletteURL , str ] ] = None , ) -> Union [ EntryResponseMany , ErrorResponse ]: \"\"\"Return `attributes.response` as a valid OPTIMADE entry listing response. Note, this method disregards the state of the query and will simply return the query results as they currently are (if there are any at all). Parameters: url: Optionally, update the `meta.query.representation` value with this. Returns: A valid OPTIMADE entry-listing response according to the [OPTIMADE specification](https://github.com/Materials-Consortia/OPTIMADE/blob/master/optimade.rst#entry-listing-endpoints) or an error response, if errors were returned or occurred during the query. \"\"\" from optimade.server.routers.utils import ( # pylint: disable=import-outside-toplevel meta_values , ) async def _update_id ( entry_ : Union [ EntryResource , Dict [ str , Any ]], database_provider_ : str ) -> Union [ EntryResource , Dict [ str , Any ]]: \"\"\"Internal utility function to prepend the entries' `id` with `provider/database/`. Parameters: entry_: The entry as a model or a dictionary. database_provider_: `provider/database` string. Returns: The entry with an updated `id` value. \"\"\" if isinstance ( entry_ , dict ): _entry = deepcopy ( entry_ ) _entry [ \"id\" ] = f \" { database_provider_ } / { entry_ [ 'id' ] } \" else : _entry = entry_ . copy ( deep = True ) _entry . id = f \" { database_provider_ } / { entry_ . id } \" # type: ignore[union-attr] return _entry if not self . attributes . response : # The query has not yet been initiated return ErrorResponse ( errors = [ { \"detail\" : ( \"Can not return as a valid OPTIMADE response as the query has\" \" not yet been initialized.\" ), \"id\" : \"OPTIMADE_GATEWAY_QUERY_NOT_INITIALIZED\" , } ], meta = meta_values ( url = url or f \"/queries/ { self . id } ?\" , data_returned = 0 , data_available = 0 , more_data_available = False , schema = CONFIG . schema_url , ), ) meta_ = self . attributes . response . meta if url : meta_ = meta_ . dict ( exclude_unset = True ) for repeated_key in ( \"query\" , \"api_version\" , \"time_stamp\" , \"provider\" , \"implementation\" , ): meta_ . pop ( repeated_key , None ) meta_ = meta_values ( url = url , ** meta_ ) # Error response if self . attributes . response . errors : return ErrorResponse ( errors = self . attributes . response . errors , meta = meta_ , ) # Data response results = [] for database_provider , entries in self . attributes . response . data . items (): results . extend ( [ await _update_id ( entry , database_provider ) for entry in entries ] ) return self . attributes . endpoint . get_response_model ()( data = results , meta = meta_ , links = self . attributes . response . links , ) attributes : QueryResourceAttributes class-attribute \u00b6 type : str = Field ( 'queries' , const = True , description = 'The name of the type of an entry.' , regex = '^queries$' ) class-attribute \u00b6 response_as_optimade ( url = None ) async \u00b6 Return attributes.response as a valid OPTIMADE entry listing response. Note, this method disregards the state of the query and will simply return the query results as they currently are (if there are any at all). Parameters: Name Type Description Default url Optional [ Union [ urllib . parse . ParseResult , urllib . parse . SplitResult , StarletteURL , str ]] Optionally, update the meta.query.representation value with this. None Returns: Type Description Union [ EntryResponseMany , ErrorResponse ] A valid OPTIMADE entry-listing response according to the Union [ EntryResponseMany , ErrorResponse ] OPTIMADE specification Union [ EntryResponseMany , ErrorResponse ] or an error response, if errors were returned or occurred during the query. Source code in optimade_gateway/models/queries.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 async def response_as_optimade ( self , url : Optional [ Union [ urllib . parse . ParseResult , urllib . parse . SplitResult , StarletteURL , str ] ] = None , ) -> Union [ EntryResponseMany , ErrorResponse ]: \"\"\"Return `attributes.response` as a valid OPTIMADE entry listing response. Note, this method disregards the state of the query and will simply return the query results as they currently are (if there are any at all). Parameters: url: Optionally, update the `meta.query.representation` value with this. Returns: A valid OPTIMADE entry-listing response according to the [OPTIMADE specification](https://github.com/Materials-Consortia/OPTIMADE/blob/master/optimade.rst#entry-listing-endpoints) or an error response, if errors were returned or occurred during the query. \"\"\" from optimade.server.routers.utils import ( # pylint: disable=import-outside-toplevel meta_values , ) async def _update_id ( entry_ : Union [ EntryResource , Dict [ str , Any ]], database_provider_ : str ) -> Union [ EntryResource , Dict [ str , Any ]]: \"\"\"Internal utility function to prepend the entries' `id` with `provider/database/`. Parameters: entry_: The entry as a model or a dictionary. database_provider_: `provider/database` string. Returns: The entry with an updated `id` value. \"\"\" if isinstance ( entry_ , dict ): _entry = deepcopy ( entry_ ) _entry [ \"id\" ] = f \" { database_provider_ } / { entry_ [ 'id' ] } \" else : _entry = entry_ . copy ( deep = True ) _entry . id = f \" { database_provider_ } / { entry_ . id } \" # type: ignore[union-attr] return _entry if not self . attributes . response : # The query has not yet been initiated return ErrorResponse ( errors = [ { \"detail\" : ( \"Can not return as a valid OPTIMADE response as the query has\" \" not yet been initialized.\" ), \"id\" : \"OPTIMADE_GATEWAY_QUERY_NOT_INITIALIZED\" , } ], meta = meta_values ( url = url or f \"/queries/ { self . id } ?\" , data_returned = 0 , data_available = 0 , more_data_available = False , schema = CONFIG . schema_url , ), ) meta_ = self . attributes . response . meta if url : meta_ = meta_ . dict ( exclude_unset = True ) for repeated_key in ( \"query\" , \"api_version\" , \"time_stamp\" , \"provider\" , \"implementation\" , ): meta_ . pop ( repeated_key , None ) meta_ = meta_values ( url = url , ** meta_ ) # Error response if self . attributes . response . errors : return ErrorResponse ( errors = self . attributes . response . errors , meta = meta_ , ) # Data response results = [] for database_provider , entries in self . attributes . response . data . items (): results . extend ( [ await _update_id ( entry , database_provider ) for entry in entries ] ) return self . attributes . endpoint . get_response_model ()( data = results , meta = meta_ , links = self . attributes . response . links , ) QueryResourceAttributes \u00b6 Bases: EntryResourceAttributes Attributes for an OPTIMADE gateway query. Source code in optimade_gateway/models/queries.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class QueryResourceAttributes ( EntryResourceAttributes ): \"\"\"Attributes for an OPTIMADE gateway query.\"\"\" gateway_id : str = Field ( ... , description = \"The OPTIMADE gateway ID for this query.\" , ) query_parameters : OptimadeQueryParameters = Field ( ... , description = ( \"OPTIMADE query parameters for entry listing endpoints used for this query.\" ), type = \"object\" , ) state : QueryState = Field ( QueryState . CREATED , description = \"Current state of Gateway Query.\" , title = \"State\" , type = \"enum\" , ) response : Optional [ GatewayQueryResponse ] = Field ( None , description = \"Response from gateway query.\" , ) endpoint : EndpointEntryType = Field ( EndpointEntryType . STRUCTURES , description = \"The entry endpoint queried, e.g., 'structures'.\" , title = \"Endpoint\" , type = \"enum\" , ) @validator ( \"endpoint\" ) def only_allow_structures ( cls , value : EndpointEntryType ) -> EndpointEntryType : \"\"\"Temporarily only allow queries to \"structures\" endpoints.\"\"\" if value != EndpointEntryType . STRUCTURES : raise NotImplementedError ( 'OPTIMADE Gateway temporarily only supports queries to \"structures\" ' 'endpoints, i.e.: endpoint=\"structures\"' ) return value endpoint : EndpointEntryType = Field ( EndpointEntryType . STRUCTURES , description = \"The entry endpoint queried, e.g., 'structures'.\" , title = 'Endpoint' , type = 'enum' ) class-attribute \u00b6 gateway_id : str = Field ( Ellipsis , description = 'The OPTIMADE gateway ID for this query.' ) class-attribute \u00b6 query_parameters : OptimadeQueryParameters = Field ( Ellipsis , description = 'OPTIMADE query parameters for entry listing endpoints used for this query.' , type = 'object' ) class-attribute \u00b6 response : Optional [ GatewayQueryResponse ] = Field ( None , description = 'Response from gateway query.' ) class-attribute \u00b6 state : QueryState = Field ( QueryState . CREATED , description = 'Current state of Gateway Query.' , title = 'State' , type = 'enum' ) class-attribute \u00b6 only_allow_structures ( value ) \u00b6 Temporarily only allow queries to \"structures\" endpoints. Source code in optimade_gateway/models/queries.py 237 238 239 240 241 242 243 244 245 @validator ( \"endpoint\" ) def only_allow_structures ( cls , value : EndpointEntryType ) -> EndpointEntryType : \"\"\"Temporarily only allow queries to \"structures\" endpoints.\"\"\" if value != EndpointEntryType . STRUCTURES : raise NotImplementedError ( 'OPTIMADE Gateway temporarily only supports queries to \"structures\" ' 'endpoints, i.e.: endpoint=\"structures\"' ) return value QueryState \u00b6 Bases: Enum Enumeration of possible states for a Gateway Query. The states are enumerated here in the expected evolvement. Source code in optimade_gateway/models/queries.py 140 141 142 143 144 145 146 147 148 149 class QueryState ( Enum ): \"\"\"Enumeration of possible states for a Gateway Query. The states are enumerated here in the expected evolvement. \"\"\" CREATED = \"created\" STARTED = \"started\" IN_PROGRESS = \"in progress\" FINISHED = \"finished\" CREATED = 'created' class-attribute \u00b6 FINISHED = 'finished' class-attribute \u00b6 IN_PROGRESS = 'in progress' class-attribute \u00b6 STARTED = 'started' class-attribute \u00b6","title":"queries"},{"location":"api_reference/models/queries/#queries","text":"Pydantic models/schemas for the Queries resource.","title":"queries"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QUERY_PARAMETERS","text":"Entry listing URL query parameters from the optimade package ( EntryListingQueryParams ).","title":"QUERY_PARAMETERS"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.EndpointEntryType","text":"Bases: Enum Entry endpoint resource types, mapping to their pydantic models from the optimade package. Source code in optimade_gateway/models/queries.py 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 class EndpointEntryType ( Enum ): \"\"\"Entry endpoint resource types, mapping to their pydantic models from the `optimade` package.\"\"\" REFERENCES = \"references\" STRUCTURES = \"structures\" def get_resource_model ( self ) -> Union [ ReferenceResource , StructureResource ]: \"\"\"Get the matching pydantic model for a resource.\"\"\" return { \"references\" : ReferenceResource , \"structures\" : StructureResource , }[ self . value ] def get_response_model ( self , single : bool = False ) -> Union [ ReferenceResponseMany , ReferenceResponseOne , StructureResponseMany , StructureResponseOne , ]: \"\"\"Get the matching pydantic model for a successful response.\"\"\" if single : return { \"references\" : ReferenceResponseOne , \"structures\" : StructureResponseOne , }[ self . value ] return { \"references\" : ReferenceResponseMany , \"structures\" : StructureResponseMany , }[ self . value ]","title":"EndpointEntryType"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.EndpointEntryType.REFERENCES","text":"","title":"REFERENCES"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.EndpointEntryType.STRUCTURES","text":"","title":"STRUCTURES"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.EndpointEntryType.get_resource_model","text":"Get the matching pydantic model for a resource. Source code in optimade_gateway/models/queries.py 42 43 44 45 46 47 def get_resource_model ( self ) -> Union [ ReferenceResource , StructureResource ]: \"\"\"Get the matching pydantic model for a resource.\"\"\" return { \"references\" : ReferenceResource , \"structures\" : StructureResource , }[ self . value ]","title":"get_resource_model()"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.EndpointEntryType.get_response_model","text":"Get the matching pydantic model for a successful response. Source code in optimade_gateway/models/queries.py 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def get_response_model ( self , single : bool = False ) -> Union [ ReferenceResponseMany , ReferenceResponseOne , StructureResponseMany , StructureResponseOne , ]: \"\"\"Get the matching pydantic model for a successful response.\"\"\" if single : return { \"references\" : ReferenceResponseOne , \"structures\" : StructureResponseOne , }[ self . value ] return { \"references\" : ReferenceResponseMany , \"structures\" : StructureResponseMany , }[ self . value ]","title":"get_response_model()"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.EntryResource","text":"Bases: OptimadeEntryResource Entry Resource ensuring datetimes are not naive. Source code in optimade_gateway/models/queries.py 152 153 154 155 156 157 158 159 160 161 162 class EntryResource ( OptimadeEntryResource ): \"\"\"Entry Resource ensuring datetimes are not naive.\"\"\" @validator ( \"attributes\" ) def ensure_non_naive_datetime ( cls , value : EntryResourceAttributes ) -> EntryResourceAttributes : \"\"\"Set timezone to UTC if datetime is naive.\"\"\" if value . last_modified and value . last_modified . tzinfo is None : value . last_modified = value . last_modified . replace ( tzinfo = timezone . utc ) return value","title":"EntryResource"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.EntryResource.ensure_non_naive_datetime","text":"Set timezone to UTC if datetime is naive. Source code in optimade_gateway/models/queries.py 155 156 157 158 159 160 161 162 @validator ( \"attributes\" ) def ensure_non_naive_datetime ( cls , value : EntryResourceAttributes ) -> EntryResourceAttributes : \"\"\"Set timezone to UTC if datetime is naive.\"\"\" if value . last_modified and value . last_modified . tzinfo is None : value . last_modified = value . last_modified . replace ( tzinfo = timezone . utc ) return value","title":"ensure_non_naive_datetime()"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.GatewayQueryResponse","text":"Bases: Response Response from a Gateway Query. Source code in optimade_gateway/models/queries.py 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 class GatewayQueryResponse ( Response ): \"\"\"Response from a Gateway Query.\"\"\" data : Dict [ str , Union [ List [ EntryResource ], List [ Dict [ str , Any ]]]] = StrictField ( ... , uniqueItems = True , description = \"Outputted Data.\" ) meta : ResponseMeta = StrictField ( ... , description = \"A meta object containing non-standard information.\" ) errors : Optional [ List [ OptimadeError ]] = StrictField ( [], description = ( \"A list of OPTIMADE-specific JSON API error objects, where the field detail \" \"MUST be present.\" ), uniqueItems = True , ) included : Optional [ Union [ List [ EntryResource ], List [ Dict [ str , Any ]]]] = Field ( None , uniqueItems = True ) @classmethod def _remove_pre_root_validators ( cls ): \"\"\"Remove `either_data_meta_or_errors_must_be_set` pre root_validator. This will always be available through `meta`, and more importantly, `errors` should be allowed to be present always for this special response. \"\"\" pre_root_validators = [] for validator_ in cls . __pre_root_validators__ : if not str ( validator_ ) . startswith ( \"<function Response.either_data_meta_or_errors_must_be_set\" ): pre_root_validators . append ( validator_ ) cls . __pre_root_validators__ = pre_root_validators def __init__ ( self , ** data : Any ) -> None : \"\"\"Remove root_validator `either_data_meta_or_errors_must_be_set`.\"\"\" self . _remove_pre_root_validators () super () . __init__ ( ** data )","title":"GatewayQueryResponse"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.GatewayQueryResponse.data","text":"","title":"data"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.GatewayQueryResponse.errors","text":"","title":"errors"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.GatewayQueryResponse.included","text":"","title":"included"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.GatewayQueryResponse.meta","text":"","title":"meta"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.GatewayQueryResponse.__init__","text":"Remove root_validator either_data_meta_or_errors_must_be_set . Source code in optimade_gateway/models/queries.py 200 201 202 203 def __init__ ( self , ** data : Any ) -> None : \"\"\"Remove root_validator `either_data_meta_or_errors_must_be_set`.\"\"\" self . _remove_pre_root_validators () super () . __init__ ( ** data )","title":"__init__()"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters","text":"Bases: BaseModel Common OPTIMADE entry listing endpoint query parameters. Source code in optimade_gateway/models/queries.py 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 class OptimadeQueryParameters ( BaseModel ): \"\"\"Common OPTIMADE entry listing endpoint query parameters.\"\"\" filter : Optional [ str ] = Field ( QUERY_PARAMETERS . filter . default , description = QUERY_PARAMETERS . filter . description , ) response_format : Optional [ str ] = Field ( QUERY_PARAMETERS . response_format . default , description = QUERY_PARAMETERS . response_format . description , ) email_address : Optional [ EmailStr ] = Field ( QUERY_PARAMETERS . email_address . default , description = QUERY_PARAMETERS . email_address . description , ) response_fields : Optional [ str ] = Field ( QUERY_PARAMETERS . response_fields . default , description = QUERY_PARAMETERS . response_fields . description , regex = QUERY_PARAMETERS . response_fields . regex , ) sort : Optional [ str ] = Field ( QUERY_PARAMETERS . sort . default , description = QUERY_PARAMETERS . sort . description , regex = QUERY_PARAMETERS . sort . regex , ) page_limit : Optional [ int ] = Field ( QUERY_PARAMETERS . page_limit . default , description = QUERY_PARAMETERS . page_limit . description , ge = QUERY_PARAMETERS . page_limit . ge , ) page_offset : Optional [ int ] = Field ( QUERY_PARAMETERS . page_offset . default , description = QUERY_PARAMETERS . page_offset . description , ge = QUERY_PARAMETERS . page_offset . ge , ) page_number : Optional [ int ] = Field ( QUERY_PARAMETERS . page_number . default , description = QUERY_PARAMETERS . page_number . description , ge = QUERY_PARAMETERS . page_number . ge , ) page_cursor : Optional [ int ] = Field ( QUERY_PARAMETERS . page_cursor . default , description = QUERY_PARAMETERS . page_cursor . description , ge = QUERY_PARAMETERS . page_cursor . ge , ) page_above : Optional [ int ] = Field ( QUERY_PARAMETERS . page_above . default , description = QUERY_PARAMETERS . page_above . description , ge = QUERY_PARAMETERS . page_above . ge , ) page_below : Optional [ int ] = Field ( QUERY_PARAMETERS . page_below . default , description = QUERY_PARAMETERS . page_below . description , ge = QUERY_PARAMETERS . page_below . ge , ) include : Optional [ str ] = Field ( QUERY_PARAMETERS . include . default , description = QUERY_PARAMETERS . include . description , )","title":"OptimadeQueryParameters"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.email_address","text":"","title":"email_address"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.filter","text":"","title":"filter"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.include","text":"","title":"include"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_above","text":"","title":"page_above"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_below","text":"","title":"page_below"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_cursor","text":"","title":"page_cursor"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_limit","text":"","title":"page_limit"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_number","text":"","title":"page_number"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_offset","text":"","title":"page_offset"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.response_fields","text":"","title":"response_fields"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.response_format","text":"","title":"response_format"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.sort","text":"","title":"sort"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryCreate","text":"Bases: EntryResourceCreate , QueryResourceAttributes Model for creating new Query resources in the MongoDB Source code in optimade_gateway/models/queries.py 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 class QueryCreate ( EntryResourceCreate , QueryResourceAttributes ): \"\"\"Model for creating new Query resources in the MongoDB\"\"\" state : Optional [ QueryState ] # type: ignore[assignment] endpoint : Optional [ EndpointEntryType ] # type: ignore[assignment] @validator ( \"query_parameters\" ) def sort_not_supported ( cls , value : OptimadeQueryParameters ) -> OptimadeQueryParameters : \"\"\"Warn and reset value if `sort` is supplied.\"\"\" if value . sort : warnings . warn ( SortNotSupported ()) value . sort = None return value","title":"QueryCreate"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryCreate.endpoint","text":"","title":"endpoint"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryCreate.state","text":"","title":"state"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryCreate.sort_not_supported","text":"Warn and reset value if sort is supplied. Source code in optimade_gateway/models/queries.py 367 368 369 370 371 372 373 374 375 @validator ( \"query_parameters\" ) def sort_not_supported ( cls , value : OptimadeQueryParameters ) -> OptimadeQueryParameters : \"\"\"Warn and reset value if `sort` is supplied.\"\"\" if value . sort : warnings . warn ( SortNotSupported ()) value . sort = None return value","title":"sort_not_supported()"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResource","text":"Bases: EntryResource OPTIMADE query resource for a gateway Source code in optimade_gateway/models/queries.py 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 class QueryResource ( EntryResource ): \"\"\"OPTIMADE query resource for a gateway\"\"\" type : str = Field ( \"queries\" , const = True , description = \"The name of the type of an entry.\" , regex = \"^queries$\" , ) attributes : QueryResourceAttributes async def response_as_optimade ( self , url : Optional [ Union [ urllib . parse . ParseResult , urllib . parse . SplitResult , StarletteURL , str ] ] = None , ) -> Union [ EntryResponseMany , ErrorResponse ]: \"\"\"Return `attributes.response` as a valid OPTIMADE entry listing response. Note, this method disregards the state of the query and will simply return the query results as they currently are (if there are any at all). Parameters: url: Optionally, update the `meta.query.representation` value with this. Returns: A valid OPTIMADE entry-listing response according to the [OPTIMADE specification](https://github.com/Materials-Consortia/OPTIMADE/blob/master/optimade.rst#entry-listing-endpoints) or an error response, if errors were returned or occurred during the query. \"\"\" from optimade.server.routers.utils import ( # pylint: disable=import-outside-toplevel meta_values , ) async def _update_id ( entry_ : Union [ EntryResource , Dict [ str , Any ]], database_provider_ : str ) -> Union [ EntryResource , Dict [ str , Any ]]: \"\"\"Internal utility function to prepend the entries' `id` with `provider/database/`. Parameters: entry_: The entry as a model or a dictionary. database_provider_: `provider/database` string. Returns: The entry with an updated `id` value. \"\"\" if isinstance ( entry_ , dict ): _entry = deepcopy ( entry_ ) _entry [ \"id\" ] = f \" { database_provider_ } / { entry_ [ 'id' ] } \" else : _entry = entry_ . copy ( deep = True ) _entry . id = f \" { database_provider_ } / { entry_ . id } \" # type: ignore[union-attr] return _entry if not self . attributes . response : # The query has not yet been initiated return ErrorResponse ( errors = [ { \"detail\" : ( \"Can not return as a valid OPTIMADE response as the query has\" \" not yet been initialized.\" ), \"id\" : \"OPTIMADE_GATEWAY_QUERY_NOT_INITIALIZED\" , } ], meta = meta_values ( url = url or f \"/queries/ { self . id } ?\" , data_returned = 0 , data_available = 0 , more_data_available = False , schema = CONFIG . schema_url , ), ) meta_ = self . attributes . response . meta if url : meta_ = meta_ . dict ( exclude_unset = True ) for repeated_key in ( \"query\" , \"api_version\" , \"time_stamp\" , \"provider\" , \"implementation\" , ): meta_ . pop ( repeated_key , None ) meta_ = meta_values ( url = url , ** meta_ ) # Error response if self . attributes . response . errors : return ErrorResponse ( errors = self . attributes . response . errors , meta = meta_ , ) # Data response results = [] for database_provider , entries in self . attributes . response . data . items (): results . extend ( [ await _update_id ( entry , database_provider ) for entry in entries ] ) return self . attributes . endpoint . get_response_model ()( data = results , meta = meta_ , links = self . attributes . response . links , )","title":"QueryResource"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResource.attributes","text":"","title":"attributes"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResource.type","text":"","title":"type"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResource.response_as_optimade","text":"Return attributes.response as a valid OPTIMADE entry listing response. Note, this method disregards the state of the query and will simply return the query results as they currently are (if there are any at all). Parameters: Name Type Description Default url Optional [ Union [ urllib . parse . ParseResult , urllib . parse . SplitResult , StarletteURL , str ]] Optionally, update the meta.query.representation value with this. None Returns: Type Description Union [ EntryResponseMany , ErrorResponse ] A valid OPTIMADE entry-listing response according to the Union [ EntryResponseMany , ErrorResponse ] OPTIMADE specification Union [ EntryResponseMany , ErrorResponse ] or an error response, if errors were returned or occurred during the query. Source code in optimade_gateway/models/queries.py 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 async def response_as_optimade ( self , url : Optional [ Union [ urllib . parse . ParseResult , urllib . parse . SplitResult , StarletteURL , str ] ] = None , ) -> Union [ EntryResponseMany , ErrorResponse ]: \"\"\"Return `attributes.response` as a valid OPTIMADE entry listing response. Note, this method disregards the state of the query and will simply return the query results as they currently are (if there are any at all). Parameters: url: Optionally, update the `meta.query.representation` value with this. Returns: A valid OPTIMADE entry-listing response according to the [OPTIMADE specification](https://github.com/Materials-Consortia/OPTIMADE/blob/master/optimade.rst#entry-listing-endpoints) or an error response, if errors were returned or occurred during the query. \"\"\" from optimade.server.routers.utils import ( # pylint: disable=import-outside-toplevel meta_values , ) async def _update_id ( entry_ : Union [ EntryResource , Dict [ str , Any ]], database_provider_ : str ) -> Union [ EntryResource , Dict [ str , Any ]]: \"\"\"Internal utility function to prepend the entries' `id` with `provider/database/`. Parameters: entry_: The entry as a model or a dictionary. database_provider_: `provider/database` string. Returns: The entry with an updated `id` value. \"\"\" if isinstance ( entry_ , dict ): _entry = deepcopy ( entry_ ) _entry [ \"id\" ] = f \" { database_provider_ } / { entry_ [ 'id' ] } \" else : _entry = entry_ . copy ( deep = True ) _entry . id = f \" { database_provider_ } / { entry_ . id } \" # type: ignore[union-attr] return _entry if not self . attributes . response : # The query has not yet been initiated return ErrorResponse ( errors = [ { \"detail\" : ( \"Can not return as a valid OPTIMADE response as the query has\" \" not yet been initialized.\" ), \"id\" : \"OPTIMADE_GATEWAY_QUERY_NOT_INITIALIZED\" , } ], meta = meta_values ( url = url or f \"/queries/ { self . id } ?\" , data_returned = 0 , data_available = 0 , more_data_available = False , schema = CONFIG . schema_url , ), ) meta_ = self . attributes . response . meta if url : meta_ = meta_ . dict ( exclude_unset = True ) for repeated_key in ( \"query\" , \"api_version\" , \"time_stamp\" , \"provider\" , \"implementation\" , ): meta_ . pop ( repeated_key , None ) meta_ = meta_values ( url = url , ** meta_ ) # Error response if self . attributes . response . errors : return ErrorResponse ( errors = self . attributes . response . errors , meta = meta_ , ) # Data response results = [] for database_provider , entries in self . attributes . response . data . items (): results . extend ( [ await _update_id ( entry , database_provider ) for entry in entries ] ) return self . attributes . endpoint . get_response_model ()( data = results , meta = meta_ , links = self . attributes . response . links , )","title":"response_as_optimade()"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes","text":"Bases: EntryResourceAttributes Attributes for an OPTIMADE gateway query. Source code in optimade_gateway/models/queries.py 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 class QueryResourceAttributes ( EntryResourceAttributes ): \"\"\"Attributes for an OPTIMADE gateway query.\"\"\" gateway_id : str = Field ( ... , description = \"The OPTIMADE gateway ID for this query.\" , ) query_parameters : OptimadeQueryParameters = Field ( ... , description = ( \"OPTIMADE query parameters for entry listing endpoints used for this query.\" ), type = \"object\" , ) state : QueryState = Field ( QueryState . CREATED , description = \"Current state of Gateway Query.\" , title = \"State\" , type = \"enum\" , ) response : Optional [ GatewayQueryResponse ] = Field ( None , description = \"Response from gateway query.\" , ) endpoint : EndpointEntryType = Field ( EndpointEntryType . STRUCTURES , description = \"The entry endpoint queried, e.g., 'structures'.\" , title = \"Endpoint\" , type = \"enum\" , ) @validator ( \"endpoint\" ) def only_allow_structures ( cls , value : EndpointEntryType ) -> EndpointEntryType : \"\"\"Temporarily only allow queries to \"structures\" endpoints.\"\"\" if value != EndpointEntryType . STRUCTURES : raise NotImplementedError ( 'OPTIMADE Gateway temporarily only supports queries to \"structures\" ' 'endpoints, i.e.: endpoint=\"structures\"' ) return value","title":"QueryResourceAttributes"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.endpoint","text":"","title":"endpoint"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.gateway_id","text":"","title":"gateway_id"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.query_parameters","text":"","title":"query_parameters"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.response","text":"","title":"response"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.state","text":"","title":"state"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.only_allow_structures","text":"Temporarily only allow queries to \"structures\" endpoints. Source code in optimade_gateway/models/queries.py 237 238 239 240 241 242 243 244 245 @validator ( \"endpoint\" ) def only_allow_structures ( cls , value : EndpointEntryType ) -> EndpointEntryType : \"\"\"Temporarily only allow queries to \"structures\" endpoints.\"\"\" if value != EndpointEntryType . STRUCTURES : raise NotImplementedError ( 'OPTIMADE Gateway temporarily only supports queries to \"structures\" ' 'endpoints, i.e.: endpoint=\"structures\"' ) return value","title":"only_allow_structures()"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryState","text":"Bases: Enum Enumeration of possible states for a Gateway Query. The states are enumerated here in the expected evolvement. Source code in optimade_gateway/models/queries.py 140 141 142 143 144 145 146 147 148 149 class QueryState ( Enum ): \"\"\"Enumeration of possible states for a Gateway Query. The states are enumerated here in the expected evolvement. \"\"\" CREATED = \"created\" STARTED = \"started\" IN_PROGRESS = \"in progress\" FINISHED = \"finished\"","title":"QueryState"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryState.CREATED","text":"","title":"CREATED"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryState.FINISHED","text":"","title":"FINISHED"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryState.IN_PROGRESS","text":"","title":"IN_PROGRESS"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryState.STARTED","text":"","title":"STARTED"},{"location":"api_reference/models/resources/","text":"resources \u00b6 Pydantic models/schemas for entry-endpoint resources. This module is mainly used for a special pydantic base model, which can be used as a mix-in class when creating entry-endpoint resources. EntryResourceCreate \u00b6 Bases: EntryResourceAttributes Generic model for creating new entry resources in the MongoDB Source code in optimade_gateway/models/resources.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class EntryResourceCreate ( EntryResourceAttributes ): \"\"\"Generic model for creating new entry resources in the MongoDB\"\"\" last_modified : Optional [ datetime ] id : Optional [ str ] class Config : \"\"\"Silently discard extra initiation keys.\"\"\" extra = \"ignore\" @classmethod def _remove_pre_root_validators ( cls ): \"\"\"Remove `check_illegal_attributes_fields` pre root_validators.\"\"\" pre_root_validators = [] for validator in cls . __pre_root_validators__ : if not str ( validator ) . startswith ( \"<function Attributes.check_illegal_attributes_fields\" ): pre_root_validators . append ( validator ) cls . __pre_root_validators__ = pre_root_validators def __init__ ( self , ** data : Any ) -> None : \"\"\"Remove root_validator `check_illegal_attributes_fields`.\"\"\" self . _remove_pre_root_validators () super () . __init__ ( ** data ) id : Optional [ str ] class-attribute \u00b6 last_modified : Optional [ datetime ] class-attribute \u00b6 Config \u00b6 Silently discard extra initiation keys. Source code in optimade_gateway/models/resources.py 20 21 22 23 class Config : \"\"\"Silently discard extra initiation keys.\"\"\" extra = \"ignore\" extra = 'ignore' class-attribute \u00b6 __init__ ( ** data ) \u00b6 Remove root_validator check_illegal_attributes_fields . Source code in optimade_gateway/models/resources.py 36 37 38 39 def __init__ ( self , ** data : Any ) -> None : \"\"\"Remove root_validator `check_illegal_attributes_fields`.\"\"\" self . _remove_pre_root_validators () super () . __init__ ( ** data )","title":"resources"},{"location":"api_reference/models/resources/#resources","text":"Pydantic models/schemas for entry-endpoint resources. This module is mainly used for a special pydantic base model, which can be used as a mix-in class when creating entry-endpoint resources.","title":"resources"},{"location":"api_reference/models/resources/#optimade_gateway.models.resources.EntryResourceCreate","text":"Bases: EntryResourceAttributes Generic model for creating new entry resources in the MongoDB Source code in optimade_gateway/models/resources.py 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 class EntryResourceCreate ( EntryResourceAttributes ): \"\"\"Generic model for creating new entry resources in the MongoDB\"\"\" last_modified : Optional [ datetime ] id : Optional [ str ] class Config : \"\"\"Silently discard extra initiation keys.\"\"\" extra = \"ignore\" @classmethod def _remove_pre_root_validators ( cls ): \"\"\"Remove `check_illegal_attributes_fields` pre root_validators.\"\"\" pre_root_validators = [] for validator in cls . __pre_root_validators__ : if not str ( validator ) . startswith ( \"<function Attributes.check_illegal_attributes_fields\" ): pre_root_validators . append ( validator ) cls . __pre_root_validators__ = pre_root_validators def __init__ ( self , ** data : Any ) -> None : \"\"\"Remove root_validator `check_illegal_attributes_fields`.\"\"\" self . _remove_pre_root_validators () super () . __init__ ( ** data )","title":"EntryResourceCreate"},{"location":"api_reference/models/resources/#optimade_gateway.models.resources.EntryResourceCreate.id","text":"","title":"id"},{"location":"api_reference/models/resources/#optimade_gateway.models.resources.EntryResourceCreate.last_modified","text":"","title":"last_modified"},{"location":"api_reference/models/resources/#optimade_gateway.models.resources.EntryResourceCreate.Config","text":"Silently discard extra initiation keys. Source code in optimade_gateway/models/resources.py 20 21 22 23 class Config : \"\"\"Silently discard extra initiation keys.\"\"\" extra = \"ignore\"","title":"Config"},{"location":"api_reference/models/resources/#optimade_gateway.models.resources.EntryResourceCreate.Config.extra","text":"","title":"extra"},{"location":"api_reference/models/resources/#optimade_gateway.models.resources.EntryResourceCreate.__init__","text":"Remove root_validator check_illegal_attributes_fields . Source code in optimade_gateway/models/resources.py 36 37 38 39 def __init__ ( self , ** data : Any ) -> None : \"\"\"Remove root_validator `check_illegal_attributes_fields`.\"\"\" self . _remove_pre_root_validators () super () . __init__ ( ** data )","title":"__init__()"},{"location":"api_reference/models/responses/","text":"responses \u00b6 Pydantic models/schemas for the API responses. DatabasesResponse \u00b6 Bases: EntryResponseMany Successful response for GET /databases This model is essentially equal to LinksResponse with the exception of the `data\u00b4 field's description. Source code in optimade_gateway/models/responses.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class DatabasesResponse ( EntryResponseMany ): \"\"\"Successful response for `GET /databases` This model is essentially equal to [`LinksResponse`](https://www.optimade.org/optimade-python-tools/api_reference/models/responses/#optimade.models.responses.LinksResponse) with the exception of the `data\u00b4 field's description. \"\"\" data : List [ LinksResource ] = Field ( ... , description = ( \"List of unique OPTIMADE links resource objects. \\n These links resource \" \"objects represents OPTIMADE databases that can be used for queries in \" \"gateways.\" ), uniqueItems = True , ) data : List [ LinksResource ] = Field ( Ellipsis , description = 'List of unique OPTIMADE links resource objects. \\n These links resource objects represents OPTIMADE databases that can be used for queries in gateways.' , uniqueItems = True ) class-attribute \u00b6 DatabasesResponseSingle \u00b6 Bases: EntryResponseOne Successful response for POST /databases and GET /databases/{database_id} Source code in optimade_gateway/models/responses.py 31 32 33 34 35 36 37 38 39 40 41 42 class DatabasesResponseSingle ( EntryResponseOne ): \"\"\"Successful response for `POST /databases` and `GET /databases/{database_id}`\"\"\" data : Optional [ LinksResource ] = Field ( ... , description = ( \"A unique OPTIMADE links resource object. \\n The OPTIMADE links resource object\" \" has just been created or found according to the specific query parameter(s)\" \" or URL id. \\n It represents an OPTIMADE database that can be used for queries\" \" in gateways.\" ), ) data : Optional [ LinksResource ] = Field ( Ellipsis , description = 'A unique OPTIMADE links resource object. \\n The OPTIMADE links resource object has just been created or found according to the specific query parameter(s) or URL id. \\n It represents an OPTIMADE database that can be used for queries in gateways.' ) class-attribute \u00b6 GatewaysResponse \u00b6 Bases: EntryResponseMany Successful response for GET /gateways Source code in optimade_gateway/models/responses.py 45 46 47 48 49 50 51 52 class GatewaysResponse ( EntryResponseMany ): \"\"\"Successful response for `GET /gateways`\"\"\" data : List [ GatewayResource ] = Field ( ... , description = \"\"\"List of unique OPTIMADE gateway resource objects.\"\"\" , uniqueItems = True , ) data : List [ GatewayResource ] = Field ( Ellipsis , description = 'List of unique OPTIMADE gateway resource objects.' , uniqueItems = True ) class-attribute \u00b6 GatewaysResponseSingle \u00b6 Bases: EntryResponseOne Successful response for POST /gateways and GET /gateways/{gateway_id} . Source code in optimade_gateway/models/responses.py 55 56 57 58 59 60 61 62 63 64 65 class GatewaysResponseSingle ( EntryResponseOne ): \"\"\"Successful response for `POST /gateways` and `GET /gateways/{gateway_id}`.\"\"\" data : Optional [ GatewayResource ] = Field ( ... , description = ( \"A unique OPTIMADE gateway resource object. \\n The OPTIMADE gateway resource \" \"object has just been created or found according to the specific query \" \"parameter(s) or URL id.\" ), ) data : Optional [ GatewayResource ] = Field ( Ellipsis , description = 'A unique OPTIMADE gateway resource object. \\n The OPTIMADE gateway resource object has just been created or found according to the specific query parameter(s) or URL id.' ) class-attribute \u00b6 QueriesResponse \u00b6 Bases: EntryResponseMany Successful response for GET /gateways/{gateway_ID}/queries . Source code in optimade_gateway/models/responses.py 68 69 70 71 72 73 74 75 class QueriesResponse ( EntryResponseMany ): \"\"\"Successful response for `GET /gateways/{gateway_ID}/queries`.\"\"\" data : List [ QueryResource ] = Field ( ... , description = \"List of unique OPTIMADE gateway query resource objects.\" , uniqueItems = True , ) data : List [ QueryResource ] = Field ( Ellipsis , description = 'List of unique OPTIMADE gateway query resource objects.' , uniqueItems = True ) class-attribute \u00b6 QueriesResponseSingle \u00b6 Bases: EntryResponseOne Successful response for POST /gateways/{gateway_ID}/queries and GET /gateways/{gateway_ID}/queries/{query_id} . Source code in optimade_gateway/models/responses.py 78 79 80 81 82 83 84 85 86 87 88 89 class QueriesResponseSingle ( EntryResponseOne ): \"\"\"Successful response for `POST /gateways/{gateway_ID}/queries` and `GET /gateways/{gateway_ID}/queries/{query_id}`.\"\"\" data : Optional [ QueryResource ] = Field ( ... , description = ( \"A unique OPTIMADE gateway query resource object. \\n The OPTIMADE gateway query\" \" resource object has just been created or found according to the specific \" \"query parameter(s) or URL id.\" ), ) data : Optional [ QueryResource ] = Field ( Ellipsis , description = 'A unique OPTIMADE gateway query resource object. \\n The OPTIMADE gateway query resource object has just been created or found according to the specific query parameter(s) or URL id.' ) class-attribute \u00b6","title":"responses"},{"location":"api_reference/models/responses/#responses","text":"Pydantic models/schemas for the API responses.","title":"responses"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.DatabasesResponse","text":"Bases: EntryResponseMany Successful response for GET /databases This model is essentially equal to LinksResponse with the exception of the `data\u00b4 field's description. Source code in optimade_gateway/models/responses.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class DatabasesResponse ( EntryResponseMany ): \"\"\"Successful response for `GET /databases` This model is essentially equal to [`LinksResponse`](https://www.optimade.org/optimade-python-tools/api_reference/models/responses/#optimade.models.responses.LinksResponse) with the exception of the `data\u00b4 field's description. \"\"\" data : List [ LinksResource ] = Field ( ... , description = ( \"List of unique OPTIMADE links resource objects. \\n These links resource \" \"objects represents OPTIMADE databases that can be used for queries in \" \"gateways.\" ), uniqueItems = True , )","title":"DatabasesResponse"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.DatabasesResponse.data","text":"","title":"data"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.DatabasesResponseSingle","text":"Bases: EntryResponseOne Successful response for POST /databases and GET /databases/{database_id} Source code in optimade_gateway/models/responses.py 31 32 33 34 35 36 37 38 39 40 41 42 class DatabasesResponseSingle ( EntryResponseOne ): \"\"\"Successful response for `POST /databases` and `GET /databases/{database_id}`\"\"\" data : Optional [ LinksResource ] = Field ( ... , description = ( \"A unique OPTIMADE links resource object. \\n The OPTIMADE links resource object\" \" has just been created or found according to the specific query parameter(s)\" \" or URL id. \\n It represents an OPTIMADE database that can be used for queries\" \" in gateways.\" ), )","title":"DatabasesResponseSingle"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.DatabasesResponseSingle.data","text":"","title":"data"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.GatewaysResponse","text":"Bases: EntryResponseMany Successful response for GET /gateways Source code in optimade_gateway/models/responses.py 45 46 47 48 49 50 51 52 class GatewaysResponse ( EntryResponseMany ): \"\"\"Successful response for `GET /gateways`\"\"\" data : List [ GatewayResource ] = Field ( ... , description = \"\"\"List of unique OPTIMADE gateway resource objects.\"\"\" , uniqueItems = True , )","title":"GatewaysResponse"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.GatewaysResponse.data","text":"","title":"data"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.GatewaysResponseSingle","text":"Bases: EntryResponseOne Successful response for POST /gateways and GET /gateways/{gateway_id} . Source code in optimade_gateway/models/responses.py 55 56 57 58 59 60 61 62 63 64 65 class GatewaysResponseSingle ( EntryResponseOne ): \"\"\"Successful response for `POST /gateways` and `GET /gateways/{gateway_id}`.\"\"\" data : Optional [ GatewayResource ] = Field ( ... , description = ( \"A unique OPTIMADE gateway resource object. \\n The OPTIMADE gateway resource \" \"object has just been created or found according to the specific query \" \"parameter(s) or URL id.\" ), )","title":"GatewaysResponseSingle"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.GatewaysResponseSingle.data","text":"","title":"data"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.QueriesResponse","text":"Bases: EntryResponseMany Successful response for GET /gateways/{gateway_ID}/queries . Source code in optimade_gateway/models/responses.py 68 69 70 71 72 73 74 75 class QueriesResponse ( EntryResponseMany ): \"\"\"Successful response for `GET /gateways/{gateway_ID}/queries`.\"\"\" data : List [ QueryResource ] = Field ( ... , description = \"List of unique OPTIMADE gateway query resource objects.\" , uniqueItems = True , )","title":"QueriesResponse"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.QueriesResponse.data","text":"","title":"data"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.QueriesResponseSingle","text":"Bases: EntryResponseOne Successful response for POST /gateways/{gateway_ID}/queries and GET /gateways/{gateway_ID}/queries/{query_id} . Source code in optimade_gateway/models/responses.py 78 79 80 81 82 83 84 85 86 87 88 89 class QueriesResponseSingle ( EntryResponseOne ): \"\"\"Successful response for `POST /gateways/{gateway_ID}/queries` and `GET /gateways/{gateway_ID}/queries/{query_id}`.\"\"\" data : Optional [ QueryResource ] = Field ( ... , description = ( \"A unique OPTIMADE gateway query resource object. \\n The OPTIMADE gateway query\" \" resource object has just been created or found according to the specific \" \"query parameter(s) or URL id.\" ), )","title":"QueriesResponseSingle"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.QueriesResponseSingle.data","text":"","title":"data"},{"location":"api_reference/models/search/","text":"search \u00b6 Pydantic models/schemas for the Search resource. Search \u00b6 Bases: BaseModel A general coordinated OPTIMADE search Important Either database_ids or optimade_urls MUST be specified. Source code in optimade_gateway/models/search.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class Search ( BaseModel ): \"\"\"A general coordinated OPTIMADE search !!! important Either `database_ids` or `optimade_urls` MUST be specified. \"\"\" query_parameters : OptimadeQueryParameters = Field ( {}, description = ( \"OPTIMADE query parameters for entry listing endpoints used for this query.\" ), ) database_ids : Set [ str ] = Field ( set (), description = ( \"A list of registered database IDs. Go to `/databases` to get all registered\" \" databases.\" ), ) optimade_urls : Set [ AnyUrl ] = Field ( set (), description = ( \"A list of OPTIMADE base URLs. If a versioned base URL is supplied it will be\" \" used as is, as long as it represents a supported version. If an \" \"un-versioned base URL, standard version negotiation will be conducted to get\" \" the versioned base URL, which will be used as long as it represents a \" \"supported version. Note, a single URL can be supplied as well, and it will \" \"automatically be wrapped in a list in the server logic.\" ), ) endpoint : str = Field ( \"structures\" , description = ( \"The entry endpoint queried. According to the OPTIMADE specification, this is\" \" the same as the resource's type.\" ), ) @root_validator def either_ids_or_urls ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `optimade_urls` must be defined\"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"optimade_urls\" )): raise ValueError ( \"Either 'database_ids' or 'optimade_urls' MUST be specified.\" ) return values @validator ( \"query_parameters\" ) def sort_not_supported ( cls , value : OptimadeQueryParameters ) -> OptimadeQueryParameters : \"\"\"Warn and reset value if `sort` is supplied.\"\"\" if value . sort : warnings . warn ( SortNotSupported ()) value . sort = None return value database_ids : Set [ str ] = Field ( set (), description = 'A list of registered database IDs. Go to `/databases` to get all registered databases.' ) class-attribute \u00b6 endpoint : str = Field ( 'structures' , description = \"The entry endpoint queried. According to the OPTIMADE specification, this is the same as the resource's type.\" ) class-attribute \u00b6 optimade_urls : Set [ AnyUrl ] = Field ( set (), description = 'A list of OPTIMADE base URLs. If a versioned base URL is supplied it will be used as is, as long as it represents a supported version. If an un-versioned base URL, standard version negotiation will be conducted to get the versioned base URL, which will be used as long as it represents a supported version. Note, a single URL can be supplied as well, and it will automatically be wrapped in a list in the server logic.' ) class-attribute \u00b6 query_parameters : OptimadeQueryParameters = Field ({}, description = 'OPTIMADE query parameters for entry listing endpoints used for this query.' ) class-attribute \u00b6 either_ids_or_urls ( values ) \u00b6 Either database_ids or optimade_urls must be defined Source code in optimade_gateway/models/search.py 52 53 54 55 56 57 58 59 @root_validator def either_ids_or_urls ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `optimade_urls` must be defined\"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"optimade_urls\" )): raise ValueError ( \"Either 'database_ids' or 'optimade_urls' MUST be specified.\" ) return values sort_not_supported ( value ) \u00b6 Warn and reset value if sort is supplied. Source code in optimade_gateway/models/search.py 61 62 63 64 65 66 67 68 69 @validator ( \"query_parameters\" ) def sort_not_supported ( cls , value : OptimadeQueryParameters ) -> OptimadeQueryParameters : \"\"\"Warn and reset value if `sort` is supplied.\"\"\" if value . sort : warnings . warn ( SortNotSupported ()) value . sort = None return value","title":"search"},{"location":"api_reference/models/search/#search","text":"Pydantic models/schemas for the Search resource.","title":"search"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search","text":"Bases: BaseModel A general coordinated OPTIMADE search Important Either database_ids or optimade_urls MUST be specified. Source code in optimade_gateway/models/search.py 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 class Search ( BaseModel ): \"\"\"A general coordinated OPTIMADE search !!! important Either `database_ids` or `optimade_urls` MUST be specified. \"\"\" query_parameters : OptimadeQueryParameters = Field ( {}, description = ( \"OPTIMADE query parameters for entry listing endpoints used for this query.\" ), ) database_ids : Set [ str ] = Field ( set (), description = ( \"A list of registered database IDs. Go to `/databases` to get all registered\" \" databases.\" ), ) optimade_urls : Set [ AnyUrl ] = Field ( set (), description = ( \"A list of OPTIMADE base URLs. If a versioned base URL is supplied it will be\" \" used as is, as long as it represents a supported version. If an \" \"un-versioned base URL, standard version negotiation will be conducted to get\" \" the versioned base URL, which will be used as long as it represents a \" \"supported version. Note, a single URL can be supplied as well, and it will \" \"automatically be wrapped in a list in the server logic.\" ), ) endpoint : str = Field ( \"structures\" , description = ( \"The entry endpoint queried. According to the OPTIMADE specification, this is\" \" the same as the resource's type.\" ), ) @root_validator def either_ids_or_urls ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `optimade_urls` must be defined\"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"optimade_urls\" )): raise ValueError ( \"Either 'database_ids' or 'optimade_urls' MUST be specified.\" ) return values @validator ( \"query_parameters\" ) def sort_not_supported ( cls , value : OptimadeQueryParameters ) -> OptimadeQueryParameters : \"\"\"Warn and reset value if `sort` is supplied.\"\"\" if value . sort : warnings . warn ( SortNotSupported ()) value . sort = None return value","title":"Search"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search.database_ids","text":"","title":"database_ids"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search.endpoint","text":"","title":"endpoint"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search.optimade_urls","text":"","title":"optimade_urls"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search.query_parameters","text":"","title":"query_parameters"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search.either_ids_or_urls","text":"Either database_ids or optimade_urls must be defined Source code in optimade_gateway/models/search.py 52 53 54 55 56 57 58 59 @root_validator def either_ids_or_urls ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `optimade_urls` must be defined\"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"optimade_urls\" )): raise ValueError ( \"Either 'database_ids' or 'optimade_urls' MUST be specified.\" ) return values","title":"either_ids_or_urls()"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search.sort_not_supported","text":"Warn and reset value if sort is supplied. Source code in optimade_gateway/models/search.py 61 62 63 64 65 66 67 68 69 @validator ( \"query_parameters\" ) def sort_not_supported ( cls , value : OptimadeQueryParameters ) -> OptimadeQueryParameters : \"\"\"Warn and reset value if `sort` is supplied.\"\"\" if value . sort : warnings . warn ( SortNotSupported ()) value . sort = None return value","title":"sort_not_supported()"},{"location":"api_reference/mongo/collection/","text":"collection \u00b6 MongoDB collection for entry-endpoint resources. The AsyncMongoCollection represents an asynchronous version of the equivalent MongoDB collection in optimade : MongoCollection . AsyncMongoCollection \u00b6 Bases: EntryCollection MongoDB Collection for use with asyncio The asynchronicity is implemented using motor and asyncio . Source code in optimade_gateway/mongo/collection.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 class AsyncMongoCollection ( EntryCollection ): \"\"\"MongoDB Collection for use with `asyncio` The asynchronicity is implemented using [`motor`](https://motor.readthedocs.io) and [`asyncio`](https://asyncio.readthedocs.io/). \"\"\" def __init__ ( self , name : str , resource_cls : \"EntryResource\" , resource_mapper : \"BaseResourceMapper\" , ): \"\"\"Initialize the AsyncMongoCollection for the given parameters. Parameters: name: The name of the collection. resource_cls: The `EntryResource` model that is stored by the collection. resource_mapper: A resource mapper object that handles aliases and format changes between deserialization and response. \"\"\" from optimade_gateway.mongo.database import ( # pylint: disable=import-outside-toplevel MONGO_DB , ) super () . __init__ ( resource_cls = resource_cls , resource_mapper = resource_mapper , transformer = MongoTransformer ( mapper = resource_mapper ), ) self . parser = LarkParser ( version = ( 1 , 0 , 0 ), variant = \"default\" ) self . collection : MongoCollection = MONGO_DB [ name ] # Check aliases do not clash with mongo operators self . _check_aliases ( self . resource_mapper . all_aliases ()) self . _check_aliases ( self . resource_mapper . all_length_aliases ()) def __str__ ( self ) -> str : \"\"\"Standard printing result for an instance.\"\"\" return ( f \"< { self . __class__ . __name__ } : resource= { self . resource_cls . __name__ } \" f \"endpoint(mapper)= { self . resource_mapper . ENDPOINT } \" f \"DB_collection= { self . collection . name } >\" ) def __repr__ ( self ) -> str : \"\"\"Representation of instance.\"\"\" return ( f \" { self . __class__ . __name__ } (name= { self . collection . name !r} , \" f \"resource_cls= { self . resource_cls !r} , \" f \"resource_mapper= { self . resource_mapper !r} )\" ) def __len__ ( self ) -> int : warn ( OptimadeGatewayWarning ( detail = ( \"Cannot calculate length of collection using `len()`. Use `count()` \" \"instead.\" ) ) ) return 0 def insert ( self , data : \"List[EntryResource]\" ) -> None : raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `ainsert(data: \" \"List[EntryResource])`.\" ) async def ainsert ( self , data : \"List[EntryResource]\" ) -> None : \"\"\"Add the given entries to the underlying database. This is the asynchronous version of the parent class method named `insert()`. Arguments: data: The entry resource objects to add to the database. \"\"\" await self . collection . insert_many ( await clean_python_types ( data )) def count ( self , ** kwargs ) -> int : raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `acount(params: \" \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]], \" \"**kwargs)`.\" ) async def acount ( self , params : \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]]\" = None , ** kwargs : \"Any\" , ) -> int : \"\"\"Count documents in Collection. This is the asynchronous version of the parent class method named `count()`. Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. **kwargs: Query parameters as keyword arguments. Valid keys will be passed to the [`AsyncIOMotorCollection.count_documents`](https://motor.readthedocs.io/en/stable/api-asyncio/asyncio_motor_collection.html#motor.motor_asyncio.AsyncIOMotorCollection.count_documents) method. Returns: int: The number of entries matching the query specified by the keyword arguments. \"\"\" if params is not None and kwargs : raise ValueError ( \"When 'params' is supplied, no other parameters can be supplied.\" ) if params is not None : kwargs = await self . ahandle_query_params ( params ) valid_method_keys = ( \"filter\" , \"skip\" , \"limit\" , \"hint\" , \"maxTimeMS\" , \"collation\" , \"session\" , ) criteria = { key : kwargs [ key ] for key in valid_method_keys if key in kwargs } if criteria . get ( \"filter\" ) is None : criteria [ \"filter\" ] = {} return await self . collection . count_documents ( ** criteria ) def find ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]]\" : \"\"\" Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of `page_limit`. See [`EntryListingQueryParams`](https://www.optimade.org/optimade-python-tools/api_reference/server/query_params/#optimade.server.query_params.EntryListingQueryParams) for more information. Parameters: params: Entry listing URL query params. Returns: A tuple of various relevant values: (`results`, `data_returned`, `more_data_available`, `exclude_fields`, `include_fields`). \"\"\" raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `afind(params: \" \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]], criteria: \" \"Optional[Dict[str, Any]])`.\" ) async def afind ( self , params : \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]]\" = None , criteria : \"Optional[Dict[str, Any]]\" = None , ) -> \"Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]]\" : \"\"\"Perform the query on the underlying MongoDB Collection, handling projection and pagination of the output. This is the asynchronous version of the parent class method named `count()`. Either provide `params` or `criteria`. Not both, but at least one. Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. criteria: Already handled/parsed URL query parameters. Returns: A list of entry resource objects, how much data was returned for the query, whether more data is available with pagination, and fields (excluded, included). \"\"\" if ( params is None and criteria is None ) or ( params is not None and criteria is not None ): raise ValueError ( \"Exacly one of either `params` and `criteria` must be specified.\" ) # Set single_entry to False, this is done since if criteria is defined, # this is an unknown factor - better to then get a list of results. single_entry = False if criteria is None : criteria = await self . ahandle_query_params ( params ) else : single_entry = isinstance ( params , SingleEntryQueryParams ) response_fields = criteria . pop ( \"fields\" , self . all_fields ) results , data_returned , more_data_available = await self . _arun_db_query ( criteria = criteria , single_entry = single_entry , ) if single_entry : results = results [ 0 ] if results else None # type: ignore[assignment] if data_returned > 1 : raise NotFound ( detail = ( f \"Instead of a single entry, { data_returned } entries were found\" ), ) include_fields = ( response_fields - self . resource_mapper . TOP_LEVEL_NON_ATTRIBUTES_FIELDS ) bad_optimade_fields = set () bad_provider_fields = set () for field in include_fields : if field not in self . resource_mapper . ALL_ATTRIBUTES : if field . startswith ( \"_\" ): if any ( field . startswith ( f \"_ { prefix } _\" ) for prefix in self . resource_mapper . SUPPORTED_PREFIXES ): bad_provider_fields . add ( field ) else : bad_optimade_fields . add ( field ) if bad_provider_fields : warn ( UnknownProviderProperty ( detail = ( \"Unrecognised field(s) for this provider requested in \" f \"`response_fields`: { bad_provider_fields } .\" ) ) ) if bad_optimade_fields : raise BadRequest ( detail = ( \"Unrecognised OPTIMADE field(s) in requested `response_fields`: \" f \" { bad_optimade_fields } .\" ) ) if results : results = await self . resource_mapper . adeserialize ( results ) return ( # type: ignore[return-value] results , data_returned , more_data_available , self . all_fields - response_fields , include_fields , ) def handle_query_params ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Dict[str, Any]\" : \"\"\"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note: Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: params: The initialized query parameter model from the server. Raises: Forbidden: If too large of a page limit is provided. BadRequest: If an invalid request is made, e.g., with incorrect fields or response format. Returns: A dictionary representation of the query parameters. \"\"\" raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `ahandle_query_params(params: \" \"Union[EntryListingQueryParams, SingleEntryQueryParams])`.\" ) async def ahandle_query_params ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Dict[str, Any]\" : \"\"\"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. This is the asynchronous version of the parent class method named `handle_query_params()`. Note: Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: params: The initialized query parameter model from the server. Raises: Forbidden: If too large of a page limit is provided. BadRequest: If an invalid request is made, e.g., with incorrect fields or response format. Returns: A dictionary representation of the query parameters. \"\"\" return super () . handle_query_params ( params ) def _run_db_query ( self , criteria : \"Dict[str, Any]\" , single_entry : bool = False ) -> \"Tuple[List[Dict[str, Any]], int, bool]\" : raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `_arun_db_query(criteria: \" \"Dict[str, Any], single_entry: bool)`.\" ) async def _arun_db_query ( self , criteria : \"Dict[str, Any]\" , single_entry : bool = False ) -> \"Tuple[List[Dict[str, Any]], int, bool]\" : \"\"\"Run the query on the backend and collect the results. This is the asynchronous version of the parent class method named `count()`. Arguments: criteria: A dictionary representation of the query parameters. single_entry: Whether or not the caller is expecting a single entry response. Returns: The list of entries from the database (without any re-mapping), the total number of entries matching the query and a boolean for whether or not there is more data available. \"\"\" results = [] async for document in self . collection . find ( ** self . _valid_find_keys ( ** criteria )): if criteria . get ( \"projection\" , {}) . get ( \"_id\" ): document [ \"_id\" ] = str ( document [ \"_id\" ]) results . append ( document ) if single_entry : data_returned = len ( results ) more_data_available = False else : criteria_nolimit = criteria . copy () criteria_nolimit . pop ( \"limit\" , None ) data_returned = await self . acount ( params = None , ** criteria_nolimit ) more_data_available = len ( results ) < data_returned return results , data_returned , more_data_available @staticmethod def _check_aliases ( aliases : \"Tuple[Tuple[str, str]]\" ) -> None : \"\"\"Check that aliases do not clash with mongo keywords. Parameters: aliases: Tuple of tuple of aliases to be checked. Raises: RuntimeError: If any alias starts with the dollar (`$`) character. \"\"\" if any ( alias [ 0 ] . startswith ( \"$\" ) or alias [ 1 ] . startswith ( \"$\" ) for alias in aliases ): raise RuntimeError ( f \"Cannot define an alias starting with a '$': { aliases } \" ) async def get_one ( self , ** criteria : \"Any\" ) -> \"EntryResource\" : \"\"\"Get one resource based on criteria Warning: This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a single resource. Parameters: **criteria: Already handled/parsed URL query parameters. Returns: A single resource from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ( ** self . _valid_find_keys ( ** criteria )) ) ) async def get_multiple ( self , ** criteria : \"Any\" ) -> \"List[EntryResource]\" : \"\"\"Get a list of resources based on criteria Warning: This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a list of resources. Parameters: **criteria: Already handled/parsed URL query parameters. Returns: A list of resources from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} results = [] async for document in self . collection . find ( ** self . _valid_find_keys ( ** criteria )): results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( document ))) return results async def create_one ( self , resource : \"EntryResourceCreate\" ) -> \"EntryResource\" : \"\"\"Create a new document in the MongoDB collection based on query parameters. Update the newly created document with an `\"id\"` field. The value will be the string representation of the `\"_id\"` field. This will only be done if `\"id\"` is not already present in `resource`. Parameters: resource: The resource to be created. Returns: The newly created document as a pydantic model entry resource. \"\"\" resource . last_modified = datetime . utcnow () result = await self . collection . insert_one ( await clean_python_types ( resource . dict ( exclude_unset = True )) ) LOGGER . debug ( \"Inserted resource %r in DB collection %s with ID %s \" , resource , self . collection . name , result . inserted_id , ) if not resource . id : LOGGER . debug ( \"Updating resource with an `id` field equal to str(id_).\" ) await self . collection . update_one ( { \"_id\" : result . inserted_id }, { \"$set\" : { \"id\" : str ( result . inserted_id )}} ) return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ({ \"_id\" : result . inserted_id }) ) ) async def exists ( self , entry_id : str ) -> bool : \"\"\"Assert whether entry_id exists in the collection (value of `\"id\"`) Parameters: entry_id: The `\"id\"` value of the entry. \"\"\" return bool ( await self . collection . count_documents ({ \"id\" : entry_id })) @staticmethod def _valid_find_keys ( ** kwargs : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Return valid MongoDB find() keys with values from kwargs Note, not including deprecated flags (see https://pymongo.readthedocs.io/en/3.11.0/api/pymongo/collection.html#pymongo.collection.Collection.find). \"\"\" valid_method_keys = ( \"filter\" , \"projection\" , \"session\" , \"skip\" , \"limit\" , \"no_cursor_timeout\" , \"cursor_type\" , \"sort\" , \"allow_partial_results\" , \"batch_size\" , \"collation\" , \"return_key\" , \"show_record_id\" , \"hint\" , \"max_time_ms\" , \"min\" , \"max\" , \"comment\" , \"allow_disk_use\" , ) criteria = { key : kwargs [ key ] for key in valid_method_keys if key in kwargs } if criteria . get ( \"filter\" ) is None : # Ensure documents are included in the result set criteria [ \"filter\" ] = {} return criteria __init__ ( name , resource_cls , resource_mapper ) \u00b6 Initialize the AsyncMongoCollection for the given parameters. Parameters: Name Type Description Default name str The name of the collection. required resource_cls EntryResource The EntryResource model that is stored by the collection. required resource_mapper BaseResourceMapper A resource mapper object that handles aliases and format changes between deserialization and response. required Source code in optimade_gateway/mongo/collection.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def __init__ ( self , name : str , resource_cls : \"EntryResource\" , resource_mapper : \"BaseResourceMapper\" , ): \"\"\"Initialize the AsyncMongoCollection for the given parameters. Parameters: name: The name of the collection. resource_cls: The `EntryResource` model that is stored by the collection. resource_mapper: A resource mapper object that handles aliases and format changes between deserialization and response. \"\"\" from optimade_gateway.mongo.database import ( # pylint: disable=import-outside-toplevel MONGO_DB , ) super () . __init__ ( resource_cls = resource_cls , resource_mapper = resource_mapper , transformer = MongoTransformer ( mapper = resource_mapper ), ) self . parser = LarkParser ( version = ( 1 , 0 , 0 ), variant = \"default\" ) self . collection : MongoCollection = MONGO_DB [ name ] # Check aliases do not clash with mongo operators self . _check_aliases ( self . resource_mapper . all_aliases ()) self . _check_aliases ( self . resource_mapper . all_length_aliases ()) acount ( params = None , ** kwargs ) async \u00b6 Count documents in Collection. This is the asynchronous version of the parent class method named count() . Parameters: Name Type Description Default params Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]] URL query parameters, either from a general entry endpoint or a single-entry endpoint. None **kwargs Any Query parameters as keyword arguments. Valid keys will be passed to the AsyncIOMotorCollection.count_documents method. {} Returns: Name Type Description int int The number of entries matching the query specified by the keyword arguments. Source code in optimade_gateway/mongo/collection.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 async def acount ( self , params : \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]]\" = None , ** kwargs : \"Any\" , ) -> int : \"\"\"Count documents in Collection. This is the asynchronous version of the parent class method named `count()`. Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. **kwargs: Query parameters as keyword arguments. Valid keys will be passed to the [`AsyncIOMotorCollection.count_documents`](https://motor.readthedocs.io/en/stable/api-asyncio/asyncio_motor_collection.html#motor.motor_asyncio.AsyncIOMotorCollection.count_documents) method. Returns: int: The number of entries matching the query specified by the keyword arguments. \"\"\" if params is not None and kwargs : raise ValueError ( \"When 'params' is supplied, no other parameters can be supplied.\" ) if params is not None : kwargs = await self . ahandle_query_params ( params ) valid_method_keys = ( \"filter\" , \"skip\" , \"limit\" , \"hint\" , \"maxTimeMS\" , \"collation\" , \"session\" , ) criteria = { key : kwargs [ key ] for key in valid_method_keys if key in kwargs } if criteria . get ( \"filter\" ) is None : criteria [ \"filter\" ] = {} return await self . collection . count_documents ( ** criteria ) afind ( params = None , criteria = None ) async \u00b6 Perform the query on the underlying MongoDB Collection, handling projection and pagination of the output. This is the asynchronous version of the parent class method named count() . Either provide params or criteria . Not both, but at least one. Parameters: Name Type Description Default params Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]] URL query parameters, either from a general entry endpoint or a single-entry endpoint. None criteria Optional[Dict[str, Any]] Already handled/parsed URL query parameters. None Returns: Type Description Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] A list of entry resource objects, how much data was returned for the query, Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] whether more data is available with pagination, and fields (excluded, Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] included). Source code in optimade_gateway/mongo/collection.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 async def afind ( self , params : \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]]\" = None , criteria : \"Optional[Dict[str, Any]]\" = None , ) -> \"Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]]\" : \"\"\"Perform the query on the underlying MongoDB Collection, handling projection and pagination of the output. This is the asynchronous version of the parent class method named `count()`. Either provide `params` or `criteria`. Not both, but at least one. Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. criteria: Already handled/parsed URL query parameters. Returns: A list of entry resource objects, how much data was returned for the query, whether more data is available with pagination, and fields (excluded, included). \"\"\" if ( params is None and criteria is None ) or ( params is not None and criteria is not None ): raise ValueError ( \"Exacly one of either `params` and `criteria` must be specified.\" ) # Set single_entry to False, this is done since if criteria is defined, # this is an unknown factor - better to then get a list of results. single_entry = False if criteria is None : criteria = await self . ahandle_query_params ( params ) else : single_entry = isinstance ( params , SingleEntryQueryParams ) response_fields = criteria . pop ( \"fields\" , self . all_fields ) results , data_returned , more_data_available = await self . _arun_db_query ( criteria = criteria , single_entry = single_entry , ) if single_entry : results = results [ 0 ] if results else None # type: ignore[assignment] if data_returned > 1 : raise NotFound ( detail = ( f \"Instead of a single entry, { data_returned } entries were found\" ), ) include_fields = ( response_fields - self . resource_mapper . TOP_LEVEL_NON_ATTRIBUTES_FIELDS ) bad_optimade_fields = set () bad_provider_fields = set () for field in include_fields : if field not in self . resource_mapper . ALL_ATTRIBUTES : if field . startswith ( \"_\" ): if any ( field . startswith ( f \"_ { prefix } _\" ) for prefix in self . resource_mapper . SUPPORTED_PREFIXES ): bad_provider_fields . add ( field ) else : bad_optimade_fields . add ( field ) if bad_provider_fields : warn ( UnknownProviderProperty ( detail = ( \"Unrecognised field(s) for this provider requested in \" f \"`response_fields`: { bad_provider_fields } .\" ) ) ) if bad_optimade_fields : raise BadRequest ( detail = ( \"Unrecognised OPTIMADE field(s) in requested `response_fields`: \" f \" { bad_optimade_fields } .\" ) ) if results : results = await self . resource_mapper . adeserialize ( results ) return ( # type: ignore[return-value] results , data_returned , more_data_available , self . all_fields - response_fields , include_fields , ) ahandle_query_params ( params ) async \u00b6 Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. This is the asynchronous version of the parent class method named handle_query_params() . Note Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: Name Type Description Default params Union[EntryListingQueryParams, SingleEntryQueryParams] The initialized query parameter model from the server. required Raises: Type Description Forbidden If too large of a page limit is provided. BadRequest If an invalid request is made, e.g., with incorrect fields or response format. Returns: Type Description Dict[str, Any] A dictionary representation of the query parameters. Source code in optimade_gateway/mongo/collection.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 async def ahandle_query_params ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Dict[str, Any]\" : \"\"\"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. This is the asynchronous version of the parent class method named `handle_query_params()`. Note: Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: params: The initialized query parameter model from the server. Raises: Forbidden: If too large of a page limit is provided. BadRequest: If an invalid request is made, e.g., with incorrect fields or response format. Returns: A dictionary representation of the query parameters. \"\"\" return super () . handle_query_params ( params ) ainsert ( data ) async \u00b6 Add the given entries to the underlying database. This is the asynchronous version of the parent class method named insert() . Parameters: Name Type Description Default data List[EntryResource] The entry resource objects to add to the database. required Source code in optimade_gateway/mongo/collection.py 112 113 114 115 116 117 118 119 120 121 async def ainsert ( self , data : \"List[EntryResource]\" ) -> None : \"\"\"Add the given entries to the underlying database. This is the asynchronous version of the parent class method named `insert()`. Arguments: data: The entry resource objects to add to the database. \"\"\" await self . collection . insert_many ( await clean_python_types ( data )) create_one ( resource ) async \u00b6 Create a new document in the MongoDB collection based on query parameters. Update the newly created document with an \"id\" field. The value will be the string representation of the \"_id\" field. This will only be done if \"id\" is not already present in resource . Parameters: Name Type Description Default resource EntryResourceCreate The resource to be created. required Returns: Type Description EntryResource The newly created document as a pydantic model entry resource. Source code in optimade_gateway/mongo/collection.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 async def create_one ( self , resource : \"EntryResourceCreate\" ) -> \"EntryResource\" : \"\"\"Create a new document in the MongoDB collection based on query parameters. Update the newly created document with an `\"id\"` field. The value will be the string representation of the `\"_id\"` field. This will only be done if `\"id\"` is not already present in `resource`. Parameters: resource: The resource to be created. Returns: The newly created document as a pydantic model entry resource. \"\"\" resource . last_modified = datetime . utcnow () result = await self . collection . insert_one ( await clean_python_types ( resource . dict ( exclude_unset = True )) ) LOGGER . debug ( \"Inserted resource %r in DB collection %s with ID %s \" , resource , self . collection . name , result . inserted_id , ) if not resource . id : LOGGER . debug ( \"Updating resource with an `id` field equal to str(id_).\" ) await self . collection . update_one ( { \"_id\" : result . inserted_id }, { \"$set\" : { \"id\" : str ( result . inserted_id )}} ) return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ({ \"_id\" : result . inserted_id }) ) ) exists ( entry_id ) async \u00b6 Assert whether entry_id exists in the collection (value of \"id\" ) Parameters: Name Type Description Default entry_id str The \"id\" value of the entry. required Source code in optimade_gateway/mongo/collection.py 499 500 501 502 503 504 505 506 async def exists ( self , entry_id : str ) -> bool : \"\"\"Assert whether entry_id exists in the collection (value of `\"id\"`) Parameters: entry_id: The `\"id\"` value of the entry. \"\"\" return bool ( await self . collection . count_documents ({ \"id\" : entry_id })) find ( params ) \u00b6 Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of page_limit . See EntryListingQueryParams for more information. Parameters: Name Type Description Default params Union[EntryListingQueryParams, SingleEntryQueryParams] Entry listing URL query params. required Returns: Type Description Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] A tuple of various relevant values: Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] ( results , data_returned , more_data_available , exclude_fields , Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] include_fields ). Source code in optimade_gateway/mongo/collection.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def find ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]]\" : \"\"\" Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of `page_limit`. See [`EntryListingQueryParams`](https://www.optimade.org/optimade-python-tools/api_reference/server/query_params/#optimade.server.query_params.EntryListingQueryParams) for more information. Parameters: params: Entry listing URL query params. Returns: A tuple of various relevant values: (`results`, `data_returned`, `more_data_available`, `exclude_fields`, `include_fields`). \"\"\" raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `afind(params: \" \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]], criteria: \" \"Optional[Dict[str, Any]])`.\" ) get_multiple ( ** criteria ) async \u00b6 Get a list of resources based on criteria Warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a list of resources. Parameters: Name Type Description Default **criteria Any Already handled/parsed URL query parameters. {} Returns: Type Description List[EntryResource] A list of resources from the MongoDB (mapped to pydantic models). Source code in optimade_gateway/mongo/collection.py 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 async def get_multiple ( self , ** criteria : \"Any\" ) -> \"List[EntryResource]\" : \"\"\"Get a list of resources based on criteria Warning: This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a list of resources. Parameters: **criteria: Already handled/parsed URL query parameters. Returns: A list of resources from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} results = [] async for document in self . collection . find ( ** self . _valid_find_keys ( ** criteria )): results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( document ))) return results get_one ( ** criteria ) async \u00b6 Get one resource based on criteria Warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a single resource. Parameters: Name Type Description Default **criteria Any Already handled/parsed URL query parameters. {} Returns: Type Description EntryResource A single resource from the MongoDB (mapped to pydantic models). Source code in optimade_gateway/mongo/collection.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 async def get_one ( self , ** criteria : \"Any\" ) -> \"EntryResource\" : \"\"\"Get one resource based on criteria Warning: This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a single resource. Parameters: **criteria: Already handled/parsed URL query parameters. Returns: A single resource from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ( ** self . _valid_find_keys ( ** criteria )) ) ) handle_query_params ( params ) \u00b6 Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: Name Type Description Default params Union[EntryListingQueryParams, SingleEntryQueryParams] The initialized query parameter model from the server. required Raises: Type Description Forbidden If too large of a page limit is provided. BadRequest If an invalid request is made, e.g., with incorrect fields or response format. Returns: Type Description Dict[str, Any] A dictionary representation of the query parameters. Source code in optimade_gateway/mongo/collection.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def handle_query_params ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Dict[str, Any]\" : \"\"\"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note: Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: params: The initialized query parameter model from the server. Raises: Forbidden: If too large of a page limit is provided. BadRequest: If an invalid request is made, e.g., with incorrect fields or response format. Returns: A dictionary representation of the query parameters. \"\"\" raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `ahandle_query_params(params: \" \"Union[EntryListingQueryParams, SingleEntryQueryParams])`.\" )","title":"collection"},{"location":"api_reference/mongo/collection/#collection","text":"MongoDB collection for entry-endpoint resources. The AsyncMongoCollection represents an asynchronous version of the equivalent MongoDB collection in optimade : MongoCollection .","title":"collection"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection","text":"Bases: EntryCollection MongoDB Collection for use with asyncio The asynchronicity is implemented using motor and asyncio . Source code in optimade_gateway/mongo/collection.py 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 439 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 461 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 498 499 500 501 502 503 504 505 506 507 508 509 510 511 512 513 514 515 516 517 518 519 520 521 522 523 524 525 526 527 528 529 530 531 532 533 534 535 536 537 538 539 540 541 542 class AsyncMongoCollection ( EntryCollection ): \"\"\"MongoDB Collection for use with `asyncio` The asynchronicity is implemented using [`motor`](https://motor.readthedocs.io) and [`asyncio`](https://asyncio.readthedocs.io/). \"\"\" def __init__ ( self , name : str , resource_cls : \"EntryResource\" , resource_mapper : \"BaseResourceMapper\" , ): \"\"\"Initialize the AsyncMongoCollection for the given parameters. Parameters: name: The name of the collection. resource_cls: The `EntryResource` model that is stored by the collection. resource_mapper: A resource mapper object that handles aliases and format changes between deserialization and response. \"\"\" from optimade_gateway.mongo.database import ( # pylint: disable=import-outside-toplevel MONGO_DB , ) super () . __init__ ( resource_cls = resource_cls , resource_mapper = resource_mapper , transformer = MongoTransformer ( mapper = resource_mapper ), ) self . parser = LarkParser ( version = ( 1 , 0 , 0 ), variant = \"default\" ) self . collection : MongoCollection = MONGO_DB [ name ] # Check aliases do not clash with mongo operators self . _check_aliases ( self . resource_mapper . all_aliases ()) self . _check_aliases ( self . resource_mapper . all_length_aliases ()) def __str__ ( self ) -> str : \"\"\"Standard printing result for an instance.\"\"\" return ( f \"< { self . __class__ . __name__ } : resource= { self . resource_cls . __name__ } \" f \"endpoint(mapper)= { self . resource_mapper . ENDPOINT } \" f \"DB_collection= { self . collection . name } >\" ) def __repr__ ( self ) -> str : \"\"\"Representation of instance.\"\"\" return ( f \" { self . __class__ . __name__ } (name= { self . collection . name !r} , \" f \"resource_cls= { self . resource_cls !r} , \" f \"resource_mapper= { self . resource_mapper !r} )\" ) def __len__ ( self ) -> int : warn ( OptimadeGatewayWarning ( detail = ( \"Cannot calculate length of collection using `len()`. Use `count()` \" \"instead.\" ) ) ) return 0 def insert ( self , data : \"List[EntryResource]\" ) -> None : raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `ainsert(data: \" \"List[EntryResource])`.\" ) async def ainsert ( self , data : \"List[EntryResource]\" ) -> None : \"\"\"Add the given entries to the underlying database. This is the asynchronous version of the parent class method named `insert()`. Arguments: data: The entry resource objects to add to the database. \"\"\" await self . collection . insert_many ( await clean_python_types ( data )) def count ( self , ** kwargs ) -> int : raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `acount(params: \" \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]], \" \"**kwargs)`.\" ) async def acount ( self , params : \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]]\" = None , ** kwargs : \"Any\" , ) -> int : \"\"\"Count documents in Collection. This is the asynchronous version of the parent class method named `count()`. Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. **kwargs: Query parameters as keyword arguments. Valid keys will be passed to the [`AsyncIOMotorCollection.count_documents`](https://motor.readthedocs.io/en/stable/api-asyncio/asyncio_motor_collection.html#motor.motor_asyncio.AsyncIOMotorCollection.count_documents) method. Returns: int: The number of entries matching the query specified by the keyword arguments. \"\"\" if params is not None and kwargs : raise ValueError ( \"When 'params' is supplied, no other parameters can be supplied.\" ) if params is not None : kwargs = await self . ahandle_query_params ( params ) valid_method_keys = ( \"filter\" , \"skip\" , \"limit\" , \"hint\" , \"maxTimeMS\" , \"collation\" , \"session\" , ) criteria = { key : kwargs [ key ] for key in valid_method_keys if key in kwargs } if criteria . get ( \"filter\" ) is None : criteria [ \"filter\" ] = {} return await self . collection . count_documents ( ** criteria ) def find ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]]\" : \"\"\" Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of `page_limit`. See [`EntryListingQueryParams`](https://www.optimade.org/optimade-python-tools/api_reference/server/query_params/#optimade.server.query_params.EntryListingQueryParams) for more information. Parameters: params: Entry listing URL query params. Returns: A tuple of various relevant values: (`results`, `data_returned`, `more_data_available`, `exclude_fields`, `include_fields`). \"\"\" raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `afind(params: \" \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]], criteria: \" \"Optional[Dict[str, Any]])`.\" ) async def afind ( self , params : \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]]\" = None , criteria : \"Optional[Dict[str, Any]]\" = None , ) -> \"Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]]\" : \"\"\"Perform the query on the underlying MongoDB Collection, handling projection and pagination of the output. This is the asynchronous version of the parent class method named `count()`. Either provide `params` or `criteria`. Not both, but at least one. Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. criteria: Already handled/parsed URL query parameters. Returns: A list of entry resource objects, how much data was returned for the query, whether more data is available with pagination, and fields (excluded, included). \"\"\" if ( params is None and criteria is None ) or ( params is not None and criteria is not None ): raise ValueError ( \"Exacly one of either `params` and `criteria` must be specified.\" ) # Set single_entry to False, this is done since if criteria is defined, # this is an unknown factor - better to then get a list of results. single_entry = False if criteria is None : criteria = await self . ahandle_query_params ( params ) else : single_entry = isinstance ( params , SingleEntryQueryParams ) response_fields = criteria . pop ( \"fields\" , self . all_fields ) results , data_returned , more_data_available = await self . _arun_db_query ( criteria = criteria , single_entry = single_entry , ) if single_entry : results = results [ 0 ] if results else None # type: ignore[assignment] if data_returned > 1 : raise NotFound ( detail = ( f \"Instead of a single entry, { data_returned } entries were found\" ), ) include_fields = ( response_fields - self . resource_mapper . TOP_LEVEL_NON_ATTRIBUTES_FIELDS ) bad_optimade_fields = set () bad_provider_fields = set () for field in include_fields : if field not in self . resource_mapper . ALL_ATTRIBUTES : if field . startswith ( \"_\" ): if any ( field . startswith ( f \"_ { prefix } _\" ) for prefix in self . resource_mapper . SUPPORTED_PREFIXES ): bad_provider_fields . add ( field ) else : bad_optimade_fields . add ( field ) if bad_provider_fields : warn ( UnknownProviderProperty ( detail = ( \"Unrecognised field(s) for this provider requested in \" f \"`response_fields`: { bad_provider_fields } .\" ) ) ) if bad_optimade_fields : raise BadRequest ( detail = ( \"Unrecognised OPTIMADE field(s) in requested `response_fields`: \" f \" { bad_optimade_fields } .\" ) ) if results : results = await self . resource_mapper . adeserialize ( results ) return ( # type: ignore[return-value] results , data_returned , more_data_available , self . all_fields - response_fields , include_fields , ) def handle_query_params ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Dict[str, Any]\" : \"\"\"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note: Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: params: The initialized query parameter model from the server. Raises: Forbidden: If too large of a page limit is provided. BadRequest: If an invalid request is made, e.g., with incorrect fields or response format. Returns: A dictionary representation of the query parameters. \"\"\" raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `ahandle_query_params(params: \" \"Union[EntryListingQueryParams, SingleEntryQueryParams])`.\" ) async def ahandle_query_params ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Dict[str, Any]\" : \"\"\"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. This is the asynchronous version of the parent class method named `handle_query_params()`. Note: Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: params: The initialized query parameter model from the server. Raises: Forbidden: If too large of a page limit is provided. BadRequest: If an invalid request is made, e.g., with incorrect fields or response format. Returns: A dictionary representation of the query parameters. \"\"\" return super () . handle_query_params ( params ) def _run_db_query ( self , criteria : \"Dict[str, Any]\" , single_entry : bool = False ) -> \"Tuple[List[Dict[str, Any]], int, bool]\" : raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `_arun_db_query(criteria: \" \"Dict[str, Any], single_entry: bool)`.\" ) async def _arun_db_query ( self , criteria : \"Dict[str, Any]\" , single_entry : bool = False ) -> \"Tuple[List[Dict[str, Any]], int, bool]\" : \"\"\"Run the query on the backend and collect the results. This is the asynchronous version of the parent class method named `count()`. Arguments: criteria: A dictionary representation of the query parameters. single_entry: Whether or not the caller is expecting a single entry response. Returns: The list of entries from the database (without any re-mapping), the total number of entries matching the query and a boolean for whether or not there is more data available. \"\"\" results = [] async for document in self . collection . find ( ** self . _valid_find_keys ( ** criteria )): if criteria . get ( \"projection\" , {}) . get ( \"_id\" ): document [ \"_id\" ] = str ( document [ \"_id\" ]) results . append ( document ) if single_entry : data_returned = len ( results ) more_data_available = False else : criteria_nolimit = criteria . copy () criteria_nolimit . pop ( \"limit\" , None ) data_returned = await self . acount ( params = None , ** criteria_nolimit ) more_data_available = len ( results ) < data_returned return results , data_returned , more_data_available @staticmethod def _check_aliases ( aliases : \"Tuple[Tuple[str, str]]\" ) -> None : \"\"\"Check that aliases do not clash with mongo keywords. Parameters: aliases: Tuple of tuple of aliases to be checked. Raises: RuntimeError: If any alias starts with the dollar (`$`) character. \"\"\" if any ( alias [ 0 ] . startswith ( \"$\" ) or alias [ 1 ] . startswith ( \"$\" ) for alias in aliases ): raise RuntimeError ( f \"Cannot define an alias starting with a '$': { aliases } \" ) async def get_one ( self , ** criteria : \"Any\" ) -> \"EntryResource\" : \"\"\"Get one resource based on criteria Warning: This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a single resource. Parameters: **criteria: Already handled/parsed URL query parameters. Returns: A single resource from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ( ** self . _valid_find_keys ( ** criteria )) ) ) async def get_multiple ( self , ** criteria : \"Any\" ) -> \"List[EntryResource]\" : \"\"\"Get a list of resources based on criteria Warning: This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a list of resources. Parameters: **criteria: Already handled/parsed URL query parameters. Returns: A list of resources from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} results = [] async for document in self . collection . find ( ** self . _valid_find_keys ( ** criteria )): results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( document ))) return results async def create_one ( self , resource : \"EntryResourceCreate\" ) -> \"EntryResource\" : \"\"\"Create a new document in the MongoDB collection based on query parameters. Update the newly created document with an `\"id\"` field. The value will be the string representation of the `\"_id\"` field. This will only be done if `\"id\"` is not already present in `resource`. Parameters: resource: The resource to be created. Returns: The newly created document as a pydantic model entry resource. \"\"\" resource . last_modified = datetime . utcnow () result = await self . collection . insert_one ( await clean_python_types ( resource . dict ( exclude_unset = True )) ) LOGGER . debug ( \"Inserted resource %r in DB collection %s with ID %s \" , resource , self . collection . name , result . inserted_id , ) if not resource . id : LOGGER . debug ( \"Updating resource with an `id` field equal to str(id_).\" ) await self . collection . update_one ( { \"_id\" : result . inserted_id }, { \"$set\" : { \"id\" : str ( result . inserted_id )}} ) return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ({ \"_id\" : result . inserted_id }) ) ) async def exists ( self , entry_id : str ) -> bool : \"\"\"Assert whether entry_id exists in the collection (value of `\"id\"`) Parameters: entry_id: The `\"id\"` value of the entry. \"\"\" return bool ( await self . collection . count_documents ({ \"id\" : entry_id })) @staticmethod def _valid_find_keys ( ** kwargs : \"Dict[str, Any]\" ) -> \"Dict[str, Any]\" : \"\"\"Return valid MongoDB find() keys with values from kwargs Note, not including deprecated flags (see https://pymongo.readthedocs.io/en/3.11.0/api/pymongo/collection.html#pymongo.collection.Collection.find). \"\"\" valid_method_keys = ( \"filter\" , \"projection\" , \"session\" , \"skip\" , \"limit\" , \"no_cursor_timeout\" , \"cursor_type\" , \"sort\" , \"allow_partial_results\" , \"batch_size\" , \"collation\" , \"return_key\" , \"show_record_id\" , \"hint\" , \"max_time_ms\" , \"min\" , \"max\" , \"comment\" , \"allow_disk_use\" , ) criteria = { key : kwargs [ key ] for key in valid_method_keys if key in kwargs } if criteria . get ( \"filter\" ) is None : # Ensure documents are included in the result set criteria [ \"filter\" ] = {} return criteria","title":"AsyncMongoCollection"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.__init__","text":"Initialize the AsyncMongoCollection for the given parameters. Parameters: Name Type Description Default name str The name of the collection. required resource_cls EntryResource The EntryResource model that is stored by the collection. required resource_mapper BaseResourceMapper A resource mapper object that handles aliases and format changes between deserialization and response. required Source code in optimade_gateway/mongo/collection.py 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 def __init__ ( self , name : str , resource_cls : \"EntryResource\" , resource_mapper : \"BaseResourceMapper\" , ): \"\"\"Initialize the AsyncMongoCollection for the given parameters. Parameters: name: The name of the collection. resource_cls: The `EntryResource` model that is stored by the collection. resource_mapper: A resource mapper object that handles aliases and format changes between deserialization and response. \"\"\" from optimade_gateway.mongo.database import ( # pylint: disable=import-outside-toplevel MONGO_DB , ) super () . __init__ ( resource_cls = resource_cls , resource_mapper = resource_mapper , transformer = MongoTransformer ( mapper = resource_mapper ), ) self . parser = LarkParser ( version = ( 1 , 0 , 0 ), variant = \"default\" ) self . collection : MongoCollection = MONGO_DB [ name ] # Check aliases do not clash with mongo operators self . _check_aliases ( self . resource_mapper . all_aliases ()) self . _check_aliases ( self . resource_mapper . all_length_aliases ())","title":"__init__()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.acount","text":"Count documents in Collection. This is the asynchronous version of the parent class method named count() . Parameters: Name Type Description Default params Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]] URL query parameters, either from a general entry endpoint or a single-entry endpoint. None **kwargs Any Query parameters as keyword arguments. Valid keys will be passed to the AsyncIOMotorCollection.count_documents method. {} Returns: Name Type Description int int The number of entries matching the query specified by the keyword arguments. Source code in optimade_gateway/mongo/collection.py 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 async def acount ( self , params : \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]]\" = None , ** kwargs : \"Any\" , ) -> int : \"\"\"Count documents in Collection. This is the asynchronous version of the parent class method named `count()`. Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. **kwargs: Query parameters as keyword arguments. Valid keys will be passed to the [`AsyncIOMotorCollection.count_documents`](https://motor.readthedocs.io/en/stable/api-asyncio/asyncio_motor_collection.html#motor.motor_asyncio.AsyncIOMotorCollection.count_documents) method. Returns: int: The number of entries matching the query specified by the keyword arguments. \"\"\" if params is not None and kwargs : raise ValueError ( \"When 'params' is supplied, no other parameters can be supplied.\" ) if params is not None : kwargs = await self . ahandle_query_params ( params ) valid_method_keys = ( \"filter\" , \"skip\" , \"limit\" , \"hint\" , \"maxTimeMS\" , \"collation\" , \"session\" , ) criteria = { key : kwargs [ key ] for key in valid_method_keys if key in kwargs } if criteria . get ( \"filter\" ) is None : criteria [ \"filter\" ] = {} return await self . collection . count_documents ( ** criteria )","title":"acount()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.afind","text":"Perform the query on the underlying MongoDB Collection, handling projection and pagination of the output. This is the asynchronous version of the parent class method named count() . Either provide params or criteria . Not both, but at least one. Parameters: Name Type Description Default params Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]] URL query parameters, either from a general entry endpoint or a single-entry endpoint. None criteria Optional[Dict[str, Any]] Already handled/parsed URL query parameters. None Returns: Type Description Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] A list of entry resource objects, how much data was returned for the query, Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] whether more data is available with pagination, and fields (excluded, Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] included). Source code in optimade_gateway/mongo/collection.py 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 async def afind ( self , params : \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]]\" = None , criteria : \"Optional[Dict[str, Any]]\" = None , ) -> \"Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]]\" : \"\"\"Perform the query on the underlying MongoDB Collection, handling projection and pagination of the output. This is the asynchronous version of the parent class method named `count()`. Either provide `params` or `criteria`. Not both, but at least one. Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. criteria: Already handled/parsed URL query parameters. Returns: A list of entry resource objects, how much data was returned for the query, whether more data is available with pagination, and fields (excluded, included). \"\"\" if ( params is None and criteria is None ) or ( params is not None and criteria is not None ): raise ValueError ( \"Exacly one of either `params` and `criteria` must be specified.\" ) # Set single_entry to False, this is done since if criteria is defined, # this is an unknown factor - better to then get a list of results. single_entry = False if criteria is None : criteria = await self . ahandle_query_params ( params ) else : single_entry = isinstance ( params , SingleEntryQueryParams ) response_fields = criteria . pop ( \"fields\" , self . all_fields ) results , data_returned , more_data_available = await self . _arun_db_query ( criteria = criteria , single_entry = single_entry , ) if single_entry : results = results [ 0 ] if results else None # type: ignore[assignment] if data_returned > 1 : raise NotFound ( detail = ( f \"Instead of a single entry, { data_returned } entries were found\" ), ) include_fields = ( response_fields - self . resource_mapper . TOP_LEVEL_NON_ATTRIBUTES_FIELDS ) bad_optimade_fields = set () bad_provider_fields = set () for field in include_fields : if field not in self . resource_mapper . ALL_ATTRIBUTES : if field . startswith ( \"_\" ): if any ( field . startswith ( f \"_ { prefix } _\" ) for prefix in self . resource_mapper . SUPPORTED_PREFIXES ): bad_provider_fields . add ( field ) else : bad_optimade_fields . add ( field ) if bad_provider_fields : warn ( UnknownProviderProperty ( detail = ( \"Unrecognised field(s) for this provider requested in \" f \"`response_fields`: { bad_provider_fields } .\" ) ) ) if bad_optimade_fields : raise BadRequest ( detail = ( \"Unrecognised OPTIMADE field(s) in requested `response_fields`: \" f \" { bad_optimade_fields } .\" ) ) if results : results = await self . resource_mapper . adeserialize ( results ) return ( # type: ignore[return-value] results , data_returned , more_data_available , self . all_fields - response_fields , include_fields , )","title":"afind()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.ahandle_query_params","text":"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. This is the asynchronous version of the parent class method named handle_query_params() . Note Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: Name Type Description Default params Union[EntryListingQueryParams, SingleEntryQueryParams] The initialized query parameter model from the server. required Raises: Type Description Forbidden If too large of a page limit is provided. BadRequest If an invalid request is made, e.g., with incorrect fields or response format. Returns: Type Description Dict[str, Any] A dictionary representation of the query parameters. Source code in optimade_gateway/mongo/collection.py 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 async def ahandle_query_params ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Dict[str, Any]\" : \"\"\"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. This is the asynchronous version of the parent class method named `handle_query_params()`. Note: Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: params: The initialized query parameter model from the server. Raises: Forbidden: If too large of a page limit is provided. BadRequest: If an invalid request is made, e.g., with incorrect fields or response format. Returns: A dictionary representation of the query parameters. \"\"\" return super () . handle_query_params ( params )","title":"ahandle_query_params()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.ainsert","text":"Add the given entries to the underlying database. This is the asynchronous version of the parent class method named insert() . Parameters: Name Type Description Default data List[EntryResource] The entry resource objects to add to the database. required Source code in optimade_gateway/mongo/collection.py 112 113 114 115 116 117 118 119 120 121 async def ainsert ( self , data : \"List[EntryResource]\" ) -> None : \"\"\"Add the given entries to the underlying database. This is the asynchronous version of the parent class method named `insert()`. Arguments: data: The entry resource objects to add to the database. \"\"\" await self . collection . insert_many ( await clean_python_types ( data ))","title":"ainsert()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.create_one","text":"Create a new document in the MongoDB collection based on query parameters. Update the newly created document with an \"id\" field. The value will be the string representation of the \"_id\" field. This will only be done if \"id\" is not already present in resource . Parameters: Name Type Description Default resource EntryResourceCreate The resource to be created. required Returns: Type Description EntryResource The newly created document as a pydantic model entry resource. Source code in optimade_gateway/mongo/collection.py 462 463 464 465 466 467 468 469 470 471 472 473 474 475 476 477 478 479 480 481 482 483 484 485 486 487 488 489 490 491 492 493 494 495 496 497 async def create_one ( self , resource : \"EntryResourceCreate\" ) -> \"EntryResource\" : \"\"\"Create a new document in the MongoDB collection based on query parameters. Update the newly created document with an `\"id\"` field. The value will be the string representation of the `\"_id\"` field. This will only be done if `\"id\"` is not already present in `resource`. Parameters: resource: The resource to be created. Returns: The newly created document as a pydantic model entry resource. \"\"\" resource . last_modified = datetime . utcnow () result = await self . collection . insert_one ( await clean_python_types ( resource . dict ( exclude_unset = True )) ) LOGGER . debug ( \"Inserted resource %r in DB collection %s with ID %s \" , resource , self . collection . name , result . inserted_id , ) if not resource . id : LOGGER . debug ( \"Updating resource with an `id` field equal to str(id_).\" ) await self . collection . update_one ( { \"_id\" : result . inserted_id }, { \"$set\" : { \"id\" : str ( result . inserted_id )}} ) return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ({ \"_id\" : result . inserted_id }) ) )","title":"create_one()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.exists","text":"Assert whether entry_id exists in the collection (value of \"id\" ) Parameters: Name Type Description Default entry_id str The \"id\" value of the entry. required Source code in optimade_gateway/mongo/collection.py 499 500 501 502 503 504 505 506 async def exists ( self , entry_id : str ) -> bool : \"\"\"Assert whether entry_id exists in the collection (value of `\"id\"`) Parameters: entry_id: The `\"id\"` value of the entry. \"\"\" return bool ( await self . collection . count_documents ({ \"id\" : entry_id }))","title":"exists()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.find","text":"Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of page_limit . See EntryListingQueryParams for more information. Parameters: Name Type Description Default params Union[EntryListingQueryParams, SingleEntryQueryParams] Entry listing URL query params. required Returns: Type Description Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] A tuple of various relevant values: Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] ( results , data_returned , more_data_available , exclude_fields , Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]] include_fields ). Source code in optimade_gateway/mongo/collection.py 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 def find ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Tuple[Union[List[EntryResource], EntryResource, None], int, bool, Set[str], Set[str]]\" : \"\"\" Fetches results and indicates if more data is available. Also gives the total number of data available in the absence of `page_limit`. See [`EntryListingQueryParams`](https://www.optimade.org/optimade-python-tools/api_reference/server/query_params/#optimade.server.query_params.EntryListingQueryParams) for more information. Parameters: params: Entry listing URL query params. Returns: A tuple of various relevant values: (`results`, `data_returned`, `more_data_available`, `exclude_fields`, `include_fields`). \"\"\" raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `afind(params: \" \"Optional[Union[EntryListingQueryParams, SingleEntryQueryParams]], criteria: \" \"Optional[Dict[str, Any]])`.\" )","title":"find()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.get_multiple","text":"Get a list of resources based on criteria Warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a list of resources. Parameters: Name Type Description Default **criteria Any Already handled/parsed URL query parameters. {} Returns: Type Description List[EntryResource] A list of resources from the MongoDB (mapped to pydantic models). Source code in optimade_gateway/mongo/collection.py 440 441 442 443 444 445 446 447 448 449 450 451 452 453 454 455 456 457 458 459 460 async def get_multiple ( self , ** criteria : \"Any\" ) -> \"List[EntryResource]\" : \"\"\"Get a list of resources based on criteria Warning: This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a list of resources. Parameters: **criteria: Already handled/parsed URL query parameters. Returns: A list of resources from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} results = [] async for document in self . collection . find ( ** self . _valid_find_keys ( ** criteria )): results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( document ))) return results","title":"get_multiple()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.get_one","text":"Get one resource based on criteria Warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a single resource. Parameters: Name Type Description Default **criteria Any Already handled/parsed URL query parameters. {} Returns: Type Description EntryResource A single resource from the MongoDB (mapped to pydantic models). Source code in optimade_gateway/mongo/collection.py 418 419 420 421 422 423 424 425 426 427 428 429 430 431 432 433 434 435 436 437 438 async def get_one ( self , ** criteria : \"Any\" ) -> \"EntryResource\" : \"\"\"Get one resource based on criteria Warning: This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a single resource. Parameters: **criteria: Already handled/parsed URL query parameters. Returns: A single resource from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ( ** self . _valid_find_keys ( ** criteria )) ) )","title":"get_one()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.handle_query_params","text":"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: Name Type Description Default params Union[EntryListingQueryParams, SingleEntryQueryParams] The initialized query parameter model from the server. required Raises: Type Description Forbidden If too large of a page limit is provided. BadRequest If an invalid request is made, e.g., with incorrect fields or response format. Returns: Type Description Dict[str, Any] A dictionary representation of the query parameters. Source code in optimade_gateway/mongo/collection.py 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 def handle_query_params ( self , params : \"Union[EntryListingQueryParams, SingleEntryQueryParams]\" ) -> \"Dict[str, Any]\" : \"\"\"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note: Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: params: The initialized query parameter model from the server. Raises: Forbidden: If too large of a page limit is provided. BadRequest: If an invalid request is made, e.g., with incorrect fields or response format. Returns: A dictionary representation of the query parameters. \"\"\" raise NotImplementedError ( \"This method cannot be used with this class and is a remnant from the parent \" \"class. Use instead the asynchronous method `ahandle_query_params(params: \" \"Union[EntryListingQueryParams, SingleEntryQueryParams])`.\" )","title":"handle_query_params()"},{"location":"api_reference/mongo/database/","text":"database \u00b6 Initialize the MongoDB database. MONGO_CLIENT : MongoClient = AsyncIOMotorClient ( CONFIG . mongo_uri , appname = 'optimade-gateway' , readConcernLevel = 'majority' , readPreference = 'primary' , w = 'majority' ) module-attribute \u00b6 The MongoDB motor client. MONGO_DB : Database = MONGO_CLIENT [ CONFIG . mongo_database ] module-attribute \u00b6 The MongoDB motor database. This is a representation of the database used for the gateway service.","title":"database"},{"location":"api_reference/mongo/database/#database","text":"Initialize the MongoDB database.","title":"database"},{"location":"api_reference/mongo/database/#optimade_gateway.mongo.database.MONGO_CLIENT","text":"The MongoDB motor client.","title":"MONGO_CLIENT"},{"location":"api_reference/mongo/database/#optimade_gateway.mongo.database.MONGO_DB","text":"The MongoDB motor database. This is a representation of the database used for the gateway service.","title":"MONGO_DB"},{"location":"api_reference/queries/params/","text":"params \u00b6 URL query parameters. SearchQueryParams \u00b6 URL query parameters for GET /search This is an extension of the EntryListingQueryParams class in `optimade\u00b4, which defines the standard entry listing endpoint query parameters. The extra query parameters are as follows. Attributes: Name Type Description database_ids Set [ str ] List of possible database IDs that are already known by the gateway. To be known they need to be registered with the gateway (currently not possible). optimade_urls Set [ AnyUrl ] A list of OPTIMADE base URLs. If a versioned base URL is supplied it will be used as is, as long as it represents a supported version. If an un-versioned base URL, standard version negotiation will be conducted to get the versioned base URL, which will be used as long as it represents a supported version. Example : http://example.org/optimade/v1/search?optimade_urls=\"https://example.org/optimade_db/v1\",\"https://optimade.herokuapp.com\" endpoint str The entry endpoint queried. According to the OPTIMADE specification, this is the same as the resource's type. Example : structures timeout int Timeout time (in seconds) to wait for a query to finish before redirecting ( after starting the query). Note, if the query has not finished after the timeout time, a redirection will still be performed, but to a zero-results page, which can be refreshed to get the finished query (once it has finished). as_optimade bool Return the response as a standard OPTIMADE entry listing endpoint response. Otherwise, the response will be based on the QueriesResponseSingle model. Source code in optimade_gateway/queries/params.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class SearchQueryParams : \"\"\"URL query parameters for `GET /search` This is an extension of the [`EntryListingQueryParams`](https://www.optimade.org/optimade-python-tools/api_reference/server/query_params/#optimade.server.query_params.EntryListingQueryParams) class in `optimade\u00b4, which defines the standard entry listing endpoint query parameters. The extra query parameters are as follows. Attributes: database_ids (Set[str]): List of possible database IDs that are already known by the gateway. To be known they need to be registered with the gateway (currently not possible). optimade_urls (Set[AnyUrl]): A list of OPTIMADE base URLs. If a versioned base URL is supplied it will be used as is, as long as it represents a supported version. If an un-versioned base URL, standard version negotiation will be conducted to get the versioned base URL, which will be used as long as it represents a supported version. **Example**: `http://example.org/optimade/v1/search?optimade_urls=\"https://example.org/optimade_db/v1\",\"https://optimade.herokuapp.com\"` endpoint (str): The entry endpoint queried. According to the OPTIMADE specification, this is the same as the resource's type. **Example**: `structures` timeout (int): Timeout time (in seconds) to wait for a query to finish before redirecting (*after* starting the query). Note, if the query has not finished after the timeout time, a redirection will still be performed, but to a zero-results page, which can be refreshed to get the finished query (once it has finished). as_optimade (bool): Return the response as a standard OPTIMADE entry listing endpoint response. Otherwise, the response will be based on the [`QueriesResponseSingle`][optimade_gateway.models.responses.QueriesResponseSingle] model. \"\"\" def __init__ ( self , * , database_ids : Set [ str ] = Query ( set (), description = ( \"Unique list of possible database IDs that are already known by the \" \"gateway. To be known they need to be registered with the gateway \" \"(currently not possible).\" ), ), optimade_urls : Set [ AnyUrl ] = Query ( set (), description = ( \"A unique list of OPTIMADE base URLs. If a versioned base URL is \" \"supplied it will be used as is, as long as it represents a supported \" \"version. If an un-versioned base URL, standard version negotiation will\" \" be conducted to get the versioned base URL, which will be used as long\" \" as it represents a supported version.\" ), ), endpoint : str = Query ( \"structures\" , description = ( \"The entry endpoint queried. According to the OPTIMADE specification, \" \"this is the same as the resource's type.\" ), ), timeout : int = Query ( 15 , description = ( \"Timeout time (in seconds) to wait for a query to finish before \" \"redirecting (*after* starting the query). Note, if the query has not \" \"finished after the timeout time, a redirection will still be performed,\" \" but to a zero-results page, which can be refreshed to get the finished\" \" query (once it has finished).\" ), ), as_optimade : bool = Query ( False , description = ( \"Return the response as a standard OPTIMADE entry listing endpoint \" \"response. Otherwise, the response will be based on the \" \"[`QueriesResponseSingle`][optimade_gateway.models.responses.QueriesResponseSingle]\" \" model.\" ), ) ) -> None : self . database_ids = database_ids self . optimade_urls = optimade_urls self . endpoint = endpoint self . timeout = timeout self . as_optimade = as_optimade","title":"params"},{"location":"api_reference/queries/params/#params","text":"URL query parameters.","title":"params"},{"location":"api_reference/queries/params/#optimade_gateway.queries.params.SearchQueryParams","text":"URL query parameters for GET /search This is an extension of the EntryListingQueryParams class in `optimade\u00b4, which defines the standard entry listing endpoint query parameters. The extra query parameters are as follows. Attributes: Name Type Description database_ids Set [ str ] List of possible database IDs that are already known by the gateway. To be known they need to be registered with the gateway (currently not possible). optimade_urls Set [ AnyUrl ] A list of OPTIMADE base URLs. If a versioned base URL is supplied it will be used as is, as long as it represents a supported version. If an un-versioned base URL, standard version negotiation will be conducted to get the versioned base URL, which will be used as long as it represents a supported version. Example : http://example.org/optimade/v1/search?optimade_urls=\"https://example.org/optimade_db/v1\",\"https://optimade.herokuapp.com\" endpoint str The entry endpoint queried. According to the OPTIMADE specification, this is the same as the resource's type. Example : structures timeout int Timeout time (in seconds) to wait for a query to finish before redirecting ( after starting the query). Note, if the query has not finished after the timeout time, a redirection will still be performed, but to a zero-results page, which can be refreshed to get the finished query (once it has finished). as_optimade bool Return the response as a standard OPTIMADE entry listing endpoint response. Otherwise, the response will be based on the QueriesResponseSingle model. Source code in optimade_gateway/queries/params.py 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 class SearchQueryParams : \"\"\"URL query parameters for `GET /search` This is an extension of the [`EntryListingQueryParams`](https://www.optimade.org/optimade-python-tools/api_reference/server/query_params/#optimade.server.query_params.EntryListingQueryParams) class in `optimade\u00b4, which defines the standard entry listing endpoint query parameters. The extra query parameters are as follows. Attributes: database_ids (Set[str]): List of possible database IDs that are already known by the gateway. To be known they need to be registered with the gateway (currently not possible). optimade_urls (Set[AnyUrl]): A list of OPTIMADE base URLs. If a versioned base URL is supplied it will be used as is, as long as it represents a supported version. If an un-versioned base URL, standard version negotiation will be conducted to get the versioned base URL, which will be used as long as it represents a supported version. **Example**: `http://example.org/optimade/v1/search?optimade_urls=\"https://example.org/optimade_db/v1\",\"https://optimade.herokuapp.com\"` endpoint (str): The entry endpoint queried. According to the OPTIMADE specification, this is the same as the resource's type. **Example**: `structures` timeout (int): Timeout time (in seconds) to wait for a query to finish before redirecting (*after* starting the query). Note, if the query has not finished after the timeout time, a redirection will still be performed, but to a zero-results page, which can be refreshed to get the finished query (once it has finished). as_optimade (bool): Return the response as a standard OPTIMADE entry listing endpoint response. Otherwise, the response will be based on the [`QueriesResponseSingle`][optimade_gateway.models.responses.QueriesResponseSingle] model. \"\"\" def __init__ ( self , * , database_ids : Set [ str ] = Query ( set (), description = ( \"Unique list of possible database IDs that are already known by the \" \"gateway. To be known they need to be registered with the gateway \" \"(currently not possible).\" ), ), optimade_urls : Set [ AnyUrl ] = Query ( set (), description = ( \"A unique list of OPTIMADE base URLs. If a versioned base URL is \" \"supplied it will be used as is, as long as it represents a supported \" \"version. If an un-versioned base URL, standard version negotiation will\" \" be conducted to get the versioned base URL, which will be used as long\" \" as it represents a supported version.\" ), ), endpoint : str = Query ( \"structures\" , description = ( \"The entry endpoint queried. According to the OPTIMADE specification, \" \"this is the same as the resource's type.\" ), ), timeout : int = Query ( 15 , description = ( \"Timeout time (in seconds) to wait for a query to finish before \" \"redirecting (*after* starting the query). Note, if the query has not \" \"finished after the timeout time, a redirection will still be performed,\" \" but to a zero-results page, which can be refreshed to get the finished\" \" query (once it has finished).\" ), ), as_optimade : bool = Query ( False , description = ( \"Return the response as a standard OPTIMADE entry listing endpoint \" \"response. Otherwise, the response will be based on the \" \"[`QueriesResponseSingle`][optimade_gateway.models.responses.QueriesResponseSingle]\" \" model.\" ), ) ) -> None : self . database_ids = database_ids self . optimade_urls = optimade_urls self . endpoint = endpoint self . timeout = timeout self . as_optimade = as_optimade","title":"SearchQueryParams"},{"location":"api_reference/queries/perform/","text":"perform \u00b6 Perform OPTIMADE queries db_find ( database , endpoint , response_model , query_params = '' , raw_url = None ) \u00b6 Imitate Collection.find() for any given database for entry-resource endpoints Parameters: Name Type Description Default database Union[LinksResource, Dict[str, Any]] The OPTIMADE implementation to be queried. It must have a valid base URL and id. required endpoint str The entry-listing endpoint, e.g., \"structures\" . required response_model Union[EntryResponseMany, EntryResponseOne] The expected OPTIMADE pydantic response model, e.g., optimade.models.StructureResponseMany . required query_params str URL query parameters to pass to the database. '' raw_url Optional[str] A raw URL to use straight up instead of deriving a URL from database , endpoint , and query_params . None Returns: Type Description Tuple[Union[ErrorResponse, EntryResponseMany, EntryResponseOne], str] Response as an optimade pydantic model and the database 's ID. Source code in optimade_gateway/queries/perform.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 def db_find ( database : \"Union[LinksResource, Dict[str, Any]]\" , endpoint : str , response_model : \"Union[EntryResponseMany, EntryResponseOne]\" , query_params : str = \"\" , raw_url : \"Optional[str]\" = None , ) -> \"Tuple[Union[ErrorResponse, EntryResponseMany, EntryResponseOne], str]\" : \"\"\"Imitate `Collection.find()` for any given database for entry-resource endpoints Parameters: database: The OPTIMADE implementation to be queried. It **must** have a valid base URL and id. endpoint: The entry-listing endpoint, e.g., `\"structures\"`. response_model: The expected OPTIMADE pydantic response model, e.g., `optimade.models.StructureResponseMany`. query_params: URL query parameters to pass to the database. raw_url: A raw URL to use straight up instead of deriving a URL from `database`, `endpoint`, and `query_params`. Returns: Response as an `optimade` pydantic model and the `database`'s ID. \"\"\" if TYPE_CHECKING or bool ( os . getenv ( \"MKDOCS_BUILD\" , \"\" )): # pragma: no cover response : \"Union[httpx.Response, Dict[str, Any], EntryResponseMany, EntryResponseOne, ErrorResponse]\" # pylint: disable=line-too-long if raw_url : url = raw_url else : url = ( f \" { str ( get_resource_attribute ( database , 'attributes.base_url' )) . strip ( '/' ) } \" f \" { BASE_URL_PREFIXES [ 'major' ] } / { endpoint . strip ( '/' ) } ? { query_params } \" ) response = httpx . get ( url , timeout = 60 ) try : response = response . json () except json . JSONDecodeError : return ( ErrorResponse ( errors = [ { \"detail\" : f \"Could not JSONify response from { url } \" , \"id\" : \"OPTIMADE_GATEWAY_DB_FIND_MANY_JSONDECODEERROR\" , } ], meta = { \"query\" : { \"representation\" : f \"/ { endpoint . strip ( '/' ) } ? { query_params } \" }, \"api_version\" : __api_version__ , \"more_data_available\" : False , }, ), get_resource_attribute ( database , \"id\" ), ) try : response = response_model ( ** response ) except ValidationError : try : response = ErrorResponse ( ** response ) except ValidationError as exc : # If it's an error and `meta` is missing, it is not a valid OPTIMADE response, # but this happens a lot, and is therefore worth having an edge-case for. if \"errors\" in response : errors = list ( response [ \"errors\" ]) errors . append ( { \"detail\" : ( f \"Could not pass response from { url } as either a \" f \" { response_model . __name__ !r} or 'ErrorResponse'. \" f \"ValidationError: { exc } \" ), \"id\" : \"OPTIMADE_GATEWAY_DB_FINDS_MANY_VALIDATIONERRORS\" , } ) return ( ErrorResponse ( errors = errors , meta = { \"query\" : { \"representation\" : f \"/ { endpoint . strip ( '/' ) } ? { query_params } \" }, \"api_version\" : __api_version__ , \"more_data_available\" : False , }, ), get_resource_attribute ( database , \"id\" ), ) return ( ErrorResponse ( errors = [ { \"detail\" : ( f \"Could not pass response from { url } as either a \" f \" { response_model . __name__ !r} or 'ErrorResponse'. \" f \"ValidationError: { exc } \" ), \"id\" : \"OPTIMADE_GATEWAY_DB_FINDS_MANY_VALIDATIONERRORS\" , } ], meta = { \"query\" : { \"representation\" : f \"/ { endpoint . strip ( '/' ) } ? { query_params } \" }, \"api_version\" : __api_version__ , \"more_data_available\" : False , }, ), get_resource_attribute ( database , \"id\" ), ) return response , get_resource_attribute ( database , \"id\" ) db_get_all_resources ( database , endpoint , response_model , query_params = '' , raw_url = None ) async \u00b6 Recursively retrieve all resources from an entry-listing endpoint This function keeps pulling the links.next link if meta.more_data_available is True to ultimately retrieve all entries for endpoint . Warning This function can be dangerous if an endpoint with hundreds or thousands of entries is requested. Parameters: Name Type Description Default database Union[LinksResource, Dict[str, Any]] The OPTIMADE implementation to be queried. It must have a valid base URL and id. required endpoint str The entry-listing endpoint, e.g., \"structures\" . required response_model EntryResponseMany The expected OPTIMADE pydantic response model, e.g., optimade.models.StructureResponseMany . required query_params str URL query parameters to pass to the database. '' raw_url Optional[str] A raw URL to use straight up instead of deriving a URL from database , endpoint , and query_params . None Returns: Type Description Tuple[List[Union[EntryResource, Dict[str, Any]]], Union[LinksResource, Dict[str, Any]]] A collected list of successful responses' data value and the database 's ID. Source code in optimade_gateway/queries/perform.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 async def db_get_all_resources ( database : \"Union[LinksResource, Dict[str, Any]]\" , endpoint : str , response_model : \"EntryResponseMany\" , query_params : str = \"\" , raw_url : \"Optional[str]\" = None , ) -> \"Tuple[List[Union[EntryResource, Dict[str, Any]]], Union[LinksResource, Dict[str, Any]]]\" : # pylint: disable=line-too-long \"\"\"Recursively retrieve all resources from an entry-listing endpoint This function keeps pulling the `links.next` link if `meta.more_data_available` is `True` to ultimately retrieve *all* entries for `endpoint`. !!! warning This function can be dangerous if an endpoint with hundreds or thousands of entries is requested. Parameters: database: The OPTIMADE implementation to be queried. It **must** have a valid base URL and id. endpoint: The entry-listing endpoint, e.g., `\"structures\"`. response_model: The expected OPTIMADE pydantic response model, e.g., `optimade.models.StructureResponseMany`. query_params: URL query parameters to pass to the database. raw_url: A raw URL to use straight up instead of deriving a URL from `database`, `endpoint`, and `query_params`. Returns: A collected list of successful responses' `data` value and the `database`'s ID. \"\"\" resulting_resources = [] response , _ = db_find ( database = database , endpoint = endpoint , response_model = response_model , query_params = query_params , raw_url = raw_url , ) if isinstance ( response , ErrorResponse ): # An errored response will result in no databases from a provider. LOGGER . error ( \"Error while querying database (id= %r ). Full response: %s \" , get_resource_attribute ( database , \"id\" ), response . json ( indent = 2 ), ) return [], database resulting_resources . extend ( response . data ) if response . meta . more_data_available : next_page = get_resource_attribute ( response , \"links.next\" ) if next_page is None : LOGGER . error ( \"Could not find a 'next' link for an OPTIMADE query request to %r \" \"(id= %r ). Cannot get all resources from / %s , even though this was asked \" \"and `more_data_available` is `True` in the response.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), endpoint , ) return resulting_resources , database more_resources , _ = await db_get_all_resources ( database = database , endpoint = endpoint , response_model = response_model , query_params = query_params , raw_url = next_page , ) resulting_resources . extend ( more_resources ) return resulting_resources , database perform_query ( url , query ) async \u00b6 Perform OPTIMADE query with gateway. Parameters: Name Type Description Default url URL Original request URL. required query QueryResource The query to be performed. required Returns: Type Description Union[EntryResponseMany, ErrorResponse, GatewayQueryResponse] This function returns the final response; a Union[EntryResponseMany, ErrorResponse, GatewayQueryResponse] GatewayQueryResponse . Source code in optimade_gateway/queries/perform.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 async def perform_query ( url : \"URL\" , query : \"QueryResource\" , ) -> \"Union[EntryResponseMany, ErrorResponse, GatewayQueryResponse]\" : \"\"\"Perform OPTIMADE query with gateway. Parameters: url: Original request URL. query: The query to be performed. Returns: This function returns the final response; a [`GatewayQueryResponse`][optimade_gateway.models.queries.GatewayQueryResponse]. \"\"\" await update_query ( query , \"state\" , QueryState . STARTED ) gateway : GatewayResource = await get_valid_resource ( await collection_factory ( CONFIG . gateways_collection ), query . attributes . gateway_id , ) filter_queries = await prepare_query_filter ( database_ids = [ _ . id for _ in gateway . attributes . databases ], filter_query = query . attributes . query_parameters . filter , ) url = url . replace ( path = f \" { url . path . rstrip ( '/' ) } / { query . id } \" ) await update_query ( query , \"response\" , GatewayQueryResponse ( data = {}, links = ToplevelLinks ( next = None ), meta = meta_values ( url = url , data_available = 0 , data_returned = 0 , more_data_available = False , schema = CONFIG . schema_url , ), ), operator = None , ** { \"$set\" : { \"state\" : QueryState . IN_PROGRESS }}, ) loop = asyncio . get_running_loop () with ThreadPoolExecutor ( max_workers = min ( 32 , ( os . cpu_count () or 0 ) + 4 , len ( gateway . attributes . databases ) ) ) as executor : # Run OPTIMADE DB queries in a thread pool, i.e., not using the main OS thread, # where the asyncio event loop is running. query_tasks = [] for database in gateway . attributes . databases : query_params = await get_query_params ( query_parameters = query . attributes . query_parameters , database_id = database . id , filter_mapping = filter_queries , ) query_tasks . append ( loop . run_in_executor ( executor = executor , func = functools . partial ( db_find , database = database , endpoint = query . attributes . endpoint . value , response_model = query . attributes . endpoint . get_response_model (), query_params = query_params , ), ) ) for query_task in query_tasks : ( db_response , db_id ) = await query_task await process_db_response ( response = db_response , database_id = db_id , query = query , gateway = gateway , ) # Pagination # # if isinstance(results, list) and get_resource_attribute( # query, # \"attributes.response.meta.more_data_available\", # False, # disambiguate=False, # Extremely minor speed-up # ): # # Deduce the `next` link from the current request # query_string = urllib.parse.parse_qs(url.query) # query_string[\"page_offset\"] = [ # int(query_string.get(\"page_offset\", [0])[0]) # type: ignore[list-item] # + len(results[: query.attributes.query_parameters.page_limit]) # ] # urlencoded = urllib.parse.urlencode(query_string, doseq=True) # base_url = get_base_url(url) # links = ToplevelLinks(next=f\"{base_url}{url.path}?{urlencoded}\") # await update_query(query, \"response.links\", links) await update_query ( query , \"state\" , QueryState . FINISHED ) return query . attributes . response","title":"perform"},{"location":"api_reference/queries/perform/#perform","text":"Perform OPTIMADE queries","title":"perform"},{"location":"api_reference/queries/perform/#optimade_gateway.queries.perform.db_find","text":"Imitate Collection.find() for any given database for entry-resource endpoints Parameters: Name Type Description Default database Union[LinksResource, Dict[str, Any]] The OPTIMADE implementation to be queried. It must have a valid base URL and id. required endpoint str The entry-listing endpoint, e.g., \"structures\" . required response_model Union[EntryResponseMany, EntryResponseOne] The expected OPTIMADE pydantic response model, e.g., optimade.models.StructureResponseMany . required query_params str URL query parameters to pass to the database. '' raw_url Optional[str] A raw URL to use straight up instead of deriving a URL from database , endpoint , and query_params . None Returns: Type Description Tuple[Union[ErrorResponse, EntryResponseMany, EntryResponseOne], str] Response as an optimade pydantic model and the database 's ID. Source code in optimade_gateway/queries/perform.py 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 def db_find ( database : \"Union[LinksResource, Dict[str, Any]]\" , endpoint : str , response_model : \"Union[EntryResponseMany, EntryResponseOne]\" , query_params : str = \"\" , raw_url : \"Optional[str]\" = None , ) -> \"Tuple[Union[ErrorResponse, EntryResponseMany, EntryResponseOne], str]\" : \"\"\"Imitate `Collection.find()` for any given database for entry-resource endpoints Parameters: database: The OPTIMADE implementation to be queried. It **must** have a valid base URL and id. endpoint: The entry-listing endpoint, e.g., `\"structures\"`. response_model: The expected OPTIMADE pydantic response model, e.g., `optimade.models.StructureResponseMany`. query_params: URL query parameters to pass to the database. raw_url: A raw URL to use straight up instead of deriving a URL from `database`, `endpoint`, and `query_params`. Returns: Response as an `optimade` pydantic model and the `database`'s ID. \"\"\" if TYPE_CHECKING or bool ( os . getenv ( \"MKDOCS_BUILD\" , \"\" )): # pragma: no cover response : \"Union[httpx.Response, Dict[str, Any], EntryResponseMany, EntryResponseOne, ErrorResponse]\" # pylint: disable=line-too-long if raw_url : url = raw_url else : url = ( f \" { str ( get_resource_attribute ( database , 'attributes.base_url' )) . strip ( '/' ) } \" f \" { BASE_URL_PREFIXES [ 'major' ] } / { endpoint . strip ( '/' ) } ? { query_params } \" ) response = httpx . get ( url , timeout = 60 ) try : response = response . json () except json . JSONDecodeError : return ( ErrorResponse ( errors = [ { \"detail\" : f \"Could not JSONify response from { url } \" , \"id\" : \"OPTIMADE_GATEWAY_DB_FIND_MANY_JSONDECODEERROR\" , } ], meta = { \"query\" : { \"representation\" : f \"/ { endpoint . strip ( '/' ) } ? { query_params } \" }, \"api_version\" : __api_version__ , \"more_data_available\" : False , }, ), get_resource_attribute ( database , \"id\" ), ) try : response = response_model ( ** response ) except ValidationError : try : response = ErrorResponse ( ** response ) except ValidationError as exc : # If it's an error and `meta` is missing, it is not a valid OPTIMADE response, # but this happens a lot, and is therefore worth having an edge-case for. if \"errors\" in response : errors = list ( response [ \"errors\" ]) errors . append ( { \"detail\" : ( f \"Could not pass response from { url } as either a \" f \" { response_model . __name__ !r} or 'ErrorResponse'. \" f \"ValidationError: { exc } \" ), \"id\" : \"OPTIMADE_GATEWAY_DB_FINDS_MANY_VALIDATIONERRORS\" , } ) return ( ErrorResponse ( errors = errors , meta = { \"query\" : { \"representation\" : f \"/ { endpoint . strip ( '/' ) } ? { query_params } \" }, \"api_version\" : __api_version__ , \"more_data_available\" : False , }, ), get_resource_attribute ( database , \"id\" ), ) return ( ErrorResponse ( errors = [ { \"detail\" : ( f \"Could not pass response from { url } as either a \" f \" { response_model . __name__ !r} or 'ErrorResponse'. \" f \"ValidationError: { exc } \" ), \"id\" : \"OPTIMADE_GATEWAY_DB_FINDS_MANY_VALIDATIONERRORS\" , } ], meta = { \"query\" : { \"representation\" : f \"/ { endpoint . strip ( '/' ) } ? { query_params } \" }, \"api_version\" : __api_version__ , \"more_data_available\" : False , }, ), get_resource_attribute ( database , \"id\" ), ) return response , get_resource_attribute ( database , \"id\" )","title":"db_find()"},{"location":"api_reference/queries/perform/#optimade_gateway.queries.perform.db_get_all_resources","text":"Recursively retrieve all resources from an entry-listing endpoint This function keeps pulling the links.next link if meta.more_data_available is True to ultimately retrieve all entries for endpoint . Warning This function can be dangerous if an endpoint with hundreds or thousands of entries is requested. Parameters: Name Type Description Default database Union[LinksResource, Dict[str, Any]] The OPTIMADE implementation to be queried. It must have a valid base URL and id. required endpoint str The entry-listing endpoint, e.g., \"structures\" . required response_model EntryResponseMany The expected OPTIMADE pydantic response model, e.g., optimade.models.StructureResponseMany . required query_params str URL query parameters to pass to the database. '' raw_url Optional[str] A raw URL to use straight up instead of deriving a URL from database , endpoint , and query_params . None Returns: Type Description Tuple[List[Union[EntryResource, Dict[str, Any]]], Union[LinksResource, Dict[str, Any]]] A collected list of successful responses' data value and the database 's ID. Source code in optimade_gateway/queries/perform.py 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 async def db_get_all_resources ( database : \"Union[LinksResource, Dict[str, Any]]\" , endpoint : str , response_model : \"EntryResponseMany\" , query_params : str = \"\" , raw_url : \"Optional[str]\" = None , ) -> \"Tuple[List[Union[EntryResource, Dict[str, Any]]], Union[LinksResource, Dict[str, Any]]]\" : # pylint: disable=line-too-long \"\"\"Recursively retrieve all resources from an entry-listing endpoint This function keeps pulling the `links.next` link if `meta.more_data_available` is `True` to ultimately retrieve *all* entries for `endpoint`. !!! warning This function can be dangerous if an endpoint with hundreds or thousands of entries is requested. Parameters: database: The OPTIMADE implementation to be queried. It **must** have a valid base URL and id. endpoint: The entry-listing endpoint, e.g., `\"structures\"`. response_model: The expected OPTIMADE pydantic response model, e.g., `optimade.models.StructureResponseMany`. query_params: URL query parameters to pass to the database. raw_url: A raw URL to use straight up instead of deriving a URL from `database`, `endpoint`, and `query_params`. Returns: A collected list of successful responses' `data` value and the `database`'s ID. \"\"\" resulting_resources = [] response , _ = db_find ( database = database , endpoint = endpoint , response_model = response_model , query_params = query_params , raw_url = raw_url , ) if isinstance ( response , ErrorResponse ): # An errored response will result in no databases from a provider. LOGGER . error ( \"Error while querying database (id= %r ). Full response: %s \" , get_resource_attribute ( database , \"id\" ), response . json ( indent = 2 ), ) return [], database resulting_resources . extend ( response . data ) if response . meta . more_data_available : next_page = get_resource_attribute ( response , \"links.next\" ) if next_page is None : LOGGER . error ( \"Could not find a 'next' link for an OPTIMADE query request to %r \" \"(id= %r ). Cannot get all resources from / %s , even though this was asked \" \"and `more_data_available` is `True` in the response.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), endpoint , ) return resulting_resources , database more_resources , _ = await db_get_all_resources ( database = database , endpoint = endpoint , response_model = response_model , query_params = query_params , raw_url = next_page , ) resulting_resources . extend ( more_resources ) return resulting_resources , database","title":"db_get_all_resources()"},{"location":"api_reference/queries/perform/#optimade_gateway.queries.perform.perform_query","text":"Perform OPTIMADE query with gateway. Parameters: Name Type Description Default url URL Original request URL. required query QueryResource The query to be performed. required Returns: Type Description Union[EntryResponseMany, ErrorResponse, GatewayQueryResponse] This function returns the final response; a Union[EntryResponseMany, ErrorResponse, GatewayQueryResponse] GatewayQueryResponse . Source code in optimade_gateway/queries/perform.py 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 async def perform_query ( url : \"URL\" , query : \"QueryResource\" , ) -> \"Union[EntryResponseMany, ErrorResponse, GatewayQueryResponse]\" : \"\"\"Perform OPTIMADE query with gateway. Parameters: url: Original request URL. query: The query to be performed. Returns: This function returns the final response; a [`GatewayQueryResponse`][optimade_gateway.models.queries.GatewayQueryResponse]. \"\"\" await update_query ( query , \"state\" , QueryState . STARTED ) gateway : GatewayResource = await get_valid_resource ( await collection_factory ( CONFIG . gateways_collection ), query . attributes . gateway_id , ) filter_queries = await prepare_query_filter ( database_ids = [ _ . id for _ in gateway . attributes . databases ], filter_query = query . attributes . query_parameters . filter , ) url = url . replace ( path = f \" { url . path . rstrip ( '/' ) } / { query . id } \" ) await update_query ( query , \"response\" , GatewayQueryResponse ( data = {}, links = ToplevelLinks ( next = None ), meta = meta_values ( url = url , data_available = 0 , data_returned = 0 , more_data_available = False , schema = CONFIG . schema_url , ), ), operator = None , ** { \"$set\" : { \"state\" : QueryState . IN_PROGRESS }}, ) loop = asyncio . get_running_loop () with ThreadPoolExecutor ( max_workers = min ( 32 , ( os . cpu_count () or 0 ) + 4 , len ( gateway . attributes . databases ) ) ) as executor : # Run OPTIMADE DB queries in a thread pool, i.e., not using the main OS thread, # where the asyncio event loop is running. query_tasks = [] for database in gateway . attributes . databases : query_params = await get_query_params ( query_parameters = query . attributes . query_parameters , database_id = database . id , filter_mapping = filter_queries , ) query_tasks . append ( loop . run_in_executor ( executor = executor , func = functools . partial ( db_find , database = database , endpoint = query . attributes . endpoint . value , response_model = query . attributes . endpoint . get_response_model (), query_params = query_params , ), ) ) for query_task in query_tasks : ( db_response , db_id ) = await query_task await process_db_response ( response = db_response , database_id = db_id , query = query , gateway = gateway , ) # Pagination # # if isinstance(results, list) and get_resource_attribute( # query, # \"attributes.response.meta.more_data_available\", # False, # disambiguate=False, # Extremely minor speed-up # ): # # Deduce the `next` link from the current request # query_string = urllib.parse.parse_qs(url.query) # query_string[\"page_offset\"] = [ # int(query_string.get(\"page_offset\", [0])[0]) # type: ignore[list-item] # + len(results[: query.attributes.query_parameters.page_limit]) # ] # urlencoded = urllib.parse.urlencode(query_string, doseq=True) # base_url = get_base_url(url) # links = ToplevelLinks(next=f\"{base_url}{url.path}?{urlencoded}\") # await update_query(query, \"response.links\", links) await update_query ( query , \"state\" , QueryState . FINISHED ) return query . attributes . response","title":"perform_query()"},{"location":"api_reference/queries/prepare/","text":"prepare \u00b6 Prepare OPTIMADE queries. get_query_params ( query_parameters , database_id , filter_mapping ) async \u00b6 Construct the parsed URL query parameters Source code in optimade_gateway/queries/prepare.py 73 74 75 76 77 78 79 80 81 82 83 84 async def get_query_params ( query_parameters : \"OptimadeQueryParameters\" , database_id : str , filter_mapping : \"Mapping[str, Union[str, None]]\" , ) -> str : \"\"\"Construct the parsed URL query parameters\"\"\" query_params = { param : value for param , value in query_parameters . dict () . items () if value } if filter_mapping [ database_id ]: query_params . update ({ \"filter\" : filter_mapping [ database_id ]}) return urllib . parse . urlencode ( query_params ) prepare_query_filter ( database_ids , filter_query ) async \u00b6 Update the query parameter filter value to be database-specific This is needed due to the served change of id values. If someone searches for a gateway-changed id , it needs to be reverted to be database-specific. Parameters: Name Type Description Default database_ids List[str] List of the databases to create updated filter values for. These values are part of the gateway-changed id values and are essential. required filter_query Union[str, None] The submitted filter query parameter value. Can be None if not supplied. required Returns: Type Description Mapping[str, Union[str, None]] A mapping for database IDs to database-specific filter query parameter values. Source code in optimade_gateway/queries/prepare.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 async def prepare_query_filter ( database_ids : \"List[str]\" , filter_query : \"Union[str, None]\" ) -> \"Mapping[str, Union[str, None]]\" : \"\"\"Update the query parameter `filter` value to be database-specific This is needed due to the served change of `id` values. If someone searches for a gateway-changed `id`, it needs to be reverted to be database-specific. Parameters: database_ids: List of the databases to create updated filter values for. These values are part of the gateway-changed `id` values and are essential. filter_query: The submitted `filter` query parameter value. Can be `None` if not supplied. Returns: A mapping for database IDs to database-specific `filter` query parameter values. \"\"\" updated_filter = {} . fromkeys ( database_ids , filter_query ) if not filter_query : return updated_filter for id_match in re . finditer ( r '\"(?P<id_value_l>[^\\s]*)\"[\\s]*' r \"(<|>|<=|>=|=|!=|CONTAINS|STARTS WITH|ENDS WITH|STARTS|ENDS)\" r \"[\\s]*id|[^_]+id[\\s]*\" r '(<|>|<=|>=|=|!=|CONTAINS|STARTS WITH|ENDS WITH|STARTS|ENDS)[\\s]*\"' r '(?P<id_value_r>[^\\s]*)\"' , f \"= { filter_query } \" if filter_query else \"\" , ): matched_id = id_match . group ( \"id_value_l\" ) or id_match . group ( \"id_value_r\" ) for database_id in database_ids : if matched_id . startswith ( f \" { database_id } /\" ): # Database found updated_filter [ database_id ] = updated_filter [ database_id ] . replace ( # type: ignore[union-attr] # pylint: disable=line-too-long f \" { database_id } /\" , \"\" , 1 ) break else : warn ( OptimadeGatewayWarning ( title = \"Non-Unique Entry ID\" , detail = ( f \"The passed entry ID <id= { matched_id } > may be ambiguous! To get\" \" a specific structures entry, one can prepend the ID with a \" \"database ID belonging to the gateway, followed by a forward \" f \"slash, e.g., ' { database_ids [ 0 ] } /<local_database_ID>'. \" f \"Available databases for this gateway: { database_ids } \" ), ) ) return updated_filter # type: ignore[return-value]","title":"prepare"},{"location":"api_reference/queries/prepare/#prepare","text":"Prepare OPTIMADE queries.","title":"prepare"},{"location":"api_reference/queries/prepare/#optimade_gateway.queries.prepare.get_query_params","text":"Construct the parsed URL query parameters Source code in optimade_gateway/queries/prepare.py 73 74 75 76 77 78 79 80 81 82 83 84 async def get_query_params ( query_parameters : \"OptimadeQueryParameters\" , database_id : str , filter_mapping : \"Mapping[str, Union[str, None]]\" , ) -> str : \"\"\"Construct the parsed URL query parameters\"\"\" query_params = { param : value for param , value in query_parameters . dict () . items () if value } if filter_mapping [ database_id ]: query_params . update ({ \"filter\" : filter_mapping [ database_id ]}) return urllib . parse . urlencode ( query_params )","title":"get_query_params()"},{"location":"api_reference/queries/prepare/#optimade_gateway.queries.prepare.prepare_query_filter","text":"Update the query parameter filter value to be database-specific This is needed due to the served change of id values. If someone searches for a gateway-changed id , it needs to be reverted to be database-specific. Parameters: Name Type Description Default database_ids List[str] List of the databases to create updated filter values for. These values are part of the gateway-changed id values and are essential. required filter_query Union[str, None] The submitted filter query parameter value. Can be None if not supplied. required Returns: Type Description Mapping[str, Union[str, None]] A mapping for database IDs to database-specific filter query parameter values. Source code in optimade_gateway/queries/prepare.py 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 async def prepare_query_filter ( database_ids : \"List[str]\" , filter_query : \"Union[str, None]\" ) -> \"Mapping[str, Union[str, None]]\" : \"\"\"Update the query parameter `filter` value to be database-specific This is needed due to the served change of `id` values. If someone searches for a gateway-changed `id`, it needs to be reverted to be database-specific. Parameters: database_ids: List of the databases to create updated filter values for. These values are part of the gateway-changed `id` values and are essential. filter_query: The submitted `filter` query parameter value. Can be `None` if not supplied. Returns: A mapping for database IDs to database-specific `filter` query parameter values. \"\"\" updated_filter = {} . fromkeys ( database_ids , filter_query ) if not filter_query : return updated_filter for id_match in re . finditer ( r '\"(?P<id_value_l>[^\\s]*)\"[\\s]*' r \"(<|>|<=|>=|=|!=|CONTAINS|STARTS WITH|ENDS WITH|STARTS|ENDS)\" r \"[\\s]*id|[^_]+id[\\s]*\" r '(<|>|<=|>=|=|!=|CONTAINS|STARTS WITH|ENDS WITH|STARTS|ENDS)[\\s]*\"' r '(?P<id_value_r>[^\\s]*)\"' , f \"= { filter_query } \" if filter_query else \"\" , ): matched_id = id_match . group ( \"id_value_l\" ) or id_match . group ( \"id_value_r\" ) for database_id in database_ids : if matched_id . startswith ( f \" { database_id } /\" ): # Database found updated_filter [ database_id ] = updated_filter [ database_id ] . replace ( # type: ignore[union-attr] # pylint: disable=line-too-long f \" { database_id } /\" , \"\" , 1 ) break else : warn ( OptimadeGatewayWarning ( title = \"Non-Unique Entry ID\" , detail = ( f \"The passed entry ID <id= { matched_id } > may be ambiguous! To get\" \" a specific structures entry, one can prepend the ID with a \" \"database ID belonging to the gateway, followed by a forward \" f \"slash, e.g., ' { database_ids [ 0 ] } /<local_database_ID>'. \" f \"Available databases for this gateway: { database_ids } \" ), ) ) return updated_filter # type: ignore[return-value]","title":"prepare_query_filter()"},{"location":"api_reference/queries/process/","text":"process \u00b6 Process performed OPTIMADE queries. process_db_response ( response , database_id , query , gateway ) async \u00b6 Process an OPTIMADE database response. The passed query will be updated with the top-level meta information: data_available , data_returned , and more_data_available . Since, only either data or errors should ever be present, one or the other will be either an empty list or None . Parameters: Name Type Description Default response Union[ErrorResponse, EntryResponseMany, EntryResponseOne] The OPTIMADE database response to be processed. required database_id str The database's id under which the returned resources or errors will be delivered. required query QueryResource A resource representing the performed query. required gateway GatewayResource A resource representing the gateway that was queried. required Returns: Type Description Union[List[EntryResource], List[Dict[str, Any]], EntryResource, Dict[str, Any], None] The response's data . Source code in optimade_gateway/queries/process.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 async def process_db_response ( response : \"Union[ErrorResponse, EntryResponseMany, EntryResponseOne]\" , database_id : str , query : \"QueryResource\" , gateway : \"GatewayResource\" , ) -> \"Union[List[EntryResource], List[Dict[str, Any]], EntryResource, Dict[str, Any], None]\" : # pylint: disable=line-too-long \"\"\"Process an OPTIMADE database response. The passed `query` will be updated with the top-level `meta` information: `data_available`, `data_returned`, and `more_data_available`. Since, only either `data` or `errors` should ever be present, one or the other will be either an empty list or `None`. Parameters: response: The OPTIMADE database response to be processed. database_id: The database's `id` under which the returned resources or errors will be delivered. query: A resource representing the performed query. gateway: A resource representing the gateway that was queried. Returns: The response's `data`. \"\"\" results = [] errors = [] LOGGER . debug ( \"Starting to process database_id: %s \" , database_id ) if isinstance ( response , ErrorResponse ): for error in response . errors : if isinstance ( error . id , str ) and error . id . startswith ( \"OPTIMADE_GATEWAY\" ): warn ( error . detail , OptimadeGatewayWarning ) else : # The model `ErrorResponse` does not allow the objects in the top-level # `errors` list to be parsed as dictionaries - they must be a pydantic # model. meta_error = {} if error . meta : meta_error = error . meta . dict () meta_error . update ( { f \"_ { CONFIG . provider . prefix } _source_gateway\" : { \"id\" : gateway . id , \"type\" : gateway . type , \"links\" : { \"self\" : gateway . links . self }, }, f \"_ { CONFIG . provider . prefix } _source_database\" : { \"id\" : database_id , \"type\" : \"links\" , \"links\" : { \"self\" : ( str ( gateway . links . self ) . split ( \"gateways\" , maxsplit = 1 )[ 0 ] + f \"databases/ { database_id } \" ) }, }, } ) error . meta = Meta ( ** meta_error ) errors . append ( error ) data_returned = 0 more_data_available = False else : results = response . data if isinstance ( results , list ): data_returned = response . meta . data_returned or len ( results ) else : data_returned = response . meta . data_returned or ( 0 if not results else 1 ) more_data_available = response . meta . more_data_available or False data_available = response . meta . data_available or 0 extra_updates = { \"$inc\" : { \"response.meta.data_available\" : data_available , \"response.meta.data_returned\" : data_returned , } } if not get_resource_attribute ( query , \"attributes.response.meta.more_data_available\" , False , disambiguate = False , # Extremely minor speed-up ): # Keep it True, if set to True once. extra_updates . update ( { \"$set\" : { \"response.meta.more_data_available\" : more_data_available }} ) # This ensures an empty list under `response.data.{database_id}` is returned if the # case is simply that there are no results to return. if errors : extra_updates . update ({ \"$addToSet\" : { \"response.errors\" : { \"$each\" : errors }}}) await update_query ( query , f \"response.data. { database_id } \" , results , operator = None , ** extra_updates , ) return results","title":"process"},{"location":"api_reference/queries/process/#process","text":"Process performed OPTIMADE queries.","title":"process"},{"location":"api_reference/queries/process/#optimade_gateway.queries.process.process_db_response","text":"Process an OPTIMADE database response. The passed query will be updated with the top-level meta information: data_available , data_returned , and more_data_available . Since, only either data or errors should ever be present, one or the other will be either an empty list or None . Parameters: Name Type Description Default response Union[ErrorResponse, EntryResponseMany, EntryResponseOne] The OPTIMADE database response to be processed. required database_id str The database's id under which the returned resources or errors will be delivered. required query QueryResource A resource representing the performed query. required gateway GatewayResource A resource representing the gateway that was queried. required Returns: Type Description Union[List[EntryResource], List[Dict[str, Any]], EntryResource, Dict[str, Any], None] The response's data . Source code in optimade_gateway/queries/process.py 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 async def process_db_response ( response : \"Union[ErrorResponse, EntryResponseMany, EntryResponseOne]\" , database_id : str , query : \"QueryResource\" , gateway : \"GatewayResource\" , ) -> \"Union[List[EntryResource], List[Dict[str, Any]], EntryResource, Dict[str, Any], None]\" : # pylint: disable=line-too-long \"\"\"Process an OPTIMADE database response. The passed `query` will be updated with the top-level `meta` information: `data_available`, `data_returned`, and `more_data_available`. Since, only either `data` or `errors` should ever be present, one or the other will be either an empty list or `None`. Parameters: response: The OPTIMADE database response to be processed. database_id: The database's `id` under which the returned resources or errors will be delivered. query: A resource representing the performed query. gateway: A resource representing the gateway that was queried. Returns: The response's `data`. \"\"\" results = [] errors = [] LOGGER . debug ( \"Starting to process database_id: %s \" , database_id ) if isinstance ( response , ErrorResponse ): for error in response . errors : if isinstance ( error . id , str ) and error . id . startswith ( \"OPTIMADE_GATEWAY\" ): warn ( error . detail , OptimadeGatewayWarning ) else : # The model `ErrorResponse` does not allow the objects in the top-level # `errors` list to be parsed as dictionaries - they must be a pydantic # model. meta_error = {} if error . meta : meta_error = error . meta . dict () meta_error . update ( { f \"_ { CONFIG . provider . prefix } _source_gateway\" : { \"id\" : gateway . id , \"type\" : gateway . type , \"links\" : { \"self\" : gateway . links . self }, }, f \"_ { CONFIG . provider . prefix } _source_database\" : { \"id\" : database_id , \"type\" : \"links\" , \"links\" : { \"self\" : ( str ( gateway . links . self ) . split ( \"gateways\" , maxsplit = 1 )[ 0 ] + f \"databases/ { database_id } \" ) }, }, } ) error . meta = Meta ( ** meta_error ) errors . append ( error ) data_returned = 0 more_data_available = False else : results = response . data if isinstance ( results , list ): data_returned = response . meta . data_returned or len ( results ) else : data_returned = response . meta . data_returned or ( 0 if not results else 1 ) more_data_available = response . meta . more_data_available or False data_available = response . meta . data_available or 0 extra_updates = { \"$inc\" : { \"response.meta.data_available\" : data_available , \"response.meta.data_returned\" : data_returned , } } if not get_resource_attribute ( query , \"attributes.response.meta.more_data_available\" , False , disambiguate = False , # Extremely minor speed-up ): # Keep it True, if set to True once. extra_updates . update ( { \"$set\" : { \"response.meta.more_data_available\" : more_data_available }} ) # This ensures an empty list under `response.data.{database_id}` is returned if the # case is simply that there are no results to return. if errors : extra_updates . update ({ \"$addToSet\" : { \"response.errors\" : { \"$each\" : errors }}}) await update_query ( query , f \"response.data. { database_id } \" , results , operator = None , ** extra_updates , ) return results","title":"process_db_response()"},{"location":"api_reference/queries/utils/","text":"utils \u00b6 Utility functions for the queries module. update_query ( query , field , value , operator = None , ** mongo_kwargs ) async \u00b6 Update a query's field attribute with value . If field is a dot-separated value, then only the last field part may be a non-pre-existing field. Otherwise a KeyError or AttributeError will be raised. Note This can only update a field for a query's attributes , i.e., this function cannot update id , type or any other top-level resource field. Important mongo_kwargs will not be considered for updating the pydantic model instance. Parameters: Name Type Description Default query QueryResource The query to be updated. required field str The attributes field (key) to be set. This can be a dot-separated key value to signify embedded fields. Example : response.meta . required value Any The (possibly) new value for field . required operator Optional[str] A MongoDB operator to be used for updating field with value . None **mongo_kwargs Any Further MongoDB update filters. {} Source code in optimade_gateway/queries/utils.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 async def update_query ( # pylint: disable=too-many-branches query : \"QueryResource\" , field : str , value : \"Any\" , operator : \"Optional[str]\" = None , ** mongo_kwargs : \"Any\" , ) -> None : \"\"\"Update a query's `field` attribute with `value`. If `field` is a dot-separated value, then only the last field part may be a non-pre-existing field. Otherwise a `KeyError` or `AttributeError` will be raised. !!! note This can *only* update a field for a query's `attributes`, i.e., this function cannot update `id`, `type` or any other top-level resource field. !!! important `mongo_kwargs` will not be considered for updating the pydantic model instance. Parameters: query: The query to be updated. field: The `attributes` field (key) to be set. This can be a dot-separated key value to signify embedded fields. **Example**: `response.meta`. value: The (possibly) new value for `field`. operator: A MongoDB operator to be used for updating `field` with `value`. **mongo_kwargs: Further MongoDB update filters. \"\"\" operator = operator or \"$set\" if operator and not operator . startswith ( \"$\" ): operator = f \"$ { operator } \" update_time = datetime . utcnow () update_kwargs = { \"$set\" : { \"last_modified\" : update_time }} if mongo_kwargs : update_kwargs . update ( mongo_kwargs ) if operator and operator == \"$set\" : update_kwargs [ \"$set\" ] . update ({ field : value }) elif operator : if operator in update_kwargs : update_kwargs [ operator ] . update ({ field : value }) else : update_kwargs . update ({ operator : { field : value }}) # MongoDB collection = await collection_factory ( CONFIG . queries_collection ) result : \"UpdateResult\" = await collection . collection . update_one ( filter = { \"id\" : { \"$eq\" : query . id }}, update = await clean_python_types ( update_kwargs ), ) if result . matched_count != 1 : LOGGER . error ( ( \"matched_count should have been exactly 1, it was: %s . \" \"Returned update_one result: %s \" ), result . matched_count , result . raw_result , ) # Pydantic model instance query . attributes . last_modified = update_time if \".\" in field : field_list = field . split ( \".\" ) sub_field : \"Union[BaseModel, Dict[str, Any]]\" = getattr ( query . attributes , field_list [ 0 ] ) for field_part in field_list [ 1 : - 1 ]: if isinstance ( sub_field , dict ): sub_field = sub_field . get ( field_part , {}) else : sub_field = getattr ( sub_field , field_part ) if isinstance ( sub_field , dict ): sub_field [ field_list [ - 1 ]] = value else : setattr ( sub_field , field_list [ - 1 ], value ) else : setattr ( query . attributes , field , value )","title":"utils"},{"location":"api_reference/queries/utils/#utils","text":"Utility functions for the queries module.","title":"utils"},{"location":"api_reference/queries/utils/#optimade_gateway.queries.utils.update_query","text":"Update a query's field attribute with value . If field is a dot-separated value, then only the last field part may be a non-pre-existing field. Otherwise a KeyError or AttributeError will be raised. Note This can only update a field for a query's attributes , i.e., this function cannot update id , type or any other top-level resource field. Important mongo_kwargs will not be considered for updating the pydantic model instance. Parameters: Name Type Description Default query QueryResource The query to be updated. required field str The attributes field (key) to be set. This can be a dot-separated key value to signify embedded fields. Example : response.meta . required value Any The (possibly) new value for field . required operator Optional[str] A MongoDB operator to be used for updating field with value . None **mongo_kwargs Any Further MongoDB update filters. {} Source code in optimade_gateway/queries/utils.py 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 async def update_query ( # pylint: disable=too-many-branches query : \"QueryResource\" , field : str , value : \"Any\" , operator : \"Optional[str]\" = None , ** mongo_kwargs : \"Any\" , ) -> None : \"\"\"Update a query's `field` attribute with `value`. If `field` is a dot-separated value, then only the last field part may be a non-pre-existing field. Otherwise a `KeyError` or `AttributeError` will be raised. !!! note This can *only* update a field for a query's `attributes`, i.e., this function cannot update `id`, `type` or any other top-level resource field. !!! important `mongo_kwargs` will not be considered for updating the pydantic model instance. Parameters: query: The query to be updated. field: The `attributes` field (key) to be set. This can be a dot-separated key value to signify embedded fields. **Example**: `response.meta`. value: The (possibly) new value for `field`. operator: A MongoDB operator to be used for updating `field` with `value`. **mongo_kwargs: Further MongoDB update filters. \"\"\" operator = operator or \"$set\" if operator and not operator . startswith ( \"$\" ): operator = f \"$ { operator } \" update_time = datetime . utcnow () update_kwargs = { \"$set\" : { \"last_modified\" : update_time }} if mongo_kwargs : update_kwargs . update ( mongo_kwargs ) if operator and operator == \"$set\" : update_kwargs [ \"$set\" ] . update ({ field : value }) elif operator : if operator in update_kwargs : update_kwargs [ operator ] . update ({ field : value }) else : update_kwargs . update ({ operator : { field : value }}) # MongoDB collection = await collection_factory ( CONFIG . queries_collection ) result : \"UpdateResult\" = await collection . collection . update_one ( filter = { \"id\" : { \"$eq\" : query . id }}, update = await clean_python_types ( update_kwargs ), ) if result . matched_count != 1 : LOGGER . error ( ( \"matched_count should have been exactly 1, it was: %s . \" \"Returned update_one result: %s \" ), result . matched_count , result . raw_result , ) # Pydantic model instance query . attributes . last_modified = update_time if \".\" in field : field_list = field . split ( \".\" ) sub_field : \"Union[BaseModel, Dict[str, Any]]\" = getattr ( query . attributes , field_list [ 0 ] ) for field_part in field_list [ 1 : - 1 ]: if isinstance ( sub_field , dict ): sub_field = sub_field . get ( field_part , {}) else : sub_field = getattr ( sub_field , field_part ) if isinstance ( sub_field , dict ): sub_field [ field_list [ - 1 ]] = value else : setattr ( sub_field , field_list [ - 1 ], value ) else : setattr ( query . attributes , field , value )","title":"update_query()"},{"location":"api_reference/routers/databases/","text":"databases \u00b6 /databases/* This file describes the router for /databases/{id} where, id may be left out. Database resources represent the available databases that may be used for the gateways. One can register a new database (by using POST /databases ) or look through the available databases (by using GET /databases ) using standard OPTIMADE filtering. get_database ( request , database_id , params = Depends ()) async \u00b6 GET /databases/{database ID} Return a single LinksResource representing the database resource object with id={database ID} . Source code in optimade_gateway/routers/databases.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 @ROUTER . get ( \"/databases/{database_id:path}\" , response_model = DatabasesResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], responses = ERROR_RESPONSES , ) async def get_database ( request : Request , database_id : str , params : SingleEntryQueryParams = Depends (), ) -> DatabasesResponseSingle : \"\"\"`GET /databases/{database ID}` Return a single [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) representing the database resource object with `id={database ID}`. \"\"\" collection = await collection_factory ( CONFIG . databases_collection ) params . filter = f 'id=\" { database_id } \"' ( result , data_returned , more_data_available , fields , include_fields , ) = await collection . afind ( params = params ) if fields or include_fields and result is not None : result = handle_response_fields ( result , fields , include_fields ) result = result [ 0 ] if isinstance ( result , list ) and data_returned else None return DatabasesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = data_returned , data_available = await collection . acount (), more_data_available = more_data_available , schema = CONFIG . schema_url , ), ) get_databases ( request , params = Depends ()) async \u00b6 GET /databases Return overview of all (active) databases. Source code in optimade_gateway/routers/databases.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 @ROUTER . get ( \"/databases\" , response_model = DatabasesResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], responses = ERROR_RESPONSES , ) async def get_databases ( request : Request , params : EntryListingQueryParams = Depends (), ) -> DatabasesResponse : \"\"\"`GET /databases` Return overview of all (active) databases. \"\"\" return await get_entries ( collection = await collection_factory ( CONFIG . databases_collection ), response_cls = DatabasesResponse , request = request , params = params , ) post_databases ( request , database ) async \u00b6 POST /databases Create/Register or return an existing LinksResource , representing a database resource object, according to database . Source code in optimade_gateway/routers/databases.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @ROUTER . post ( \"/databases\" , response_model = DatabasesResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], responses = ERROR_RESPONSES , ) async def post_databases ( request : Request , database : DatabaseCreate ) -> DatabasesResponseSingle : \"\"\"`POST /databases` Create/Register or return an existing [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource), representing a database resource object, according to `database`. \"\"\" result , created = await resource_factory ( database ) collection = await collection_factory ( CONFIG . databases_collection ) return DatabasesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"databases"},{"location":"api_reference/routers/databases/#databases","text":"/databases/* This file describes the router for /databases/{id} where, id may be left out. Database resources represent the available databases that may be used for the gateways. One can register a new database (by using POST /databases ) or look through the available databases (by using GET /databases ) using standard OPTIMADE filtering.","title":"databases"},{"location":"api_reference/routers/databases/#optimade_gateway.routers.databases.get_database","text":"GET /databases/{database ID} Return a single LinksResource representing the database resource object with id={database ID} . Source code in optimade_gateway/routers/databases.py 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 @ROUTER . get ( \"/databases/{database_id:path}\" , response_model = DatabasesResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], responses = ERROR_RESPONSES , ) async def get_database ( request : Request , database_id : str , params : SingleEntryQueryParams = Depends (), ) -> DatabasesResponseSingle : \"\"\"`GET /databases/{database ID}` Return a single [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) representing the database resource object with `id={database ID}`. \"\"\" collection = await collection_factory ( CONFIG . databases_collection ) params . filter = f 'id=\" { database_id } \"' ( result , data_returned , more_data_available , fields , include_fields , ) = await collection . afind ( params = params ) if fields or include_fields and result is not None : result = handle_response_fields ( result , fields , include_fields ) result = result [ 0 ] if isinstance ( result , list ) and data_returned else None return DatabasesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = data_returned , data_available = await collection . acount (), more_data_available = more_data_available , schema = CONFIG . schema_url , ), )","title":"get_database()"},{"location":"api_reference/routers/databases/#optimade_gateway.routers.databases.get_databases","text":"GET /databases Return overview of all (active) databases. Source code in optimade_gateway/routers/databases.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 @ROUTER . get ( \"/databases\" , response_model = DatabasesResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], responses = ERROR_RESPONSES , ) async def get_databases ( request : Request , params : EntryListingQueryParams = Depends (), ) -> DatabasesResponse : \"\"\"`GET /databases` Return overview of all (active) databases. \"\"\" return await get_entries ( collection = await collection_factory ( CONFIG . databases_collection ), response_cls = DatabasesResponse , request = request , params = params , )","title":"get_databases()"},{"location":"api_reference/routers/databases/#optimade_gateway.routers.databases.post_databases","text":"POST /databases Create/Register or return an existing LinksResource , representing a database resource object, according to database . Source code in optimade_gateway/routers/databases.py 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 @ROUTER . post ( \"/databases\" , response_model = DatabasesResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], responses = ERROR_RESPONSES , ) async def post_databases ( request : Request , database : DatabaseCreate ) -> DatabasesResponseSingle : \"\"\"`POST /databases` Create/Register or return an existing [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource), representing a database resource object, according to `database`. \"\"\" result , created = await resource_factory ( database ) collection = await collection_factory ( CONFIG . databases_collection ) return DatabasesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"post_databases()"},{"location":"api_reference/routers/gateways/","text":"gateways \u00b6 /gateways/* This file describes the router for /gateways/{id} where, id may be left out. get_gateway ( request , gateway_id ) async \u00b6 GET /gateways/{gateway ID} Return a single GatewayResource . Source code in optimade_gateway/routers/gateways.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @ROUTER . get ( \"/gateways/ {gateway_id} \" , response_model = GatewaysResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], responses = ERROR_RESPONSES , ) async def get_gateway ( request : Request , gateway_id : str ) -> GatewaysResponseSingle : \"\"\"`GET /gateways/{gateway ID}` Return a single [`GatewayResource`][optimade_gateway.models.gateways.GatewayResource]. \"\"\" collection = await collection_factory ( CONFIG . gateways_collection ) result = await get_valid_resource ( collection , gateway_id ) return GatewaysResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ), ) get_gateways ( request , params = Depends ()) async \u00b6 GET /gateways Return overview of all (active) gateways. Source code in optimade_gateway/routers/gateways.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @ROUTER . get ( \"/gateways\" , response_model = GatewaysResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], responses = ERROR_RESPONSES , ) async def get_gateways ( request : Request , params : EntryListingQueryParams = Depends (), ) -> GatewaysResponse : \"\"\"`GET /gateways` Return overview of all (active) gateways. \"\"\" return await get_entries ( collection = await collection_factory ( CONFIG . gateways_collection ), response_cls = GatewaysResponse , request = request , params = params , ) post_gateways ( request , gateway ) async \u00b6 POST /gateways Create or return existing gateway according to gateway . Source code in optimade_gateway/routers/gateways.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @ROUTER . post ( \"/gateways\" , response_model = GatewaysResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], responses = ERROR_RESPONSES , ) async def post_gateways ( request : Request , gateway : GatewayCreate ) -> GatewaysResponseSingle : \"\"\"`POST /gateways` Create or return existing gateway according to `gateway`. \"\"\" if gateway . database_ids : databases_collection = await collection_factory ( CONFIG . databases_collection ) databases = await databases_collection . get_multiple ( filter = { \"id\" : { \"$in\" : await clean_python_types ( gateway . database_ids )}} ) if not isinstance ( gateway . databases , list ): gateway . databases = [] current_database_ids = [ _ . id for _ in gateway . databases ] gateway . databases . extend ( ( _ for _ in databases if _ . id not in current_database_ids ) ) result , created = await resource_factory ( gateway ) collection = await collection_factory ( CONFIG . gateways_collection ) return GatewaysResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"gateways"},{"location":"api_reference/routers/gateways/#gateways","text":"/gateways/* This file describes the router for /gateways/{id} where, id may be left out.","title":"gateways"},{"location":"api_reference/routers/gateways/#optimade_gateway.routers.gateways.get_gateway","text":"GET /gateways/{gateway ID} Return a single GatewayResource . Source code in optimade_gateway/routers/gateways.py 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 @ROUTER . get ( \"/gateways/ {gateway_id} \" , response_model = GatewaysResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], responses = ERROR_RESPONSES , ) async def get_gateway ( request : Request , gateway_id : str ) -> GatewaysResponseSingle : \"\"\"`GET /gateways/{gateway ID}` Return a single [`GatewayResource`][optimade_gateway.models.gateways.GatewayResource]. \"\"\" collection = await collection_factory ( CONFIG . gateways_collection ) result = await get_valid_resource ( collection , gateway_id ) return GatewaysResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ), )","title":"get_gateway()"},{"location":"api_reference/routers/gateways/#optimade_gateway.routers.gateways.get_gateways","text":"GET /gateways Return overview of all (active) gateways. Source code in optimade_gateway/routers/gateways.py 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 @ROUTER . get ( \"/gateways\" , response_model = GatewaysResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], responses = ERROR_RESPONSES , ) async def get_gateways ( request : Request , params : EntryListingQueryParams = Depends (), ) -> GatewaysResponse : \"\"\"`GET /gateways` Return overview of all (active) gateways. \"\"\" return await get_entries ( collection = await collection_factory ( CONFIG . gateways_collection ), response_cls = GatewaysResponse , request = request , params = params , )","title":"get_gateways()"},{"location":"api_reference/routers/gateways/#optimade_gateway.routers.gateways.post_gateways","text":"POST /gateways Create or return existing gateway according to gateway . Source code in optimade_gateway/routers/gateways.py 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 @ROUTER . post ( \"/gateways\" , response_model = GatewaysResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], responses = ERROR_RESPONSES , ) async def post_gateways ( request : Request , gateway : GatewayCreate ) -> GatewaysResponseSingle : \"\"\"`POST /gateways` Create or return existing gateway according to `gateway`. \"\"\" if gateway . database_ids : databases_collection = await collection_factory ( CONFIG . databases_collection ) databases = await databases_collection . get_multiple ( filter = { \"id\" : { \"$in\" : await clean_python_types ( gateway . database_ids )}} ) if not isinstance ( gateway . databases , list ): gateway . databases = [] current_database_ids = [ _ . id for _ in gateway . databases ] gateway . databases . extend ( ( _ for _ in databases if _ . id not in current_database_ids ) ) result , created = await resource_factory ( gateway ) collection = await collection_factory ( CONFIG . gateways_collection ) return GatewaysResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"post_gateways()"},{"location":"api_reference/routers/info/","text":"info \u00b6 /info/* This file describes the router for /info/{entry} where, entry may be left out. get_entry_info ( request , entry ) async \u00b6 GET /info/{entry} Get information about the gateway service's entry-listing endpoints. Source code in optimade_gateway/routers/info.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @ROUTER . get ( \"/info/ {entry} \" , response_model = EntryInfoResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], responses = ERROR_RESPONSES , ) async def get_entry_info ( request : Request , entry : str ) -> EntryInfoResponse : \"\"\"`GET /info/{entry}` Get information about the gateway service's entry-listing endpoints. \"\"\" valid_entry_info_endpoints = ENTRY_INFO_SCHEMAS . keys () if entry not in valid_entry_info_endpoints : raise NotFound ( detail = ( f \"Entry info not found for { entry } , valid entry info endpoints are: \" f \" { ', ' . join ( valid_entry_info_endpoints ) } \" ), ) schema = ENTRY_INFO_SCHEMAS [ entry ]() queryable_properties = { \"id\" , \"type\" , \"attributes\" } properties = await aretrieve_queryable_properties ( schema , queryable_properties ) output_fields_by_format = { \"json\" : list ( properties . keys ())} return EntryInfoResponse ( data = EntryInfoResource ( formats = list ( output_fields_by_format . keys ()), description = schema . get ( \"description\" , \"Entry Resources\" ), properties = properties , output_fields_by_format = output_fields_by_format , ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , schema = CONFIG . schema_url , ), ) get_info ( request ) async \u00b6 GET /info An introspective endpoint for the gateway service. Source code in optimade_gateway/routers/info.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @ROUTER . get ( \"/info\" , response_model = InfoResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], responses = ERROR_RESPONSES , ) async def get_info ( request : Request ) -> InfoResponse : \"\"\"`GET /info` An introspective endpoint for the gateway service. \"\"\" return InfoResponse ( data = BaseInfoResource ( id = BaseInfoResource . schema ()[ \"properties\" ][ \"id\" ][ \"default\" ], type = BaseInfoResource . schema ()[ \"properties\" ][ \"type\" ][ \"default\" ], attributes = BaseInfoAttributes ( api_version = __api_version__ , available_api_versions = [ { \"url\" : ( f \" { get_base_url ( request . url ) } \" f \"/v { __api_version__ . split ( '.' , maxsplit = 1 )[ 0 ] } \" ), \"version\" : __api_version__ , } ], formats = [ \"json\" ], entry_types_by_format = { \"json\" : list ( ENTRY_INFO_SCHEMAS . keys ())}, available_endpoints = sorted ( [ \"docs\" , \"info\" , \"links\" , \"openapi.json\" , \"redoc\" , \"search\" , ] + list ( ENTRY_INFO_SCHEMAS . keys ()) ), is_index = False , ), ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , schema = CONFIG . schema_url , ), )","title":"info"},{"location":"api_reference/routers/info/#info","text":"/info/* This file describes the router for /info/{entry} where, entry may be left out.","title":"info"},{"location":"api_reference/routers/info/#optimade_gateway.routers.info.get_entry_info","text":"GET /info/{entry} Get information about the gateway service's entry-listing endpoints. Source code in optimade_gateway/routers/info.py 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 @ROUTER . get ( \"/info/ {entry} \" , response_model = EntryInfoResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], responses = ERROR_RESPONSES , ) async def get_entry_info ( request : Request , entry : str ) -> EntryInfoResponse : \"\"\"`GET /info/{entry}` Get information about the gateway service's entry-listing endpoints. \"\"\" valid_entry_info_endpoints = ENTRY_INFO_SCHEMAS . keys () if entry not in valid_entry_info_endpoints : raise NotFound ( detail = ( f \"Entry info not found for { entry } , valid entry info endpoints are: \" f \" { ', ' . join ( valid_entry_info_endpoints ) } \" ), ) schema = ENTRY_INFO_SCHEMAS [ entry ]() queryable_properties = { \"id\" , \"type\" , \"attributes\" } properties = await aretrieve_queryable_properties ( schema , queryable_properties ) output_fields_by_format = { \"json\" : list ( properties . keys ())} return EntryInfoResponse ( data = EntryInfoResource ( formats = list ( output_fields_by_format . keys ()), description = schema . get ( \"description\" , \"Entry Resources\" ), properties = properties , output_fields_by_format = output_fields_by_format , ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , schema = CONFIG . schema_url , ), )","title":"get_entry_info()"},{"location":"api_reference/routers/info/#optimade_gateway.routers.info.get_info","text":"GET /info An introspective endpoint for the gateway service. Source code in optimade_gateway/routers/info.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 @ROUTER . get ( \"/info\" , response_model = InfoResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], responses = ERROR_RESPONSES , ) async def get_info ( request : Request ) -> InfoResponse : \"\"\"`GET /info` An introspective endpoint for the gateway service. \"\"\" return InfoResponse ( data = BaseInfoResource ( id = BaseInfoResource . schema ()[ \"properties\" ][ \"id\" ][ \"default\" ], type = BaseInfoResource . schema ()[ \"properties\" ][ \"type\" ][ \"default\" ], attributes = BaseInfoAttributes ( api_version = __api_version__ , available_api_versions = [ { \"url\" : ( f \" { get_base_url ( request . url ) } \" f \"/v { __api_version__ . split ( '.' , maxsplit = 1 )[ 0 ] } \" ), \"version\" : __api_version__ , } ], formats = [ \"json\" ], entry_types_by_format = { \"json\" : list ( ENTRY_INFO_SCHEMAS . keys ())}, available_endpoints = sorted ( [ \"docs\" , \"info\" , \"links\" , \"openapi.json\" , \"redoc\" , \"search\" , ] + list ( ENTRY_INFO_SCHEMAS . keys ()) ), is_index = False , ), ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , schema = CONFIG . schema_url , ), )","title":"get_info()"},{"location":"api_reference/routers/links/","text":"links \u00b6 /links/* This file describes the router for /links get_links ( request , params = Depends ()) async \u00b6 GET /links Return a regular /links response for an OPTIMADE implementation. Source code in optimade_gateway/routers/links.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @ROUTER . get ( \"/links\" , response_model = LinksResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Links\" ], responses = ERROR_RESPONSES , ) async def get_links ( request : Request , params : EntryListingQueryParams = Depends () ) -> LinksResponse : \"\"\"`GET /links` Return a regular `/links` response for an OPTIMADE implementation. \"\"\" return await get_entries ( collection = await collection_factory ( CONFIG . links_collection ), response_cls = LinksResponse , request = request , params = params , )","title":"links"},{"location":"api_reference/routers/links/#links","text":"/links/* This file describes the router for /links","title":"links"},{"location":"api_reference/routers/links/#optimade_gateway.routers.links.get_links","text":"GET /links Return a regular /links response for an OPTIMADE implementation. Source code in optimade_gateway/routers/links.py 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 @ROUTER . get ( \"/links\" , response_model = LinksResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Links\" ], responses = ERROR_RESPONSES , ) async def get_links ( request : Request , params : EntryListingQueryParams = Depends () ) -> LinksResponse : \"\"\"`GET /links` Return a regular `/links` response for an OPTIMADE implementation. \"\"\" return await get_entries ( collection = await collection_factory ( CONFIG . links_collection ), response_cls = LinksResponse , request = request , params = params , )","title":"get_links()"},{"location":"api_reference/routers/queries/","text":"queries \u00b6 General /queries endpoint to handle gateway queries This file describes the router for /queries/{id} where, id may be left out. get_queries ( request , params = Depends ()) async \u00b6 GET /queries Return overview of all (active) queries. Source code in optimade_gateway/routers/queries.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @ROUTER . get ( \"/queries\" , response_model = QueriesResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], responses = ERROR_RESPONSES , ) async def get_queries ( request : Request , params : EntryListingQueryParams = Depends (), ) -> QueriesResponse : \"\"\"`GET /queries` Return overview of all (active) queries. \"\"\" return await get_entries ( collection = await collection_factory ( CONFIG . queries_collection ), response_cls = QueriesResponse , request = request , params = params , ) get_query ( request , query_id , response ) async \u00b6 GET /queries/{query_id} Return a single QueryResource . Source code in optimade_gateway/routers/queries.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @ROUTER . get ( \"/queries/ {query_id} \" , response_model = QueriesResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], responses = ERROR_RESPONSES , ) async def get_query ( request : Request , query_id : str , response : Response , ) -> QueriesResponseSingle : \"\"\"`GET /queries/{query_id}` Return a single [`QueryResource`][optimade_gateway.models.queries.QueryResource]. \"\"\" collection = await collection_factory ( CONFIG . queries_collection ) query : QueryResource = await get_valid_resource ( collection , query_id ) if query . attributes . response and query . attributes . response . errors : for error in query . attributes . response . errors : if error . status : for part in error . status . split ( \" \" ): try : response . status_code = int ( part ) break except ValueError : pass if response . status_code and response . status_code >= 300 : break else : response . status_code = 500 return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = query , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ), ) post_queries ( request , query ) async \u00b6 POST /queries Create or return existing gateway query according to query . Source code in optimade_gateway/routers/queries.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @ROUTER . post ( \"/queries\" , response_model = QueriesResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], status_code = status . HTTP_202_ACCEPTED , responses = ERROR_RESPONSES , ) async def post_queries ( request : Request , query : QueryCreate , ) -> QueriesResponseSingle : \"\"\"`POST /queries` Create or return existing gateway query according to `query`. \"\"\" await validate_resource ( await collection_factory ( CONFIG . gateways_collection ), query . gateway_id ) result , created = await resource_factory ( query ) if created : asyncio . create_task ( perform_query ( url = request . url , query = result )) collection = await collection_factory ( CONFIG . queries_collection ) return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"queries"},{"location":"api_reference/routers/queries/#queries","text":"General /queries endpoint to handle gateway queries This file describes the router for /queries/{id} where, id may be left out.","title":"queries"},{"location":"api_reference/routers/queries/#optimade_gateway.routers.queries.get_queries","text":"GET /queries Return overview of all (active) queries. Source code in optimade_gateway/routers/queries.py 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 @ROUTER . get ( \"/queries\" , response_model = QueriesResponse , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], responses = ERROR_RESPONSES , ) async def get_queries ( request : Request , params : EntryListingQueryParams = Depends (), ) -> QueriesResponse : \"\"\"`GET /queries` Return overview of all (active) queries. \"\"\" return await get_entries ( collection = await collection_factory ( CONFIG . queries_collection ), response_cls = QueriesResponse , request = request , params = params , )","title":"get_queries()"},{"location":"api_reference/routers/queries/#optimade_gateway.routers.queries.get_query","text":"GET /queries/{query_id} Return a single QueryResource . Source code in optimade_gateway/routers/queries.py 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 @ROUTER . get ( \"/queries/ {query_id} \" , response_model = QueriesResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], responses = ERROR_RESPONSES , ) async def get_query ( request : Request , query_id : str , response : Response , ) -> QueriesResponseSingle : \"\"\"`GET /queries/{query_id}` Return a single [`QueryResource`][optimade_gateway.models.queries.QueryResource]. \"\"\" collection = await collection_factory ( CONFIG . queries_collection ) query : QueryResource = await get_valid_resource ( collection , query_id ) if query . attributes . response and query . attributes . response . errors : for error in query . attributes . response . errors : if error . status : for part in error . status . split ( \" \" ): try : response . status_code = int ( part ) break except ValueError : pass if response . status_code and response . status_code >= 300 : break else : response . status_code = 500 return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = query , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ), )","title":"get_query()"},{"location":"api_reference/routers/queries/#optimade_gateway.routers.queries.post_queries","text":"POST /queries Create or return existing gateway query according to query . Source code in optimade_gateway/routers/queries.py 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 @ROUTER . post ( \"/queries\" , response_model = QueriesResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], status_code = status . HTTP_202_ACCEPTED , responses = ERROR_RESPONSES , ) async def post_queries ( request : Request , query : QueryCreate , ) -> QueriesResponseSingle : \"\"\"`POST /queries` Create or return existing gateway query according to `query`. \"\"\" await validate_resource ( await collection_factory ( CONFIG . gateways_collection ), query . gateway_id ) result , created = await resource_factory ( query ) if created : asyncio . create_task ( perform_query ( url = request . url , query = result )) collection = await collection_factory ( CONFIG . queries_collection ) return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"post_queries()"},{"location":"api_reference/routers/search/","text":"search \u00b6 General /search endpoint to completely coordinate an OPTIMADE gateway query This file describes the router for /search get_search ( request , response , search_params = Depends (), entry_params = Depends ()) async \u00b6 GET /search Coordinate a new OPTIMADE query in multiple databases through a gateway: Create a Search POST data - calling POST /search . Wait search_params.timeout seconds before returning the query, if it has not finished before. Return query - similar to GET /queries/{query_id} . This endpoint works similarly to GET /queries/{query_id} , where one passes the query parameters directly in the URL, instead of first POSTing a query and then going to its URL. Hence, a QueryResponseSingle is the standard response model for this endpoint. If the timeout time is reached and the query has not yet finished, the user is redirected to the specific URL for the query. If the as_optimade query parameter is True , the response will be parseable as a standard OPTIMADE entry listing endpoint like, e.g., /structures . For more information see the OPTIMADE specification . Source code in optimade_gateway/routers/search.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 @ROUTER . get ( \"/search\" , response_model = Union [ QueriesResponseSingle , EntryResponseMany , ErrorResponse ], # type: ignore[arg-type] response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Search\" ], responses = ERROR_RESPONSES , ) async def get_search ( request : Request , response : Response , search_params : SearchQueryParams = Depends (), entry_params : EntryListingQueryParams = Depends (), ) -> Union [ QueriesResponseSingle , EntryResponseMany , ErrorResponse , RedirectResponse ]: \"\"\"`GET /search` Coordinate a new OPTIMADE query in multiple databases through a gateway: 1. Create a [`Search`][optimade_gateway.models.search.Search] `POST` data - calling `POST /search`. 1. Wait [`search_params.timeout`][optimade_gateway.queries.params.SearchQueryParams] seconds before returning the query, if it has not finished before. 1. Return query - similar to `GET /queries/{query_id}`. This endpoint works similarly to `GET /queries/{query_id}`, where one passes the query parameters directly in the URL, instead of first POSTing a query and then going to its URL. Hence, a [`QueryResponseSingle`][optimade_gateway.models.responses.QueriesResponseSingle] is the standard response model for this endpoint. If the timeout time is reached and the query has not yet finished, the user is redirected to the specific URL for the query. If the `as_optimade` query parameter is `True`, the response will be parseable as a standard OPTIMADE entry listing endpoint like, e.g., `/structures`. For more information see the [OPTIMADE specification](https://github.com/Materials-Consortia/OPTIMADE/blob/master/optimade.rst#entry-listing-endpoints). \"\"\" try : search = Search ( query_parameters = OptimadeQueryParameters ( ** { field : getattr ( entry_params , field ) for field in OptimadeQueryParameters . __fields__ if getattr ( entry_params , field ) } ), optimade_urls = search_params . optimade_urls , endpoint = search_params . endpoint , database_ids = search_params . database_ids , ) except ValidationError as exc : raise BadRequest ( detail = ( \"A Search object could not be created from the given URL query \" f \"parameters. Error(s): { exc . errors } \" ) ) from exc queries_response = await post_search ( request , search = search ) if not queries_response . data : LOGGER . error ( \"QueryResource not found in POST /search response: \\n %s \" , queries_response ) raise RuntimeError ( \"Expected the response from POST /search to return a QueryResource, it did \" \"not\" ) once = True start_time = time () while ( # pylint: disable=too-many-nested-blocks time () < ( start_time + search_params . timeout ) or once ): # Make sure to run this at least once (e.g., if timeout=0) once = False collection = await collection_factory ( CONFIG . queries_collection ) query : QueryResource = await collection . get_one ( ** { \"filter\" : { \"id\" : queries_response . data . id }} ) if query . attributes . state == QueryState . FINISHED : if query . attributes . response and query . attributes . response . errors : for error in query . attributes . response . errors : if error . status : for part in error . status . split ( \" \" ): try : response . status_code = int ( part ) break except ValueError : pass if response . status_code and response . status_code >= 300 : break else : response . status_code = 500 if search_params . as_optimade : return await query . response_as_optimade ( url = request . url ) return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = query , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ), ) await asyncio . sleep ( 0.1 ) # The query has not yet succeeded and we're past the timeout time -> Redirect to # /queries/<id> return RedirectResponse ( query . links . self ) post_search ( request , search ) async \u00b6 POST /search Coordinate a new OPTIMADE query in multiple databases through a gateway: Search for gateway in DB using optimade_urls and database_ids Create GatewayCreate model POST gateway resource to get ID - using functionality of POST /gateways Create new Query resource POST Query resource - using functionality of POST /queries Return POST /queries response - QueriesResponseSingle Source code in optimade_gateway/routers/search.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 @ROUTER . post ( \"/search\" , response_model = QueriesResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Search\" ], status_code = status . HTTP_202_ACCEPTED , responses = ERROR_RESPONSES , ) async def post_search ( request : Request , search : Search ) -> QueriesResponseSingle : \"\"\"`POST /search` Coordinate a new OPTIMADE query in multiple databases through a gateway: 1. Search for gateway in DB using `optimade_urls` and `database_ids` 1. Create [`GatewayCreate`][optimade_gateway.models.gateways.GatewayCreate] model 1. `POST` gateway resource to get ID - using functionality of `POST /gateways` 1. Create new [Query][optimade_gateway.models.queries.QueryCreate] resource 1. `POST` Query resource - using functionality of `POST /queries` 1. Return `POST /queries` response - [`QueriesResponseSingle`][optimade_gateway.models.responses.QueriesResponseSingle] \"\"\" databases_collection = await collection_factory ( CONFIG . databases_collection ) # NOTE: It may be that the final list of base URLs (`base_urls`) contains the same # provider(s), but with differring base URLS, if, for example, a versioned base URL # is supplied. base_urls = set () if search . database_ids : databases = await databases_collection . get_multiple ( filter = { \"id\" : { \"$in\" : await clean_python_types ( search . database_ids )}} ) base_urls |= { get_resource_attribute ( database , \"attributes.base_url\" ) for database in databases if get_resource_attribute ( database , \"attributes.base_url\" ) is not None } if search . optimade_urls : base_urls |= { _ for _ in search . optimade_urls if _ is not None } if not base_urls : msg = \"No (valid) OPTIMADE URLs with:\" if search . database_ids : msg += ( f \" \\n Database IDs: { search . database_ids } and corresponding found URLs: \" f \" { [ get_resource_attribute ( database , 'attributes.base_url' ) for database in databases ] } \" ) if search . optimade_urls : msg += f \" \\n Passed OPTIMADE URLs: { search . optimade_urls } \" raise BadRequest ( detail = msg ) # Ensure all URLs are `pydantic.AnyUrl`s if not all ( isinstance ( _ , AnyUrl ) for _ in base_urls ): raise InternalServerError ( \"Could unexpectedly not validate all base URLs as proper URLs.\" ) databases = await databases_collection . get_multiple ( filter = { \"base_url\" : { \"$in\" : await clean_python_types ( base_urls )}} ) if len ( databases ) == len ( base_urls ): # At this point it is expected that the list of databases in `databases` # is a complete set of databases requested. gateway = GatewayCreate ( databases = databases ) elif len ( databases ) < len ( base_urls ): # There are unregistered databases current_base_urls = { get_resource_attribute ( database , \"attributes.base_url\" ) for database in databases } databases . extend ( [ LinksResource ( id = ( f \" { url . user + '@' if url . user else '' }{ url . host } \" f \" { ':' + url . port if url . port else '' } \" f \" { url . path . rstrip ( '/' ) if url . path else '' } \" ) . replace ( \".\" , \"__\" ), type = \"links\" , attributes = LinksResourceAttributes ( name = ( f \" { url . user + '@' if url . user else '' }{ url . host } \" f \" { ':' + url . port if url . port else '' } \" f \" { url . path . rstrip ( '/' ) if url . path else '' } \" ), description = \"\" , base_url = url , link_type = LinkType . CHILD , homepage = None , ), ) for url in base_urls - current_base_urls ] ) else : LOGGER . error ( \"Found more database entries in MongoDB than then number of passed base URLs.\" \" This suggests ambiguity in the base URLs of databases stored in MongoDB. \\n \" \" base_urls: %s \\n databases %s \" , base_urls , databases , ) raise InternalServerError ( \"Unambiguous base URLs. See logs for more details.\" ) gateway = GatewayCreate ( databases = databases ) gateway , created = await resource_factory ( gateway ) if created : LOGGER . debug ( \"A new gateway was created for a query (id= %r )\" , gateway . id ) else : LOGGER . debug ( \"A gateway was found and reused for a query (id= %r )\" , gateway . id ) query = QueryCreate ( endpoint = search . endpoint , gateway_id = gateway . id , query_parameters = search . query_parameters , ) query , created = await resource_factory ( query ) if created : asyncio . create_task ( perform_query ( url = request . url , query = query )) collection = await collection_factory ( CONFIG . queries_collection ) return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = query , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"search"},{"location":"api_reference/routers/search/#search","text":"General /search endpoint to completely coordinate an OPTIMADE gateway query This file describes the router for /search","title":"search"},{"location":"api_reference/routers/search/#optimade_gateway.routers.search.get_search","text":"GET /search Coordinate a new OPTIMADE query in multiple databases through a gateway: Create a Search POST data - calling POST /search . Wait search_params.timeout seconds before returning the query, if it has not finished before. Return query - similar to GET /queries/{query_id} . This endpoint works similarly to GET /queries/{query_id} , where one passes the query parameters directly in the URL, instead of first POSTing a query and then going to its URL. Hence, a QueryResponseSingle is the standard response model for this endpoint. If the timeout time is reached and the query has not yet finished, the user is redirected to the specific URL for the query. If the as_optimade query parameter is True , the response will be parseable as a standard OPTIMADE entry listing endpoint like, e.g., /structures . For more information see the OPTIMADE specification . Source code in optimade_gateway/routers/search.py 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 @ROUTER . get ( \"/search\" , response_model = Union [ QueriesResponseSingle , EntryResponseMany , ErrorResponse ], # type: ignore[arg-type] response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Search\" ], responses = ERROR_RESPONSES , ) async def get_search ( request : Request , response : Response , search_params : SearchQueryParams = Depends (), entry_params : EntryListingQueryParams = Depends (), ) -> Union [ QueriesResponseSingle , EntryResponseMany , ErrorResponse , RedirectResponse ]: \"\"\"`GET /search` Coordinate a new OPTIMADE query in multiple databases through a gateway: 1. Create a [`Search`][optimade_gateway.models.search.Search] `POST` data - calling `POST /search`. 1. Wait [`search_params.timeout`][optimade_gateway.queries.params.SearchQueryParams] seconds before returning the query, if it has not finished before. 1. Return query - similar to `GET /queries/{query_id}`. This endpoint works similarly to `GET /queries/{query_id}`, where one passes the query parameters directly in the URL, instead of first POSTing a query and then going to its URL. Hence, a [`QueryResponseSingle`][optimade_gateway.models.responses.QueriesResponseSingle] is the standard response model for this endpoint. If the timeout time is reached and the query has not yet finished, the user is redirected to the specific URL for the query. If the `as_optimade` query parameter is `True`, the response will be parseable as a standard OPTIMADE entry listing endpoint like, e.g., `/structures`. For more information see the [OPTIMADE specification](https://github.com/Materials-Consortia/OPTIMADE/blob/master/optimade.rst#entry-listing-endpoints). \"\"\" try : search = Search ( query_parameters = OptimadeQueryParameters ( ** { field : getattr ( entry_params , field ) for field in OptimadeQueryParameters . __fields__ if getattr ( entry_params , field ) } ), optimade_urls = search_params . optimade_urls , endpoint = search_params . endpoint , database_ids = search_params . database_ids , ) except ValidationError as exc : raise BadRequest ( detail = ( \"A Search object could not be created from the given URL query \" f \"parameters. Error(s): { exc . errors } \" ) ) from exc queries_response = await post_search ( request , search = search ) if not queries_response . data : LOGGER . error ( \"QueryResource not found in POST /search response: \\n %s \" , queries_response ) raise RuntimeError ( \"Expected the response from POST /search to return a QueryResource, it did \" \"not\" ) once = True start_time = time () while ( # pylint: disable=too-many-nested-blocks time () < ( start_time + search_params . timeout ) or once ): # Make sure to run this at least once (e.g., if timeout=0) once = False collection = await collection_factory ( CONFIG . queries_collection ) query : QueryResource = await collection . get_one ( ** { \"filter\" : { \"id\" : queries_response . data . id }} ) if query . attributes . state == QueryState . FINISHED : if query . attributes . response and query . attributes . response . errors : for error in query . attributes . response . errors : if error . status : for part in error . status . split ( \" \" ): try : response . status_code = int ( part ) break except ValueError : pass if response . status_code and response . status_code >= 300 : break else : response . status_code = 500 if search_params . as_optimade : return await query . response_as_optimade ( url = request . url ) return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = query , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ), ) await asyncio . sleep ( 0.1 ) # The query has not yet succeeded and we're past the timeout time -> Redirect to # /queries/<id> return RedirectResponse ( query . links . self )","title":"get_search()"},{"location":"api_reference/routers/search/#optimade_gateway.routers.search.post_search","text":"POST /search Coordinate a new OPTIMADE query in multiple databases through a gateway: Search for gateway in DB using optimade_urls and database_ids Create GatewayCreate model POST gateway resource to get ID - using functionality of POST /gateways Create new Query resource POST Query resource - using functionality of POST /queries Return POST /queries response - QueriesResponseSingle Source code in optimade_gateway/routers/search.py 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 @ROUTER . post ( \"/search\" , response_model = QueriesResponseSingle , response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Search\" ], status_code = status . HTTP_202_ACCEPTED , responses = ERROR_RESPONSES , ) async def post_search ( request : Request , search : Search ) -> QueriesResponseSingle : \"\"\"`POST /search` Coordinate a new OPTIMADE query in multiple databases through a gateway: 1. Search for gateway in DB using `optimade_urls` and `database_ids` 1. Create [`GatewayCreate`][optimade_gateway.models.gateways.GatewayCreate] model 1. `POST` gateway resource to get ID - using functionality of `POST /gateways` 1. Create new [Query][optimade_gateway.models.queries.QueryCreate] resource 1. `POST` Query resource - using functionality of `POST /queries` 1. Return `POST /queries` response - [`QueriesResponseSingle`][optimade_gateway.models.responses.QueriesResponseSingle] \"\"\" databases_collection = await collection_factory ( CONFIG . databases_collection ) # NOTE: It may be that the final list of base URLs (`base_urls`) contains the same # provider(s), but with differring base URLS, if, for example, a versioned base URL # is supplied. base_urls = set () if search . database_ids : databases = await databases_collection . get_multiple ( filter = { \"id\" : { \"$in\" : await clean_python_types ( search . database_ids )}} ) base_urls |= { get_resource_attribute ( database , \"attributes.base_url\" ) for database in databases if get_resource_attribute ( database , \"attributes.base_url\" ) is not None } if search . optimade_urls : base_urls |= { _ for _ in search . optimade_urls if _ is not None } if not base_urls : msg = \"No (valid) OPTIMADE URLs with:\" if search . database_ids : msg += ( f \" \\n Database IDs: { search . database_ids } and corresponding found URLs: \" f \" { [ get_resource_attribute ( database , 'attributes.base_url' ) for database in databases ] } \" ) if search . optimade_urls : msg += f \" \\n Passed OPTIMADE URLs: { search . optimade_urls } \" raise BadRequest ( detail = msg ) # Ensure all URLs are `pydantic.AnyUrl`s if not all ( isinstance ( _ , AnyUrl ) for _ in base_urls ): raise InternalServerError ( \"Could unexpectedly not validate all base URLs as proper URLs.\" ) databases = await databases_collection . get_multiple ( filter = { \"base_url\" : { \"$in\" : await clean_python_types ( base_urls )}} ) if len ( databases ) == len ( base_urls ): # At this point it is expected that the list of databases in `databases` # is a complete set of databases requested. gateway = GatewayCreate ( databases = databases ) elif len ( databases ) < len ( base_urls ): # There are unregistered databases current_base_urls = { get_resource_attribute ( database , \"attributes.base_url\" ) for database in databases } databases . extend ( [ LinksResource ( id = ( f \" { url . user + '@' if url . user else '' }{ url . host } \" f \" { ':' + url . port if url . port else '' } \" f \" { url . path . rstrip ( '/' ) if url . path else '' } \" ) . replace ( \".\" , \"__\" ), type = \"links\" , attributes = LinksResourceAttributes ( name = ( f \" { url . user + '@' if url . user else '' }{ url . host } \" f \" { ':' + url . port if url . port else '' } \" f \" { url . path . rstrip ( '/' ) if url . path else '' } \" ), description = \"\" , base_url = url , link_type = LinkType . CHILD , homepage = None , ), ) for url in base_urls - current_base_urls ] ) else : LOGGER . error ( \"Found more database entries in MongoDB than then number of passed base URLs.\" \" This suggests ambiguity in the base URLs of databases stored in MongoDB. \\n \" \" base_urls: %s \\n databases %s \" , base_urls , databases , ) raise InternalServerError ( \"Unambiguous base URLs. See logs for more details.\" ) gateway = GatewayCreate ( databases = databases ) gateway , created = await resource_factory ( gateway ) if created : LOGGER . debug ( \"A new gateway was created for a query (id= %r )\" , gateway . id ) else : LOGGER . debug ( \"A gateway was found and reused for a query (id= %r )\" , gateway . id ) query = QueryCreate ( endpoint = search . endpoint , gateway_id = gateway . id , query_parameters = search . query_parameters , ) query , created = await resource_factory ( query ) if created : asyncio . create_task ( perform_query ( url = request . url , query = query )) collection = await collection_factory ( CONFIG . queries_collection ) return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = query , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await collection . acount (), more_data_available = False , schema = CONFIG . schema_url , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"post_search()"},{"location":"api_reference/routers/utils/","text":"utils \u00b6 Utility functions for all routers. COLLECTIONS : Dict [ str , AsyncMongoCollection ] = {} module-attribute \u00b6 A lazy-loaded dictionary of asynchronous MongoDB entry-endpoint collections. aretrieve_queryable_properties ( schema , queryable_properties ) async \u00b6 Asynchronous implementation of retrieve_queryable_properties() from optimade Reference to the function in the optimade API documentation: retrieve_queryable_properties() . Recursively loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: Name Type Description Default schema Dict[str, Any] The schema of the pydantic model. required queryable_properties Iterable The list of properties to find in the schema. required Returns: Type Description dict A flat dictionary with properties as keys, containing the field description, unit, dict sortability, support level, queryability and type, where provided. Source code in optimade_gateway/routers/utils.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 async def aretrieve_queryable_properties ( schema : \"Dict[str, Any]\" , queryable_properties : \"Iterable\" ) -> dict : \"\"\"Asynchronous implementation of `retrieve_queryable_properties()` from `optimade` Reference to the function in the `optimade` API documentation: [`retrieve_queryable_properties()`](https://www.optimade.org/optimade-python-tools/api_reference/server/schemas/#optimade.server.schemas.retrieve_queryable_properties). Recursively loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: schema: The schema of the pydantic model. queryable_properties: The list of properties to find in the schema. Returns: A flat dictionary with properties as keys, containing the field description, unit, sortability, support level, queryability and type, where provided. \"\"\" return retrieve_queryable_properties ( schema = schema , queryable_properties = queryable_properties , ) collection_factory ( name ) async \u00b6 Get or initiate an entry-endpoint resource collection. This factory utilizes the global dictionary COLLECTIONS . It lazily instantiates the collections and then caches them in the dictionary. Parameters: Name Type Description Default name str The configured name for the entry-endpoint resource collection. required Returns: Type Description AsyncMongoCollection The OPTIMADE Gateway asynchronous implementation of the AsyncMongoCollection MongoCollection . Raises: Type Description ValueError If the supplied name is not one of the configured valid collection names. Source code in optimade_gateway/routers/utils.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 async def collection_factory ( name : str ) -> AsyncMongoCollection : \"\"\"Get or initiate an entry-endpoint resource collection. This factory utilizes the global dictionary [`COLLECTIONS`][optimade_gateway.routers.utils.COLLECTIONS]. It lazily instantiates the collections and then caches them in the dictionary. Parameters: name: The configured name for the entry-endpoint resource collection. Returns: The OPTIMADE Gateway asynchronous implementation of the [`MongoCollection`](https://www.optimade.org/optimade-python-tools/api_reference/server/entry_collections/mongo/#optimade.server.entry_collections.mongo.MongoCollection). Raises: ValueError: If the supplied `name` is not one of the configured valid collection names. \"\"\" if name in COLLECTIONS : return COLLECTIONS [ name ] if name == CONFIG . databases_collection : from optimade_gateway.mappers.databases import DatabasesMapper as ResourceMapper elif name == CONFIG . gateways_collection : from optimade_gateway.mappers.gateways import ( # type: ignore[no-redef] GatewaysMapper as ResourceMapper , ) elif name == CONFIG . queries_collection : from optimade_gateway.mappers.queries import ( # type: ignore[no-redef] QueryMapper as ResourceMapper , ) elif name == CONFIG . links_collection : from optimade_gateway.mappers.links import ( # type: ignore[no-redef] LinksMapper as ResourceMapper , ) else : raise ValueError ( f \" { name !r} is not a valid entry-endpoint resource collection name. Configured\" \" valid names: \" f \" { ( CONFIG . databases_collection , CONFIG . gateways_collection , CONFIG . queries_collection , CONFIG . links_collection ) } \" ) COLLECTIONS [ name ] = AsyncMongoCollection ( name = name , resource_cls = ResourceMapper . ENTRY_RESOURCE_CLASS , resource_mapper = ResourceMapper , ) return COLLECTIONS [ name ] get_entries ( collection , response_cls , request , params ) async \u00b6 Generalized /{entries} endpoint getter Source code in optimade_gateway/routers/utils.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 async def get_entries ( collection : AsyncMongoCollection , response_cls : \"EntryResponseMany\" , request : \"Request\" , params : \"EntryListingQueryParams\" , ) -> \"EntryResponseMany\" : \"\"\"Generalized `/{entries}` endpoint getter\"\"\" ( results , data_returned , more_data_available , fields , include_fields , ) = await collection . afind ( params = params ) if more_data_available : # Deduce the `next` link from the current request query = urllib . parse . parse_qs ( request . url . query ) query [ \"page_offset\" ] = [ int ( query . get ( \"page_offset\" , [ 0 ])[ 0 ]) + len ( results )] # type: ignore[list-item, arg-type] urlencoded = urllib . parse . urlencode ( query , doseq = True ) base_url = get_base_url ( request . url ) links = ToplevelLinks ( next = f \" { base_url }{ request . url . path } ? { urlencoded } \" ) else : links = ToplevelLinks ( next = None ) if fields or include_fields : results = handle_response_fields ( results , fields , include_fields ) return response_cls ( links = links , data = results , meta = meta_values ( url = request . url , data_returned = data_returned , data_available = await collection . acount (), more_data_available = more_data_available , schema = CONFIG . schema_url , ), ) get_valid_resource ( collection , entry_id ) async \u00b6 Validate and retrieve a resource Source code in optimade_gateway/routers/utils.py 120 121 122 123 124 125 async def get_valid_resource ( collection : AsyncMongoCollection , entry_id : str ) -> \"EntryResource\" : \"\"\"Validate and retrieve a resource\"\"\" await validate_resource ( collection , entry_id ) return await collection . get_one ( filter = { \"id\" : entry_id }) resource_factory ( create_resource ) async \u00b6 Get or create a resource Currently supported resources: \"databases\" ( DatabaseCreate -> LinksResource ) \"gateways\" ( GatewayCreate -> GatewayResource ) \"queries\" ( QueryCreate -> QueryResource ) For each of the resources, \"uniqueness\" is determined in the following way: Databases The base_url field is considered unique across all databases. If a base_url is provided via a Link model, the base_url.href value is used to query the MongoDB. Gateways The collected list of databases.attributes.base_url values is considered unique across all gateways. In the database, the search is done as a combination of the length/size of the databases ' Python list/MongoDB array and a match on all (using the MongoDB $all operator) of the databases.attributes.base_url element values, when compared with the create_resource . Important The database_ids attribute must not contain values that are not also included in the databases attribute, in the form of the IDs for the individual databases. If this should be the case an OptimadeGatewayError will be thrown. Queries The gateway_id , query_parameters , and endpoint fields are collectively considered to define uniqueness for a QueryResource in the MongoDB collection. Attention Only the /structures entry endpoint can be queried with multiple expected responses. This means the endpoint field defaults to \"structures\" , i.e., the StructureResource resource model. Parameters: Name Type Description Default create_resource Union[DatabaseCreate, GatewayCreate, QueryCreate] The resource to be retrieved or created anew. required Returns: Type Description Tuple[Union[LinksResource, GatewayResource, QueryResource], bool] Two things in a tuple: Tuple[Union[LinksResource, GatewayResource, QueryResource], bool] Either a GatewayResource ; a QueryResource ; or a LinksResource and Tuple[Union[LinksResource, GatewayResource, QueryResource], bool] whether or not the resource was newly created. Source code in optimade_gateway/routers/utils.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 async def resource_factory ( # pylint: disable=too-many-branches create_resource : \"Union[DatabaseCreate, GatewayCreate, QueryCreate]\" , ) -> \"Tuple[Union[LinksResource, GatewayResource, QueryResource], bool]\" : \"\"\"Get or create a resource Currently supported resources: - `\"databases\"` ([`DatabaseCreate`][optimade_gateway.models.databases.DatabaseCreate] -> [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource)) - `\"gateways\"` ([`GatewayCreate`][optimade_gateway.models.gateways.GatewayCreate] -> [`GatewayResource`][optimade_gateway.models.gateways.GatewayResource]) - `\"queries\"` ([`QueryCreate`][optimade_gateway.models.queries.QueryCreate] -> [`QueryResource`][optimade_gateway.models.queries.QueryResource]) For each of the resources, \"uniqueness\" is determined in the following way: === \"Databases\" The `base_url` field is considered unique across all databases. If a `base_url` is provided via a [`Link`](https://www.optimade.org/optimade-python-tools/api_reference/models/jsonapi/#optimade.models.jsonapi.Link) model, the `base_url.href` value is used to query the MongoDB. === \"Gateways\" The collected list of `databases.attributes.base_url` values is considered unique across all gateways. In the database, the search is done as a combination of the length/size of the `databases`' Python list/MongoDB array and a match on all (using the MongoDB `$all` operator) of the [`databases.attributes.base_url`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResourceAttributes.base_url) element values, when compared with the `create_resource`. !!! important The `database_ids` attribute **must not** contain values that are not also included in the `databases` attribute, in the form of the IDs for the individual databases. If this should be the case an [`OptimadeGatewayError`][optimade_gateway.common.exceptions.OptimadeGatewayError] will be thrown. === \"Queries\" The `gateway_id`, `query_parameters`, and `endpoint` fields are collectively considered to define uniqueness for a [`QueryResource`][optimade_gateway.models.queries.QueryResource] in the MongoDB collection. !!! attention Only the `/structures` entry endpoint can be queried with multiple expected responses. This means the `endpoint` field defaults to `\"structures\"`, i.e., the [`StructureResource`](https://www.optimade.org/optimade-python-tools/all_models/#optimade.models.structures.StructureResource) resource model. Parameters: create_resource: The resource to be retrieved or created anew. Returns: Two things in a tuple: - Either a [`GatewayResource`][optimade_gateway.models.gateways.GatewayResource]; a [`QueryResource`][optimade_gateway.models.queries.QueryResource]; or a [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) and - whether or not the resource was newly created. \"\"\" created = False if isinstance ( create_resource , DatabaseCreate ): collection_name = CONFIG . databases_collection base_url = get_resource_attribute ( create_resource , \"base_url\" ) mongo_query = { \"$or\" : [ { \"base_url\" : { \"$eq\" : base_url }}, { \"base_url.href\" : { \"$eq\" : base_url }}, ] } elif isinstance ( create_resource , GatewayCreate ): collection_name = CONFIG . gateways_collection # One MUST have taken care of database_ids prior to calling `resource_factory()` database_attr_ids = { _ . id for _ in create_resource . databases or []} unknown_ids = { database_id for database_id in create_resource . database_ids or [] if database_id not in database_attr_ids } if unknown_ids : raise OptimadeGatewayError ( \"When using `resource_factory()` for `GatewayCreate`, `database_ids` MUST\" f \" not include unknown IDs. Passed unknown IDs: { unknown_ids } \" ) mongo_query = { \"databases\" : { \"$size\" : len ( create_resource . databases )}, \"databases.attributes.base_url\" : { \"$all\" : [ _ . attributes . base_url for _ in create_resource . databases or []] }, } elif isinstance ( create_resource , QueryCreate ): collection_name = CONFIG . queries_collection # Currently only /structures entry endpoints can be queried with multiple # expected responses. create_resource . endpoint = ( create_resource . endpoint if create_resource . endpoint else \"structures\" ) mongo_query = { \"gateway_id\" : { \"$eq\" : create_resource . gateway_id }, \"query_parameters\" : { \"$eq\" : create_resource . query_parameters }, \"endpoint\" : { \"$eq\" : create_resource . endpoint }, } else : raise TypeError ( \"create_resource must be either a GatewayCreate or QueryCreate object not \" f \" { type ( create_resource ) !r} \" ) collection = await collection_factory ( collection_name ) result , data_returned , more_data_available , _ , _ = await collection . afind ( criteria = { \"filter\" : await clean_python_types ( mongo_query )} ) if more_data_available : raise OptimadeGatewayError ( \"more_data_available MUST be False for a single entry response, however it \" f \"is { more_data_available } \" ) if result : if data_returned > 1 : raise OptimadeGatewayError ( f \"More than one { result [ 0 ] . type } were found. IDs of found \" f \" { result [ 0 ] . type } : { [ _ . id for _ in result ] } \" ) if isinstance ( result , list ): result = result [ 0 ] else : if isinstance ( create_resource , DatabaseCreate ): # Set required `LinksResourceAttributes` values if not set if not create_resource . description : create_resource . description = ( f \" { create_resource . name } created by OPTIMADE gateway database \" \"registration.\" ) if not create_resource . link_type : create_resource . link_type = LinkType . EXTERNAL if not create_resource . homepage : create_resource . homepage = None elif isinstance ( create_resource , GatewayCreate ): # Do not store `database_ids` if \"database_ids\" in create_resource . __fields_set__ : create_resource . database_ids = None create_resource . __fields_set__ . remove ( \"database_ids\" ) elif isinstance ( create_resource , QueryCreate ): create_resource . state = QueryState . CREATED result = await collection . create_one ( create_resource ) LOGGER . debug ( \"Created new %s : %r \" , result . type , result ) created = True return result , created validate_resource ( collection , entry_id ) async \u00b6 Validate whether a resource exists in a collection Source code in optimade_gateway/routers/utils.py 112 113 114 115 116 117 async def validate_resource ( collection : AsyncMongoCollection , entry_id : str ) -> None : \"\"\"Validate whether a resource exists in a collection\"\"\" if not await collection . exists ( entry_id ): raise NotFound ( detail = f \"Resource <id= { entry_id } > not found in { collection } .\" , )","title":"utils"},{"location":"api_reference/routers/utils/#utils","text":"Utility functions for all routers.","title":"utils"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.COLLECTIONS","text":"A lazy-loaded dictionary of asynchronous MongoDB entry-endpoint collections.","title":"COLLECTIONS"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.aretrieve_queryable_properties","text":"Asynchronous implementation of retrieve_queryable_properties() from optimade Reference to the function in the optimade API documentation: retrieve_queryable_properties() . Recursively loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: Name Type Description Default schema Dict[str, Any] The schema of the pydantic model. required queryable_properties Iterable The list of properties to find in the schema. required Returns: Type Description dict A flat dictionary with properties as keys, containing the field description, unit, dict sortability, support level, queryability and type, where provided. Source code in optimade_gateway/routers/utils.py 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 async def aretrieve_queryable_properties ( schema : \"Dict[str, Any]\" , queryable_properties : \"Iterable\" ) -> dict : \"\"\"Asynchronous implementation of `retrieve_queryable_properties()` from `optimade` Reference to the function in the `optimade` API documentation: [`retrieve_queryable_properties()`](https://www.optimade.org/optimade-python-tools/api_reference/server/schemas/#optimade.server.schemas.retrieve_queryable_properties). Recursively loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: schema: The schema of the pydantic model. queryable_properties: The list of properties to find in the schema. Returns: A flat dictionary with properties as keys, containing the field description, unit, sortability, support level, queryability and type, where provided. \"\"\" return retrieve_queryable_properties ( schema = schema , queryable_properties = queryable_properties , )","title":"aretrieve_queryable_properties()"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.collection_factory","text":"Get or initiate an entry-endpoint resource collection. This factory utilizes the global dictionary COLLECTIONS . It lazily instantiates the collections and then caches them in the dictionary. Parameters: Name Type Description Default name str The configured name for the entry-endpoint resource collection. required Returns: Type Description AsyncMongoCollection The OPTIMADE Gateway asynchronous implementation of the AsyncMongoCollection MongoCollection . Raises: Type Description ValueError If the supplied name is not one of the configured valid collection names. Source code in optimade_gateway/routers/utils.py 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 async def collection_factory ( name : str ) -> AsyncMongoCollection : \"\"\"Get or initiate an entry-endpoint resource collection. This factory utilizes the global dictionary [`COLLECTIONS`][optimade_gateway.routers.utils.COLLECTIONS]. It lazily instantiates the collections and then caches them in the dictionary. Parameters: name: The configured name for the entry-endpoint resource collection. Returns: The OPTIMADE Gateway asynchronous implementation of the [`MongoCollection`](https://www.optimade.org/optimade-python-tools/api_reference/server/entry_collections/mongo/#optimade.server.entry_collections.mongo.MongoCollection). Raises: ValueError: If the supplied `name` is not one of the configured valid collection names. \"\"\" if name in COLLECTIONS : return COLLECTIONS [ name ] if name == CONFIG . databases_collection : from optimade_gateway.mappers.databases import DatabasesMapper as ResourceMapper elif name == CONFIG . gateways_collection : from optimade_gateway.mappers.gateways import ( # type: ignore[no-redef] GatewaysMapper as ResourceMapper , ) elif name == CONFIG . queries_collection : from optimade_gateway.mappers.queries import ( # type: ignore[no-redef] QueryMapper as ResourceMapper , ) elif name == CONFIG . links_collection : from optimade_gateway.mappers.links import ( # type: ignore[no-redef] LinksMapper as ResourceMapper , ) else : raise ValueError ( f \" { name !r} is not a valid entry-endpoint resource collection name. Configured\" \" valid names: \" f \" { ( CONFIG . databases_collection , CONFIG . gateways_collection , CONFIG . queries_collection , CONFIG . links_collection ) } \" ) COLLECTIONS [ name ] = AsyncMongoCollection ( name = name , resource_cls = ResourceMapper . ENTRY_RESOURCE_CLASS , resource_mapper = ResourceMapper , ) return COLLECTIONS [ name ]","title":"collection_factory()"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.get_entries","text":"Generalized /{entries} endpoint getter Source code in optimade_gateway/routers/utils.py 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 async def get_entries ( collection : AsyncMongoCollection , response_cls : \"EntryResponseMany\" , request : \"Request\" , params : \"EntryListingQueryParams\" , ) -> \"EntryResponseMany\" : \"\"\"Generalized `/{entries}` endpoint getter\"\"\" ( results , data_returned , more_data_available , fields , include_fields , ) = await collection . afind ( params = params ) if more_data_available : # Deduce the `next` link from the current request query = urllib . parse . parse_qs ( request . url . query ) query [ \"page_offset\" ] = [ int ( query . get ( \"page_offset\" , [ 0 ])[ 0 ]) + len ( results )] # type: ignore[list-item, arg-type] urlencoded = urllib . parse . urlencode ( query , doseq = True ) base_url = get_base_url ( request . url ) links = ToplevelLinks ( next = f \" { base_url }{ request . url . path } ? { urlencoded } \" ) else : links = ToplevelLinks ( next = None ) if fields or include_fields : results = handle_response_fields ( results , fields , include_fields ) return response_cls ( links = links , data = results , meta = meta_values ( url = request . url , data_returned = data_returned , data_available = await collection . acount (), more_data_available = more_data_available , schema = CONFIG . schema_url , ), )","title":"get_entries()"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.get_valid_resource","text":"Validate and retrieve a resource Source code in optimade_gateway/routers/utils.py 120 121 122 123 124 125 async def get_valid_resource ( collection : AsyncMongoCollection , entry_id : str ) -> \"EntryResource\" : \"\"\"Validate and retrieve a resource\"\"\" await validate_resource ( collection , entry_id ) return await collection . get_one ( filter = { \"id\" : entry_id })","title":"get_valid_resource()"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.resource_factory","text":"Get or create a resource Currently supported resources: \"databases\" ( DatabaseCreate -> LinksResource ) \"gateways\" ( GatewayCreate -> GatewayResource ) \"queries\" ( QueryCreate -> QueryResource ) For each of the resources, \"uniqueness\" is determined in the following way: Databases The base_url field is considered unique across all databases. If a base_url is provided via a Link model, the base_url.href value is used to query the MongoDB. Gateways The collected list of databases.attributes.base_url values is considered unique across all gateways. In the database, the search is done as a combination of the length/size of the databases ' Python list/MongoDB array and a match on all (using the MongoDB $all operator) of the databases.attributes.base_url element values, when compared with the create_resource . Important The database_ids attribute must not contain values that are not also included in the databases attribute, in the form of the IDs for the individual databases. If this should be the case an OptimadeGatewayError will be thrown. Queries The gateway_id , query_parameters , and endpoint fields are collectively considered to define uniqueness for a QueryResource in the MongoDB collection. Attention Only the /structures entry endpoint can be queried with multiple expected responses. This means the endpoint field defaults to \"structures\" , i.e., the StructureResource resource model. Parameters: Name Type Description Default create_resource Union[DatabaseCreate, GatewayCreate, QueryCreate] The resource to be retrieved or created anew. required Returns: Type Description Tuple[Union[LinksResource, GatewayResource, QueryResource], bool] Two things in a tuple: Tuple[Union[LinksResource, GatewayResource, QueryResource], bool] Either a GatewayResource ; a QueryResource ; or a LinksResource and Tuple[Union[LinksResource, GatewayResource, QueryResource], bool] whether or not the resource was newly created. Source code in optimade_gateway/routers/utils.py 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 async def resource_factory ( # pylint: disable=too-many-branches create_resource : \"Union[DatabaseCreate, GatewayCreate, QueryCreate]\" , ) -> \"Tuple[Union[LinksResource, GatewayResource, QueryResource], bool]\" : \"\"\"Get or create a resource Currently supported resources: - `\"databases\"` ([`DatabaseCreate`][optimade_gateway.models.databases.DatabaseCreate] -> [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource)) - `\"gateways\"` ([`GatewayCreate`][optimade_gateway.models.gateways.GatewayCreate] -> [`GatewayResource`][optimade_gateway.models.gateways.GatewayResource]) - `\"queries\"` ([`QueryCreate`][optimade_gateway.models.queries.QueryCreate] -> [`QueryResource`][optimade_gateway.models.queries.QueryResource]) For each of the resources, \"uniqueness\" is determined in the following way: === \"Databases\" The `base_url` field is considered unique across all databases. If a `base_url` is provided via a [`Link`](https://www.optimade.org/optimade-python-tools/api_reference/models/jsonapi/#optimade.models.jsonapi.Link) model, the `base_url.href` value is used to query the MongoDB. === \"Gateways\" The collected list of `databases.attributes.base_url` values is considered unique across all gateways. In the database, the search is done as a combination of the length/size of the `databases`' Python list/MongoDB array and a match on all (using the MongoDB `$all` operator) of the [`databases.attributes.base_url`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResourceAttributes.base_url) element values, when compared with the `create_resource`. !!! important The `database_ids` attribute **must not** contain values that are not also included in the `databases` attribute, in the form of the IDs for the individual databases. If this should be the case an [`OptimadeGatewayError`][optimade_gateway.common.exceptions.OptimadeGatewayError] will be thrown. === \"Queries\" The `gateway_id`, `query_parameters`, and `endpoint` fields are collectively considered to define uniqueness for a [`QueryResource`][optimade_gateway.models.queries.QueryResource] in the MongoDB collection. !!! attention Only the `/structures` entry endpoint can be queried with multiple expected responses. This means the `endpoint` field defaults to `\"structures\"`, i.e., the [`StructureResource`](https://www.optimade.org/optimade-python-tools/all_models/#optimade.models.structures.StructureResource) resource model. Parameters: create_resource: The resource to be retrieved or created anew. Returns: Two things in a tuple: - Either a [`GatewayResource`][optimade_gateway.models.gateways.GatewayResource]; a [`QueryResource`][optimade_gateway.models.queries.QueryResource]; or a [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) and - whether or not the resource was newly created. \"\"\" created = False if isinstance ( create_resource , DatabaseCreate ): collection_name = CONFIG . databases_collection base_url = get_resource_attribute ( create_resource , \"base_url\" ) mongo_query = { \"$or\" : [ { \"base_url\" : { \"$eq\" : base_url }}, { \"base_url.href\" : { \"$eq\" : base_url }}, ] } elif isinstance ( create_resource , GatewayCreate ): collection_name = CONFIG . gateways_collection # One MUST have taken care of database_ids prior to calling `resource_factory()` database_attr_ids = { _ . id for _ in create_resource . databases or []} unknown_ids = { database_id for database_id in create_resource . database_ids or [] if database_id not in database_attr_ids } if unknown_ids : raise OptimadeGatewayError ( \"When using `resource_factory()` for `GatewayCreate`, `database_ids` MUST\" f \" not include unknown IDs. Passed unknown IDs: { unknown_ids } \" ) mongo_query = { \"databases\" : { \"$size\" : len ( create_resource . databases )}, \"databases.attributes.base_url\" : { \"$all\" : [ _ . attributes . base_url for _ in create_resource . databases or []] }, } elif isinstance ( create_resource , QueryCreate ): collection_name = CONFIG . queries_collection # Currently only /structures entry endpoints can be queried with multiple # expected responses. create_resource . endpoint = ( create_resource . endpoint if create_resource . endpoint else \"structures\" ) mongo_query = { \"gateway_id\" : { \"$eq\" : create_resource . gateway_id }, \"query_parameters\" : { \"$eq\" : create_resource . query_parameters }, \"endpoint\" : { \"$eq\" : create_resource . endpoint }, } else : raise TypeError ( \"create_resource must be either a GatewayCreate or QueryCreate object not \" f \" { type ( create_resource ) !r} \" ) collection = await collection_factory ( collection_name ) result , data_returned , more_data_available , _ , _ = await collection . afind ( criteria = { \"filter\" : await clean_python_types ( mongo_query )} ) if more_data_available : raise OptimadeGatewayError ( \"more_data_available MUST be False for a single entry response, however it \" f \"is { more_data_available } \" ) if result : if data_returned > 1 : raise OptimadeGatewayError ( f \"More than one { result [ 0 ] . type } were found. IDs of found \" f \" { result [ 0 ] . type } : { [ _ . id for _ in result ] } \" ) if isinstance ( result , list ): result = result [ 0 ] else : if isinstance ( create_resource , DatabaseCreate ): # Set required `LinksResourceAttributes` values if not set if not create_resource . description : create_resource . description = ( f \" { create_resource . name } created by OPTIMADE gateway database \" \"registration.\" ) if not create_resource . link_type : create_resource . link_type = LinkType . EXTERNAL if not create_resource . homepage : create_resource . homepage = None elif isinstance ( create_resource , GatewayCreate ): # Do not store `database_ids` if \"database_ids\" in create_resource . __fields_set__ : create_resource . database_ids = None create_resource . __fields_set__ . remove ( \"database_ids\" ) elif isinstance ( create_resource , QueryCreate ): create_resource . state = QueryState . CREATED result = await collection . create_one ( create_resource ) LOGGER . debug ( \"Created new %s : %r \" , result . type , result ) created = True return result , created","title":"resource_factory()"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.validate_resource","text":"Validate whether a resource exists in a collection Source code in optimade_gateway/routers/utils.py 112 113 114 115 116 117 async def validate_resource ( collection : AsyncMongoCollection , entry_id : str ) -> None : \"\"\"Validate whether a resource exists in a collection\"\"\" if not await collection . exists ( entry_id ): raise NotFound ( detail = f \"Resource <id= { entry_id } > not found in { collection } .\" , )","title":"validate_resource()"}]}