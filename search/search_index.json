{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"OPTIMADE Gateway \u00b6 A REST API server acting as a gateway for databases with an OPTIMADE API, handling the distribution and collection of a single query to several different OPTIMADE databases. The design outline is available here . License, copyright & funding support \u00b6 All code in this repository was originally written by Casper Welzel Andersen ( @CasperWA ). The design for the gateway as outlined in design.md was a joint effort between Casper Welzel Andersen & Carl Simon Adorf ( @csadorf ). All files in this repository are licensed under the MIT license with copyright \u00a9 2021 Casper Welzel Andersen & THEOS, EPFL. Funding support \u00b6 This work was funded by THEOS , EPFL and the MarketPlace project . The MarketPlace project is funded by Horizon 2020 under H2020-NMBP-25-2017 call with Grant agreement number: 760173.","title":"OPTIMADE Gateway"},{"location":"#optimade-gateway","text":"A REST API server acting as a gateway for databases with an OPTIMADE API, handling the distribution and collection of a single query to several different OPTIMADE databases. The design outline is available here .","title":"OPTIMADE Gateway"},{"location":"#license-copyright-funding-support","text":"All code in this repository was originally written by Casper Welzel Andersen ( @CasperWA ). The design for the gateway as outlined in design.md was a joint effort between Casper Welzel Andersen & Carl Simon Adorf ( @csadorf ). All files in this repository are licensed under the MIT license with copyright \u00a9 2021 Casper Welzel Andersen & THEOS, EPFL.","title":"License, copyright &amp; funding support"},{"location":"#funding-support","text":"This work was funded by THEOS , EPFL and the MarketPlace project . The MarketPlace project is funded by Horizon 2020 under H2020-NMBP-25-2017 call with Grant agreement number: 760173.","title":"Funding support"},{"location":"CHANGELOG/","text":"","title":"Changelog"},{"location":"LICENSE/","text":"MIT License Copyright (c) 2021 Casper Welzel Andersen & THEOS, EPFL Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"design/","text":"Design of the OPTIMADE gateway \u00b6 The OPTIMADE gateway is intended to be implemented into the MarketPlace platform. Therefore, it should implement the MarketPlace Data Source API, as well as endpoints needed for the gateway capabilities themselves. To this end, the following sections defines/recaps these APIs and capabilities. MarketPlace Data Source API \u00b6 The MarketPlace Data Source API developed in T2.2 of the MarketPlace project. It can be found on the Fraunhofer GitLab here . Outline of the currently defined endpoints. Note, if there is no HTTP method next to the endpoint, it is not an available and reachable endpoint. /marketplace/ /schemas/ ( GET ) /{schema_id}/ /attributes ( GET ) /export ( POST ) /search ( POST ) OPTIMADE gateway API \u00b6 The suggested OPTIMADE gateway API. This API is based on the expected capabilities outlined below . /optimade/ Methods : GET Behavior : Introspective/static metadata overview of server. /query/ Methods : POST or GET Behavior : Orchestrate an OPTIMADE query. /gateways/ Methods : GET Behavior : Standard reponse : Introspective/static metadata overview of all gateways. Using special query parameter : Create/retrieve and return unique gateway ID. /{gateway_id}/ Methods : POST or GET Behavior : Create/retrieve search ID and return unique search ID. Start asynchronous search task. Either: /queries/ Methods : None Behavior : Disallowed. Note : This endpoint could support GET requests with similar functionality and behavior as for /gateways/ ? This would move some functionality away from /{gateway_id}/ to this endpoint. Making /{gateway_id}/ act as a mix of /query/ and /gateways/ in terms of orchestrating the search and returning introspective/static metadata about the gateway. /{search_id}/ Methods : GET Behavior : Return current results according to state of asynchronous search task. or: /{search_id}/ Methods : GET Behavior : Return current results according to state of asynchronous search task. OPTIMADE gateway capabilities \u00b6 Searching in multiple OPTIMADE databases . Utilize the OPTIMADE filter language . Retrieve entries (OPTIMADE structures) as JSON-serialized CUDS . Not a required capability for the base gateway API . Design ideas and comments by Simon Adorf ( @csadorf ) \u00b6 I think the way you would achieve the \u201cselection\u201d of databases is by creating provider-specific endpoints like this: GET /gateway?providers=abc,def,xyz This will return a deterministic gateway id related to specific set of providers, which you will then use for further queries like this: GET /gateway/{gateway_id}/structures/ etc. The gateway id would provide introspection, so /gateway/{gateway_id} returns some information about the gateway (supported OPTIMADE API, list of providers) etc. You would cache the gateway id in the client, so you don\u2019t have to make two requests for each query. If you don\u2019t provide a list of providers, the current default set is used. But this ensures that the REST API is actually stateless, because one gateway is always tied to a specific set of providers even if the default list is changed. Obviously, if you use a gateway that includes providers that are no longer available you would respond with code 503 or so. This design solves the issue of how to provide a gateway that implements the OPTIMADE API and allows for the selection of providers. I assume your results are paginated, so IMO \u2014 unless you request a specific order \u2014 you should just return results as they come in. You need to implement this gateway asynchronously anyways so it really does not matter whether you include slow providers or not. Of course, this changes if the user requests a specific order, but that\u2019s just how it is. From a user perspective it would make sense to me that such a query across multiple providers may take a while. You should definitely define a timeout for each gateway where if a provider does not respond by then, the result is returned regardless of whether the provider has responded. Or you respond with a time out code. Searching \u00b6 Taking Simon's comments into account, the search capability should be: Asynchronous; and Dynamic. The asynchronicity comes from creating web calls (possibly using CORS) to each (chosen) database asynchronously, collating the results in a single (gateway) endpoint. The dynamics here relate to the suggested dynamic creation (and possible deletion) of gateway IDs under a /gateway -endpoint. GET requests \u00b6 Essentially, for each search, a new gateway will be created (if needed) with a unique ID. This unique ID will constitue the content of the initial response after performing a search, so that the user can go to the new gateway ID-specific endpoint to retrieve the results. To make this easier for the user, the server could automatically redirect the user after creating the endpoint. Here the response will contain the currently retrieved results as well as som metadata information about how the search is going and a general overview. This would ideally result in the following search sequence: The final GET request can be repeated to retrieve more results during the timeline of the search happening, and to retrieve the final list of results in a set time period after the search has finished. POST requests \u00b6 One could also think of using POST requests instead, containing the OPTIMADE query parameters alongside with other information, mainly utilized for the /gateway/{unique ID} -endpoints. The response could contain a link or simply redirect to a /gateway/{unique ID}/{search unique ID} -endpoint. The latter part could also be done for the GET approach, since a specific gateway should support multiple unique simultaneous searched. Since the searches are asynchronous, the results don't come back from all resources simultaneously, thus demanding an extra endpoint, where the continuously updating results can be found - as well as the final list of results for a specific search. This differs from the section above, where a GET request should contain query parameters in the URL and this will be correlated with an ongoing (unique) search in the backend, which would potentially allow different users to experience the same loading of results if they performed the same search in the same gateway, even at slightly different times during the searching period. A sequence would ideally look this: Conclusion \u00b6 The best approach here would be to create unique search IDs under each unique gateway, pertaining to a specific search. In the same way that gateways may be reused, search results may be reused. However, to ensure the \"freshness\" of the data, the \"live\"-period for any unique search should be significantly smaller than that of any unique gateway. POST requests may be preferred due to the ability of combining OPTIMADE-specific query data and gateway-specific data. Suggested search sequence diagram : Design discussions (17.12.2020) \u00b6 To be backwards compatible (where each gateway may represent a fully fledged OPTIMADE database), make /gateways/{unique ID}/ redirect to /gateways/{unique ID}/structures/ . Note, remove CUDS as a required capability, content negotiation might be with different means than a URL query parameter. Caching \u00b6 Caching should be segmented for each database. For each new user query that retrieves and caches individual resources from a database, the lifetime of the cached resource should be updated to the set default (or what is determined by caching headers from the side of the database). Either the CacheControl or requests-cache packages will be utilized for caching. Since the time it takes for an OPTIMADE database to change its content varies, but is mainly quite long, individual search life times ( /gateways/{gateway ID}(/queries)/{search ID}/ ) can be \"long\", e.g., a couple of hours. However, these two ways of \"caching\" should be separate. It should always be possible to forcefully ensure a \"fresh\" search. OPTIMADE filter language \u00b6 The filter language will be reused as the filter language for any search in any gateway. The filter language is defined in the OPTIMADE specification . Retrieval formats \u00b6 All responses will be in JSON (for now). To choose the retrieval format of the structure, a query parameter will be dedicated for the /{search unique ID} endpoint. OPTIMADE \u00b6 The standard OPTIMADE format for defining structures will be reused for listing the structure entries. See the OPTIMADE specification for a list of properties defining the structures entry. When returning the results in this format, the whole response should be compliant with a standard OPTIMADE response as is expected in the /structures -endpoint. CUDS \u00b6 Utilizing the optimade2cuds Python package in the SimOPTIMADE repository on the Fraunhofer GitLab for the MarketPlace project, the resulting OPTIMADE structure can be converted to Python CUDS objects. From there they can be serialized to JSON representations (using the OSP-Core package) and returned as a search result response. External API calls \u00b6 When making external API calls, i.e., requesting the various OPTIMADE databases, this is technically done in a concurrent.futures.ThreadPoolExecutor . This is mainly done to not block the main OS thread, where the asyncio event loop is running . This is the event loop that handles incoming gateway requests. While the number of databases may not be significant, the response times can still vary and by using a ThreadPoolExecutor , the gateway is ready for more heavy use out-of-the-box. Another key reason to use a ThreadPoolExecutor (instead of Starlette's - and therefore FastAPI's - BackgroundTask ) is for testing with the pytest framework. When using BackgroundTask the response cannot be properly mocked and instead blocks the main OS thread. Perhaps this could be solved by implementing the same solution as has been done for now, namely running a time.sleep function call in a ThreadPoolExecutor , in the mocked response callback, but the benefits of using a ThreadPoolExecutor also for the actual queries outweigh this in the long run. For further considerations a ProcessPoolExecutor might even be considered, but it shouldn't be necessary as the work done is IO blocking, not CPU blocking. The possible speed-up should not be significant. Further reading and considerations on this subject Multithreading vs. Multiprocessing in Python by Amine Baatout is a good read. Another source of inspiration was found in this StackOverflow post response . Other ideas - a queue \u00b6 Throughout the process of figuring this out, other ideas were on the table. One was to setup an asyncio.Queue - either a single \"unbuffered channel\" queue for the whole lifetime of the server, or one each per request. This would effectively split up the perform_query in producer/worker functions. For some nice reading on this, check out Latency in Asynchronous Python by Chris Wellons ( null program ). Since the ThreadPoolExecutor solution solves the issue of the analogous \"heartbeat\" function not losing its responsivenes, i.e., the asyncio event loop not being blocked, and it would work with the current code implementation, I opted for this solution instead. But I recon a queue solution would work similarly, but perhaps with slightly less gateway API responsiveness during heavy load, since it all still runs in the same event loop.","title":"Design of the OPTIMADE gateway"},{"location":"design/#design-of-the-optimade-gateway","text":"The OPTIMADE gateway is intended to be implemented into the MarketPlace platform. Therefore, it should implement the MarketPlace Data Source API, as well as endpoints needed for the gateway capabilities themselves. To this end, the following sections defines/recaps these APIs and capabilities.","title":"Design of the OPTIMADE gateway"},{"location":"design/#marketplace-data-source-api","text":"The MarketPlace Data Source API developed in T2.2 of the MarketPlace project. It can be found on the Fraunhofer GitLab here . Outline of the currently defined endpoints. Note, if there is no HTTP method next to the endpoint, it is not an available and reachable endpoint. /marketplace/ /schemas/ ( GET ) /{schema_id}/ /attributes ( GET ) /export ( POST ) /search ( POST )","title":"MarketPlace Data Source API"},{"location":"design/#optimade-gateway-api","text":"The suggested OPTIMADE gateway API. This API is based on the expected capabilities outlined below . /optimade/ Methods : GET Behavior : Introspective/static metadata overview of server. /query/ Methods : POST or GET Behavior : Orchestrate an OPTIMADE query. /gateways/ Methods : GET Behavior : Standard reponse : Introspective/static metadata overview of all gateways. Using special query parameter : Create/retrieve and return unique gateway ID. /{gateway_id}/ Methods : POST or GET Behavior : Create/retrieve search ID and return unique search ID. Start asynchronous search task. Either: /queries/ Methods : None Behavior : Disallowed. Note : This endpoint could support GET requests with similar functionality and behavior as for /gateways/ ? This would move some functionality away from /{gateway_id}/ to this endpoint. Making /{gateway_id}/ act as a mix of /query/ and /gateways/ in terms of orchestrating the search and returning introspective/static metadata about the gateway. /{search_id}/ Methods : GET Behavior : Return current results according to state of asynchronous search task. or: /{search_id}/ Methods : GET Behavior : Return current results according to state of asynchronous search task.","title":"OPTIMADE gateway API"},{"location":"design/#optimade-gateway-capabilities","text":"Searching in multiple OPTIMADE databases . Utilize the OPTIMADE filter language . Retrieve entries (OPTIMADE structures) as JSON-serialized CUDS . Not a required capability for the base gateway API .","title":"OPTIMADE gateway capabilities"},{"location":"design/#design-ideas-and-comments-by-simon-adorf-csadorf","text":"I think the way you would achieve the \u201cselection\u201d of databases is by creating provider-specific endpoints like this: GET /gateway?providers=abc,def,xyz This will return a deterministic gateway id related to specific set of providers, which you will then use for further queries like this: GET /gateway/{gateway_id}/structures/ etc. The gateway id would provide introspection, so /gateway/{gateway_id} returns some information about the gateway (supported OPTIMADE API, list of providers) etc. You would cache the gateway id in the client, so you don\u2019t have to make two requests for each query. If you don\u2019t provide a list of providers, the current default set is used. But this ensures that the REST API is actually stateless, because one gateway is always tied to a specific set of providers even if the default list is changed. Obviously, if you use a gateway that includes providers that are no longer available you would respond with code 503 or so. This design solves the issue of how to provide a gateway that implements the OPTIMADE API and allows for the selection of providers. I assume your results are paginated, so IMO \u2014 unless you request a specific order \u2014 you should just return results as they come in. You need to implement this gateway asynchronously anyways so it really does not matter whether you include slow providers or not. Of course, this changes if the user requests a specific order, but that\u2019s just how it is. From a user perspective it would make sense to me that such a query across multiple providers may take a while. You should definitely define a timeout for each gateway where if a provider does not respond by then, the result is returned regardless of whether the provider has responded. Or you respond with a time out code.","title":"Design ideas and comments by Simon Adorf (@csadorf)"},{"location":"design/#searching","text":"Taking Simon's comments into account, the search capability should be: Asynchronous; and Dynamic. The asynchronicity comes from creating web calls (possibly using CORS) to each (chosen) database asynchronously, collating the results in a single (gateway) endpoint. The dynamics here relate to the suggested dynamic creation (and possible deletion) of gateway IDs under a /gateway -endpoint.","title":"Searching"},{"location":"design/#get-requests","text":"Essentially, for each search, a new gateway will be created (if needed) with a unique ID. This unique ID will constitue the content of the initial response after performing a search, so that the user can go to the new gateway ID-specific endpoint to retrieve the results. To make this easier for the user, the server could automatically redirect the user after creating the endpoint. Here the response will contain the currently retrieved results as well as som metadata information about how the search is going and a general overview. This would ideally result in the following search sequence: The final GET request can be repeated to retrieve more results during the timeline of the search happening, and to retrieve the final list of results in a set time period after the search has finished.","title":"GET requests"},{"location":"design/#post-requests","text":"One could also think of using POST requests instead, containing the OPTIMADE query parameters alongside with other information, mainly utilized for the /gateway/{unique ID} -endpoints. The response could contain a link or simply redirect to a /gateway/{unique ID}/{search unique ID} -endpoint. The latter part could also be done for the GET approach, since a specific gateway should support multiple unique simultaneous searched. Since the searches are asynchronous, the results don't come back from all resources simultaneously, thus demanding an extra endpoint, where the continuously updating results can be found - as well as the final list of results for a specific search. This differs from the section above, where a GET request should contain query parameters in the URL and this will be correlated with an ongoing (unique) search in the backend, which would potentially allow different users to experience the same loading of results if they performed the same search in the same gateway, even at slightly different times during the searching period. A sequence would ideally look this:","title":"POST requests"},{"location":"design/#conclusion","text":"The best approach here would be to create unique search IDs under each unique gateway, pertaining to a specific search. In the same way that gateways may be reused, search results may be reused. However, to ensure the \"freshness\" of the data, the \"live\"-period for any unique search should be significantly smaller than that of any unique gateway. POST requests may be preferred due to the ability of combining OPTIMADE-specific query data and gateway-specific data. Suggested search sequence diagram :","title":"Conclusion"},{"location":"design/#design-discussions-17122020","text":"To be backwards compatible (where each gateway may represent a fully fledged OPTIMADE database), make /gateways/{unique ID}/ redirect to /gateways/{unique ID}/structures/ . Note, remove CUDS as a required capability, content negotiation might be with different means than a URL query parameter.","title":"Design discussions (17.12.2020)"},{"location":"design/#caching","text":"Caching should be segmented for each database. For each new user query that retrieves and caches individual resources from a database, the lifetime of the cached resource should be updated to the set default (or what is determined by caching headers from the side of the database). Either the CacheControl or requests-cache packages will be utilized for caching. Since the time it takes for an OPTIMADE database to change its content varies, but is mainly quite long, individual search life times ( /gateways/{gateway ID}(/queries)/{search ID}/ ) can be \"long\", e.g., a couple of hours. However, these two ways of \"caching\" should be separate. It should always be possible to forcefully ensure a \"fresh\" search.","title":"Caching"},{"location":"design/#optimade-filter-language","text":"The filter language will be reused as the filter language for any search in any gateway. The filter language is defined in the OPTIMADE specification .","title":"OPTIMADE filter language"},{"location":"design/#retrieval-formats","text":"All responses will be in JSON (for now). To choose the retrieval format of the structure, a query parameter will be dedicated for the /{search unique ID} endpoint.","title":"Retrieval formats"},{"location":"design/#optimade","text":"The standard OPTIMADE format for defining structures will be reused for listing the structure entries. See the OPTIMADE specification for a list of properties defining the structures entry. When returning the results in this format, the whole response should be compliant with a standard OPTIMADE response as is expected in the /structures -endpoint.","title":"OPTIMADE"},{"location":"design/#cuds","text":"Utilizing the optimade2cuds Python package in the SimOPTIMADE repository on the Fraunhofer GitLab for the MarketPlace project, the resulting OPTIMADE structure can be converted to Python CUDS objects. From there they can be serialized to JSON representations (using the OSP-Core package) and returned as a search result response.","title":"CUDS"},{"location":"design/#external-api-calls","text":"When making external API calls, i.e., requesting the various OPTIMADE databases, this is technically done in a concurrent.futures.ThreadPoolExecutor . This is mainly done to not block the main OS thread, where the asyncio event loop is running . This is the event loop that handles incoming gateway requests. While the number of databases may not be significant, the response times can still vary and by using a ThreadPoolExecutor , the gateway is ready for more heavy use out-of-the-box. Another key reason to use a ThreadPoolExecutor (instead of Starlette's - and therefore FastAPI's - BackgroundTask ) is for testing with the pytest framework. When using BackgroundTask the response cannot be properly mocked and instead blocks the main OS thread. Perhaps this could be solved by implementing the same solution as has been done for now, namely running a time.sleep function call in a ThreadPoolExecutor , in the mocked response callback, but the benefits of using a ThreadPoolExecutor also for the actual queries outweigh this in the long run. For further considerations a ProcessPoolExecutor might even be considered, but it shouldn't be necessary as the work done is IO blocking, not CPU blocking. The possible speed-up should not be significant. Further reading and considerations on this subject Multithreading vs. Multiprocessing in Python by Amine Baatout is a good read. Another source of inspiration was found in this StackOverflow post response .","title":"External API calls"},{"location":"design/#other-ideas-a-queue","text":"Throughout the process of figuring this out, other ideas were on the table. One was to setup an asyncio.Queue - either a single \"unbuffered channel\" queue for the whole lifetime of the server, or one each per request. This would effectively split up the perform_query in producer/worker functions. For some nice reading on this, check out Latency in Asynchronous Python by Chris Wellons ( null program ). Since the ThreadPoolExecutor solution solves the issue of the analogous \"heartbeat\" function not losing its responsivenes, i.e., the asyncio event loop not being blocked, and it would work with the current code implementation, I opted for this solution instead. But I recon a queue solution would work similarly, but perhaps with slightly less gateway API responsiveness during heavy load, since it all still runs in the same event loop.","title":"Other ideas - a queue"},{"location":"api_reference/events/","text":"events \u00b6 EVENTS : Tuple [ Tuple [ str , Callable [[], NoneType ]]] \u00b6 A tuple of all pairs of events and event functions. To use this tuple of tuples: from fastapi import FastAPI APP = FastAPI () for event , func in EVENTS : APP . add_event_handler ( event , func ) ci_dev_startup () async \u00b6 Function to run at app startup - only relevant for CI or development to add test data Source code in optimade_gateway/events.py async def ci_dev_startup () -> None : \"\"\"Function to run at app startup - only relevant for CI or development to add test data\"\"\" import os if bool ( os . getenv ( \"CI\" , False )): LOGGER . info ( \"CI detected - Will load test gateways (after dropping the collection)!\" ) elif os . getenv ( \"OPTIMADE_MONGO_DATABASE\" , \"\" ) == \"optimade_gateway_dev\" : LOGGER . info ( \"Running in development mode - Will load test gateways (after dropping the collection)!\" ) else : LOGGER . debug ( \"Not in CI or development mode - will start normally.\" ) return # Add test gateways import json from optimade_gateway.mongo.database import MONGO_DB from pathlib import Path test_data = ( Path ( __file__ ) . parent . parent . joinpath ( \".ci/test_gateways.json\" ) . resolve () ) await MONGO_DB [ CONFIG . gateways_collection ] . drop () assert await MONGO_DB [ CONFIG . gateways_collection ] . count_documents ({}) == 0 assert test_data . exists () with open ( test_data ) as handle : data = json . load ( handle ) await MONGO_DB [ CONFIG . gateways_collection ] . insert_many ( data ) load_optimade_providers_databases () async \u00b6 Load in the providers' OPTIMADE databases from Materials-Consortia Utilize the Materials-Consortia list of OPTIMADE providers at https://providers.optimade.org . Load in all databases with a valid base URL. Source code in optimade_gateway/events.py async def load_optimade_providers_databases () -> None : \"\"\"Load in the providers' OPTIMADE databases from Materials-Consortia Utilize the Materials-Consortia list of OPTIMADE providers at [https://providers.optimade.org](https://providers.optimade.org). Load in all databases with a valid base URL. \"\"\" import asyncio import httpx from optimade import __api_version__ from optimade.models import LinksResponse from optimade.models.links import LinkType from optimade.server.routers.utils import BASE_URL_PREFIXES from optimade_gateway.common.utils import clean_python_types , get_resource_attribute from optimade_gateway.models.databases import DatabaseCreate from optimade_gateway.queries.perform import db_get_all_resources from optimade_gateway.routers.utils import resource_factory if not CONFIG . load_optimade_providers_databases : LOGGER . debug ( \"Will not load databases from Materials-Consortia list of providers.\" ) return async with httpx . AsyncClient () as client : providers = await client . get ( f \"https://providers.optimade.org/v { __api_version__ . split ( '.' )[ 0 ] } /links\" ) if providers . is_error : LOGGER . warning ( \"Response from Materials-Consortia's list of OPTIMADE providers was not successful \" \"(status code != 200). No databases will therefore be added at server startup.\" ) return LOGGER . info ( \"Registering Materials-Consortia list of OPTIMADE providers' databases.\" ) providers = LinksResponse ( ** providers . json ()) valid_providers = [] for provider in providers . data : if get_resource_attribute ( provider , \"id\" ) in ( \"exmpl\" , \"optimade\" ): LOGGER . info ( \"- %s (id= %r ) - Skipping: Not a real provider.\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) continue if not get_resource_attribute ( provider , \"attributes.base_url\" ): LOGGER . info ( \"- %s (id= %r ) - Skipping: No base URL information.\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) continue valid_providers . append ( provider ) # Run queries to each database using the supported major versioned base URL to get a list of # the provider's databases. # There is no need to use ThreadPoolExecutor here, since we want this to block everything and # then finish, before the server actually starts up. provider_queries = [ asyncio . create_task ( db_get_all_resources ( database = provider , endpoint = \"links\" , response_model = LinksResponse , ) ) for provider in valid_providers ] for query in asyncio . as_completed ( provider_queries ): provider_databases , provider = await query LOGGER . info ( \"- %s (id= %r ) - Processing\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) if not provider_databases : LOGGER . info ( \" - No OPTIMADE databases found.\" ) continue provider_databases = [ db for db in provider_databases if await clean_python_types ( get_resource_attribute ( db , \"attributes.link_type\" , \"\" ) ) == LinkType . CHILD . value ] if not provider_databases : LOGGER . info ( \" - No OPTIMADE databases found.\" ) continue for database in provider_databases : if not get_resource_attribute ( database , \"attributes.base_url\" ): LOGGER . info ( \" - %s (id= %r ) - Skipping: No base URL information.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), ) continue LOGGER . info ( \" - %s (id= %r ) - Checking versioned base URL and /structures\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), ) async with httpx . AsyncClient () as client : try : db_response = await client . get ( f \" { str ( get_resource_attribute ( database , 'attributes.base_url' )) . rstrip ( '/' ) }{ BASE_URL_PREFIXES [ 'major' ] } /structures\" , ) except httpx . ReadTimeout : LOGGER . info ( \" - %s (id= %r ) - Skipping: Timeout while requesting %s /structures.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), BASE_URL_PREFIXES [ \"major\" ], ) continue if db_response . status_code != 200 : LOGGER . info ( \" - %s (id= %r ) - Skipping: Response from %s /structures is not 200 OK.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), BASE_URL_PREFIXES [ \"major\" ], ) continue new_id = ( f \" { get_resource_attribute ( provider , 'id' ) } / { get_resource_attribute ( database , 'id' ) } \" if len ( provider_databases ) > 1 else get_resource_attribute ( database , \"id\" ) ) registered_database , _ = await resource_factory ( DatabaseCreate ( id = new_id , ** await clean_python_types ( get_resource_attribute ( database , \"attributes\" , {}) ), ) ) LOGGER . info ( \" - %s (id= %r ) - Registered database with id= %r \" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), registered_database . id , )","title":"events"},{"location":"api_reference/events/#events","text":"","title":"events"},{"location":"api_reference/events/#optimade_gateway.events.EVENTS","text":"A tuple of all pairs of events and event functions. To use this tuple of tuples: from fastapi import FastAPI APP = FastAPI () for event , func in EVENTS : APP . add_event_handler ( event , func )","title":"EVENTS"},{"location":"api_reference/events/#optimade_gateway.events.ci_dev_startup","text":"Function to run at app startup - only relevant for CI or development to add test data Source code in optimade_gateway/events.py async def ci_dev_startup () -> None : \"\"\"Function to run at app startup - only relevant for CI or development to add test data\"\"\" import os if bool ( os . getenv ( \"CI\" , False )): LOGGER . info ( \"CI detected - Will load test gateways (after dropping the collection)!\" ) elif os . getenv ( \"OPTIMADE_MONGO_DATABASE\" , \"\" ) == \"optimade_gateway_dev\" : LOGGER . info ( \"Running in development mode - Will load test gateways (after dropping the collection)!\" ) else : LOGGER . debug ( \"Not in CI or development mode - will start normally.\" ) return # Add test gateways import json from optimade_gateway.mongo.database import MONGO_DB from pathlib import Path test_data = ( Path ( __file__ ) . parent . parent . joinpath ( \".ci/test_gateways.json\" ) . resolve () ) await MONGO_DB [ CONFIG . gateways_collection ] . drop () assert await MONGO_DB [ CONFIG . gateways_collection ] . count_documents ({}) == 0 assert test_data . exists () with open ( test_data ) as handle : data = json . load ( handle ) await MONGO_DB [ CONFIG . gateways_collection ] . insert_many ( data )","title":"ci_dev_startup()"},{"location":"api_reference/events/#optimade_gateway.events.load_optimade_providers_databases","text":"Load in the providers' OPTIMADE databases from Materials-Consortia Utilize the Materials-Consortia list of OPTIMADE providers at https://providers.optimade.org . Load in all databases with a valid base URL. Source code in optimade_gateway/events.py async def load_optimade_providers_databases () -> None : \"\"\"Load in the providers' OPTIMADE databases from Materials-Consortia Utilize the Materials-Consortia list of OPTIMADE providers at [https://providers.optimade.org](https://providers.optimade.org). Load in all databases with a valid base URL. \"\"\" import asyncio import httpx from optimade import __api_version__ from optimade.models import LinksResponse from optimade.models.links import LinkType from optimade.server.routers.utils import BASE_URL_PREFIXES from optimade_gateway.common.utils import clean_python_types , get_resource_attribute from optimade_gateway.models.databases import DatabaseCreate from optimade_gateway.queries.perform import db_get_all_resources from optimade_gateway.routers.utils import resource_factory if not CONFIG . load_optimade_providers_databases : LOGGER . debug ( \"Will not load databases from Materials-Consortia list of providers.\" ) return async with httpx . AsyncClient () as client : providers = await client . get ( f \"https://providers.optimade.org/v { __api_version__ . split ( '.' )[ 0 ] } /links\" ) if providers . is_error : LOGGER . warning ( \"Response from Materials-Consortia's list of OPTIMADE providers was not successful \" \"(status code != 200). No databases will therefore be added at server startup.\" ) return LOGGER . info ( \"Registering Materials-Consortia list of OPTIMADE providers' databases.\" ) providers = LinksResponse ( ** providers . json ()) valid_providers = [] for provider in providers . data : if get_resource_attribute ( provider , \"id\" ) in ( \"exmpl\" , \"optimade\" ): LOGGER . info ( \"- %s (id= %r ) - Skipping: Not a real provider.\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) continue if not get_resource_attribute ( provider , \"attributes.base_url\" ): LOGGER . info ( \"- %s (id= %r ) - Skipping: No base URL information.\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) continue valid_providers . append ( provider ) # Run queries to each database using the supported major versioned base URL to get a list of # the provider's databases. # There is no need to use ThreadPoolExecutor here, since we want this to block everything and # then finish, before the server actually starts up. provider_queries = [ asyncio . create_task ( db_get_all_resources ( database = provider , endpoint = \"links\" , response_model = LinksResponse , ) ) for provider in valid_providers ] for query in asyncio . as_completed ( provider_queries ): provider_databases , provider = await query LOGGER . info ( \"- %s (id= %r ) - Processing\" , get_resource_attribute ( provider , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( provider , \"id\" ), ) if not provider_databases : LOGGER . info ( \" - No OPTIMADE databases found.\" ) continue provider_databases = [ db for db in provider_databases if await clean_python_types ( get_resource_attribute ( db , \"attributes.link_type\" , \"\" ) ) == LinkType . CHILD . value ] if not provider_databases : LOGGER . info ( \" - No OPTIMADE databases found.\" ) continue for database in provider_databases : if not get_resource_attribute ( database , \"attributes.base_url\" ): LOGGER . info ( \" - %s (id= %r ) - Skipping: No base URL information.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), ) continue LOGGER . info ( \" - %s (id= %r ) - Checking versioned base URL and /structures\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), ) async with httpx . AsyncClient () as client : try : db_response = await client . get ( f \" { str ( get_resource_attribute ( database , 'attributes.base_url' )) . rstrip ( '/' ) }{ BASE_URL_PREFIXES [ 'major' ] } /structures\" , ) except httpx . ReadTimeout : LOGGER . info ( \" - %s (id= %r ) - Skipping: Timeout while requesting %s /structures.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), BASE_URL_PREFIXES [ \"major\" ], ) continue if db_response . status_code != 200 : LOGGER . info ( \" - %s (id= %r ) - Skipping: Response from %s /structures is not 200 OK.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), BASE_URL_PREFIXES [ \"major\" ], ) continue new_id = ( f \" { get_resource_attribute ( provider , 'id' ) } / { get_resource_attribute ( database , 'id' ) } \" if len ( provider_databases ) > 1 else get_resource_attribute ( database , \"id\" ) ) registered_database , _ = await resource_factory ( DatabaseCreate ( id = new_id , ** await clean_python_types ( get_resource_attribute ( database , \"attributes\" , {}) ), ) ) LOGGER . info ( \" - %s (id= %r ) - Registered database with id= %r \" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), registered_database . id , )","title":"load_optimade_providers_databases()"},{"location":"api_reference/exception_handlers/","text":"exception_handlers \u00b6 request_validation_exception_handler ( request , exc ) async \u00b6 Special handler if a RequestValidationError comes from wrong POST data Source code in optimade_gateway/exception_handlers.py async def request_validation_exception_handler ( request : Request , exc : RequestValidationError ) -> JSONResponse : \"\"\"Special handler if a `RequestValidationError` comes from wrong `POST` data\"\"\" status_code = 500 if request . method in ( \"POST\" , \"post\" ): status_code = 400 errors = set () for error in exc . errors (): pointer = \"/\" + \"/\" . join ([ str ( _ ) for _ in error [ \"loc\" ]]) source = ErrorSource ( pointer = pointer ) code = error [ \"type\" ] detail = error [ \"msg\" ] errors . add ( OptimadeError ( detail = detail , status = status_code , title = str ( exc . __class__ . __name__ ), source = source , code = code , ) ) return general_exception ( request , exc , status_code = status_code , errors = list ( errors ))","title":"exception_handlers"},{"location":"api_reference/exception_handlers/#exception_handlers","text":"","title":"exception_handlers"},{"location":"api_reference/exception_handlers/#optimade_gateway.exception_handlers.request_validation_exception_handler","text":"Special handler if a RequestValidationError comes from wrong POST data Source code in optimade_gateway/exception_handlers.py async def request_validation_exception_handler ( request : Request , exc : RequestValidationError ) -> JSONResponse : \"\"\"Special handler if a `RequestValidationError` comes from wrong `POST` data\"\"\" status_code = 500 if request . method in ( \"POST\" , \"post\" ): status_code = 400 errors = set () for error in exc . errors (): pointer = \"/\" + \"/\" . join ([ str ( _ ) for _ in error [ \"loc\" ]]) source = ErrorSource ( pointer = pointer ) code = error [ \"type\" ] detail = error [ \"msg\" ] errors . add ( OptimadeError ( detail = detail , status = status_code , title = str ( exc . __class__ . __name__ ), source = source , code = code , ) ) return general_exception ( request , exc , status_code = status_code , errors = list ( errors ))","title":"request_validation_exception_handler()"},{"location":"api_reference/main/","text":"main \u00b6 APP \u00b6 The FastAPI ASGI application. get_root ( request ) async \u00b6 GET / Introspective overview of gateway server. Note Temporarily redirecting to GET /docs . Source code in optimade_gateway/main.py @APP . get ( \"/\" , include_in_schema = False ) async def get_root ( request : Request ) -> RedirectResponse : \"\"\"`GET /` Introspective overview of gateway server. !!! note Temporarily redirecting to `GET /docs`. \"\"\" return RedirectResponse ( request . url . replace ( path = f \" { request . url . path . strip ( '/' ) } /docs\" ) )","title":"main"},{"location":"api_reference/main/#main","text":"","title":"main"},{"location":"api_reference/main/#optimade_gateway.main.APP","text":"The FastAPI ASGI application.","title":"APP"},{"location":"api_reference/main/#optimade_gateway.main.get_root","text":"GET / Introspective overview of gateway server. Note Temporarily redirecting to GET /docs . Source code in optimade_gateway/main.py @APP . get ( \"/\" , include_in_schema = False ) async def get_root ( request : Request ) -> RedirectResponse : \"\"\"`GET /` Introspective overview of gateway server. !!! note Temporarily redirecting to `GET /docs`. \"\"\" return RedirectResponse ( request . url . replace ( path = f \" { request . url . path . strip ( '/' ) } /docs\" ) )","title":"get_root()"},{"location":"api_reference/middleware/","text":"middleware \u00b6 CheckWronglyVersionedBaseUrlsGateways \u00b6 If a non-supported versioned base URL is supplied to a gateway return 553 Version Not Supported . check_url ( url ) async staticmethod \u00b6 Check URL path for versioned part. Parameters: Name Type Description Default url URL A complete urllib -parsed raw URL. required Exceptions: Type Description VersionNotSupported If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. Source code in optimade_gateway/middleware.py @staticmethod async def check_url ( url : URL ): \"\"\"Check URL path for versioned part. Parameters: url: A complete `urllib`-parsed raw URL. Raises: VersionNotSupported: If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. \"\"\" base_url = get_base_url ( url ) optimade_path = f \" { url . scheme } :// { url . netloc }{ url . path } \" [ len ( base_url ) :] match = re . match ( r \"^/gateways/[^/\\s]+(?P<version>/v[0-9]+(\\.[0-9]+){0,2}).*\" , optimade_path ) if match is not None : if match . group ( \"version\" ) not in BASE_URL_PREFIXES . values (): raise VersionNotSupported ( detail = ( f \"The parsed versioned base URL { match . group ( 'version' ) !r} from \" f \" { url } is not supported by this implementation. \" f \"Supported versioned base URLs are: { ', ' . join ( BASE_URL_PREFIXES . values ()) } \" ) )","title":"middleware"},{"location":"api_reference/middleware/#middleware","text":"","title":"middleware"},{"location":"api_reference/middleware/#optimade_gateway.middleware.CheckWronglyVersionedBaseUrlsGateways","text":"If a non-supported versioned base URL is supplied to a gateway return 553 Version Not Supported .","title":"CheckWronglyVersionedBaseUrlsGateways"},{"location":"api_reference/middleware/#optimade_gateway.middleware.CheckWronglyVersionedBaseUrlsGateways.check_url","text":"Check URL path for versioned part. Parameters: Name Type Description Default url URL A complete urllib -parsed raw URL. required Exceptions: Type Description VersionNotSupported If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. Source code in optimade_gateway/middleware.py @staticmethod async def check_url ( url : URL ): \"\"\"Check URL path for versioned part. Parameters: url: A complete `urllib`-parsed raw URL. Raises: VersionNotSupported: If the URL represents an OPTIMADE versioned base URL and the version part is not supported by the implementation. \"\"\" base_url = get_base_url ( url ) optimade_path = f \" { url . scheme } :// { url . netloc }{ url . path } \" [ len ( base_url ) :] match = re . match ( r \"^/gateways/[^/\\s]+(?P<version>/v[0-9]+(\\.[0-9]+){0,2}).*\" , optimade_path ) if match is not None : if match . group ( \"version\" ) not in BASE_URL_PREFIXES . values (): raise VersionNotSupported ( detail = ( f \"The parsed versioned base URL { match . group ( 'version' ) !r} from \" f \" { url } is not supported by this implementation. \" f \"Supported versioned base URLs are: { ', ' . join ( BASE_URL_PREFIXES . values ()) } \" ) )","title":"check_url()"},{"location":"api_reference/common/config/","text":"config \u00b6 Configuration of the FastAPI server ServerConfig pydantic-model \u00b6 This class stores server config parameters in a way that can be easily extended for new config file types. databases_collection : str pydantic-field \u00b6 Mongo collection name for /databases endpoint resources. gateways_collection : str pydantic-field \u00b6 Mongo collection name for /gateways endpoint resources. load_optimade_providers_databases : bool pydantic-field \u00b6 Whether or not to load all valid OPTIMADE providers' databases from the Materials-Consortia list of OPTIMADE providers on server startup. queries_collection : str pydantic-field \u00b6 Mongo collection name for /queries endpoint resources. replace_with_env_vars ( v ) classmethod \u00b6 Replace string variables with environment variables, if possible Source code in optimade_gateway/common/config.py @validator ( \"mongo_uri\" ) def replace_with_env_vars ( cls , v ): \"\"\"Replace string variables with environment variables, if possible\"\"\" res : str = v for match in re . finditer ( r \"\\{[^ {} ]+\\}\" , v ): string_var = match . group ()[ 1 : - 1 ] env_var = os . getenv ( string_var , os . getenv ( string_var . upper (), os . getenv ( string_var . lower ())) ) if env_var is not None : res = res . replace ( match . group (), env_var ) else : warnings . warn ( f \"Could not find an environment variable for { match . group () !r} from mongo_uri: { v } \" ) return res","title":"config"},{"location":"api_reference/common/config/#config","text":"Configuration of the FastAPI server","title":"config"},{"location":"api_reference/common/config/#optimade_gateway.common.config.ServerConfig","text":"This class stores server config parameters in a way that can be easily extended for new config file types.","title":"ServerConfig"},{"location":"api_reference/common/config/#optimade_gateway.common.config.ServerConfig.databases_collection","text":"Mongo collection name for /databases endpoint resources.","title":"databases_collection"},{"location":"api_reference/common/config/#optimade_gateway.common.config.ServerConfig.gateways_collection","text":"Mongo collection name for /gateways endpoint resources.","title":"gateways_collection"},{"location":"api_reference/common/config/#optimade_gateway.common.config.ServerConfig.load_optimade_providers_databases","text":"Whether or not to load all valid OPTIMADE providers' databases from the Materials-Consortia list of OPTIMADE providers on server startup.","title":"load_optimade_providers_databases"},{"location":"api_reference/common/config/#optimade_gateway.common.config.ServerConfig.queries_collection","text":"Mongo collection name for /queries endpoint resources.","title":"queries_collection"},{"location":"api_reference/common/config/#optimade_gateway.common.config.ServerConfig.replace_with_env_vars","text":"Replace string variables with environment variables, if possible Source code in optimade_gateway/common/config.py @validator ( \"mongo_uri\" ) def replace_with_env_vars ( cls , v ): \"\"\"Replace string variables with environment variables, if possible\"\"\" res : str = v for match in re . finditer ( r \"\\{[^ {} ]+\\}\" , v ): string_var = match . group ()[ 1 : - 1 ] env_var = os . getenv ( string_var , os . getenv ( string_var . upper (), os . getenv ( string_var . lower ())) ) if env_var is not None : res = res . replace ( match . group (), env_var ) else : warnings . warn ( f \"Could not find an environment variable for { match . group () !r} from mongo_uri: { v } \" ) return res","title":"replace_with_env_vars()"},{"location":"api_reference/common/exceptions/","text":"exceptions \u00b6 OptimadeGatewayError \u00b6 General OPTIMADE Gateway exception.","title":"exceptions"},{"location":"api_reference/common/exceptions/#exceptions","text":"","title":"exceptions"},{"location":"api_reference/common/exceptions/#optimade_gateway.common.exceptions.OptimadeGatewayError","text":"General OPTIMADE Gateway exception.","title":"OptimadeGatewayError"},{"location":"api_reference/common/logger/","text":"logger \u00b6 Logging to both file and console disable_logging () \u00b6 Temporarily disable logging. Usage: from optimade_gateway.common.logger import disable_logging # Do stuff, logging to all handlers. # ... with disable_logging (): # Do stuff, without logging to any handlers. # ... # Do stuff, logging to all handlers now re-enabled. # ... Source code in optimade_gateway/common/logger.py @contextmanager def disable_logging (): \"\"\"Temporarily disable logging. Usage: ```python from optimade_gateway.common.logger import disable_logging # Do stuff, logging to all handlers. # ... with disable_logging(): # Do stuff, without logging to any handlers. # ... # Do stuff, logging to all handlers now re-enabled. # ... ``` \"\"\" try : # Disable logging lower than CRITICAL level logging . disable ( logging . CRITICAL ) yield finally : # Re-enable logging to desired levels logging . disable ( logging . NOTSET )","title":"logger"},{"location":"api_reference/common/logger/#logger","text":"Logging to both file and console","title":"logger"},{"location":"api_reference/common/logger/#optimade_gateway.common.logger.disable_logging","text":"Temporarily disable logging. Usage: from optimade_gateway.common.logger import disable_logging # Do stuff, logging to all handlers. # ... with disable_logging (): # Do stuff, without logging to any handlers. # ... # Do stuff, logging to all handlers now re-enabled. # ... Source code in optimade_gateway/common/logger.py @contextmanager def disable_logging (): \"\"\"Temporarily disable logging. Usage: ```python from optimade_gateway.common.logger import disable_logging # Do stuff, logging to all handlers. # ... with disable_logging(): # Do stuff, without logging to any handlers. # ... # Do stuff, logging to all handlers now re-enabled. # ... ``` \"\"\" try : # Disable logging lower than CRITICAL level logging . disable ( logging . CRITICAL ) yield finally : # Re-enable logging to desired levels logging . disable ( logging . NOTSET )","title":"disable_logging()"},{"location":"api_reference/common/utils/","text":"utils \u00b6 clean_python_types ( data ) async \u00b6 Turn any types into MongoDB-friendly Python types. Use dict() method for Pydantic models. Use value property for Enums. Turn tuples and sets into lists. Source code in optimade_gateway/common/utils.py async def clean_python_types ( data : Any ) -> Any : \"\"\"Turn any types into MongoDB-friendly Python types. Use `dict()` method for Pydantic models. Use `value` property for Enums. Turn tuples and sets into lists. \"\"\" if isinstance ( data , ( list , tuple , set )): res = [] for datum in data : res . append ( await clean_python_types ( datum )) elif isinstance ( data , dict ): res = {} for key in list ( data . keys ()): res [ key ] = await clean_python_types ( data [ key ]) elif isinstance ( data , BaseModel ): # Pydantic model res = await clean_python_types ( data . dict ()) elif isinstance ( data , Enum ): res = await clean_python_types ( data . value ) elif isinstance ( data , type ): res = await clean_python_types ( f \" { data . __module__ } . { data . __name__ } \" ) else : # Unknown or other basic type, e.g., str, int, etc. res = data return res get_resource_attribute ( resource , field , default = None , disambiguate = True ) \u00b6 Return a resource's field's value Get the field value no matter if the resource is a pydantic model or a Python dictionary. Determine ambiguous field values and return them if desired ( disambiguate ). For example, if \"attributes.base_url\" is requested for a LinksResource it can be either a string, a Link model or a dictionary resembling the Link model. Parameters: Name Type Description Default resource Union[pydantic.main.BaseModel, Dict[str, Any]] The resource, from which to get the field value. required field str The resource field. This can be a comma-separated nested field, e.g., \"attributes.base_url\" . required default Any The default value to return if field does not exist. None disambiguate bool Whether or not to \"shortcut\" a field value. For example, for attributes.base_url , if True , this would return the string value or the value of it's \"href\" key. True Returns: Type Description Any The resource's field's value. Source code in optimade_gateway/common/utils.py def get_resource_attribute ( resource : Union [ BaseModel , Dict [ str , Any ]], field : str , default : Any = None , disambiguate : bool = True , ) -> Any : \"\"\"Return a resource's field's value Get the field value no matter if the resource is a pydantic model or a Python dictionary. Determine ambiguous field values and return them if desired (`disambiguate`). For example, if [`\"attributes.base_url\"`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResourceAttributes.base_url) is requested for a [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) it can be either a string, a [`Link`](https://www.optimade.org/optimade-python-tools/api_reference/models/jsonapi/#optimade.models.jsonapi.Link) model or a dictionary resembling the `Link` model. Parameters: resource: The resource, from which to get the field value. field: The resource field. This can be a comma-separated nested field, e.g., `\"attributes.base_url\"`. default: The default value to return if `field` does not exist. disambiguate: Whether or not to \"shortcut\" a field value. For example, for `attributes.base_url`, if `True`, this would return the string value or the value of it's `\"href\"` key. Returns: The resource's field's value. \"\"\" if isinstance ( resource , BaseModel ): _get_attr = getattr elif isinstance ( resource , dict ): def _get_attr ( mapping : dict , key : str , default : Any ) -> Any : return mapping . get ( key , default ) else : raise TypeError ( \"resource must be either a pydantic model or a Python dictionary, it was of type \" f \" { type ( resource ) !r} \" ) fields = field . split ( \".\" ) for field in fields [: - 1 ]: resource = _get_attr ( resource , field , {}) field = fields [ - 1 ] value = _get_attr ( resource , field , default ) if disambiguate : if field in ( \"base_url\" , \"next\" , \"prev\" , \"last\" , \"first\" ): if not isinstance ( value , str ): value = _get_attr ( value , \"href\" , default ) return value","title":"utils"},{"location":"api_reference/common/utils/#utils","text":"","title":"utils"},{"location":"api_reference/common/utils/#optimade_gateway.common.utils.clean_python_types","text":"Turn any types into MongoDB-friendly Python types. Use dict() method for Pydantic models. Use value property for Enums. Turn tuples and sets into lists. Source code in optimade_gateway/common/utils.py async def clean_python_types ( data : Any ) -> Any : \"\"\"Turn any types into MongoDB-friendly Python types. Use `dict()` method for Pydantic models. Use `value` property for Enums. Turn tuples and sets into lists. \"\"\" if isinstance ( data , ( list , tuple , set )): res = [] for datum in data : res . append ( await clean_python_types ( datum )) elif isinstance ( data , dict ): res = {} for key in list ( data . keys ()): res [ key ] = await clean_python_types ( data [ key ]) elif isinstance ( data , BaseModel ): # Pydantic model res = await clean_python_types ( data . dict ()) elif isinstance ( data , Enum ): res = await clean_python_types ( data . value ) elif isinstance ( data , type ): res = await clean_python_types ( f \" { data . __module__ } . { data . __name__ } \" ) else : # Unknown or other basic type, e.g., str, int, etc. res = data return res","title":"clean_python_types()"},{"location":"api_reference/common/utils/#optimade_gateway.common.utils.get_resource_attribute","text":"Return a resource's field's value Get the field value no matter if the resource is a pydantic model or a Python dictionary. Determine ambiguous field values and return them if desired ( disambiguate ). For example, if \"attributes.base_url\" is requested for a LinksResource it can be either a string, a Link model or a dictionary resembling the Link model. Parameters: Name Type Description Default resource Union[pydantic.main.BaseModel, Dict[str, Any]] The resource, from which to get the field value. required field str The resource field. This can be a comma-separated nested field, e.g., \"attributes.base_url\" . required default Any The default value to return if field does not exist. None disambiguate bool Whether or not to \"shortcut\" a field value. For example, for attributes.base_url , if True , this would return the string value or the value of it's \"href\" key. True Returns: Type Description Any The resource's field's value. Source code in optimade_gateway/common/utils.py def get_resource_attribute ( resource : Union [ BaseModel , Dict [ str , Any ]], field : str , default : Any = None , disambiguate : bool = True , ) -> Any : \"\"\"Return a resource's field's value Get the field value no matter if the resource is a pydantic model or a Python dictionary. Determine ambiguous field values and return them if desired (`disambiguate`). For example, if [`\"attributes.base_url\"`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResourceAttributes.base_url) is requested for a [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) it can be either a string, a [`Link`](https://www.optimade.org/optimade-python-tools/api_reference/models/jsonapi/#optimade.models.jsonapi.Link) model or a dictionary resembling the `Link` model. Parameters: resource: The resource, from which to get the field value. field: The resource field. This can be a comma-separated nested field, e.g., `\"attributes.base_url\"`. default: The default value to return if `field` does not exist. disambiguate: Whether or not to \"shortcut\" a field value. For example, for `attributes.base_url`, if `True`, this would return the string value or the value of it's `\"href\"` key. Returns: The resource's field's value. \"\"\" if isinstance ( resource , BaseModel ): _get_attr = getattr elif isinstance ( resource , dict ): def _get_attr ( mapping : dict , key : str , default : Any ) -> Any : return mapping . get ( key , default ) else : raise TypeError ( \"resource must be either a pydantic model or a Python dictionary, it was of type \" f \" { type ( resource ) !r} \" ) fields = field . split ( \".\" ) for field in fields [: - 1 ]: resource = _get_attr ( resource , field , {}) field = fields [ - 1 ] value = _get_attr ( resource , field , default ) if disambiguate : if field in ( \"base_url\" , \"next\" , \"prev\" , \"last\" , \"first\" ): if not isinstance ( value , str ): value = _get_attr ( value , \"href\" , default ) return value","title":"get_resource_attribute()"},{"location":"api_reference/mappers/databases/","text":"databases \u00b6 DatabasesMapper \u00b6 map_back ( doc ) classmethod \u00b6 Map properties from MongoDB to OPTIMADE :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict Source code in optimade_gateway/mappers/databases.py @classmethod def map_back ( cls , doc : dict ) -> dict : from optimade.server.routers.utils import BASE_URL_PREFIXES if \"_id\" in doc : _id = str ( doc . pop ( \"_id\" )) if \"id\" not in doc : doc [ \"id\" ] = _id doc [ \"links\" ] = { \"self\" : AnyUrl ( url = f \" { CONFIG . base_url . strip ( '/' ) }{ BASE_URL_PREFIXES [ 'major' ] } / { cls . ENDPOINT } / { doc [ 'id' ] } \" , scheme = CONFIG . base_url . split ( \"://\" )[ 0 ], host = CONFIG . base_url . split ( \"://\" )[ 1 ] . split ( \"/\" )[ 0 ], ) } # Ensure the type does not change to \"databases\" # The `LinksMapper.map_back()` method ensures the value for doc[\"type\"] is kept. doc [ \"type\" ] = \"links\" return super () . map_back ( doc )","title":"databases"},{"location":"api_reference/mappers/databases/#databases","text":"","title":"databases"},{"location":"api_reference/mappers/databases/#optimade_gateway.mappers.databases.DatabasesMapper","text":"","title":"DatabasesMapper"},{"location":"api_reference/mappers/databases/#optimade_gateway.mappers.databases.DatabasesMapper.map_back","text":"Map properties from MongoDB to OPTIMADE :param doc: A resource object in MongoDB format :type doc: dict :return: A resource object in OPTIMADE format :rtype: dict Source code in optimade_gateway/mappers/databases.py @classmethod def map_back ( cls , doc : dict ) -> dict : from optimade.server.routers.utils import BASE_URL_PREFIXES if \"_id\" in doc : _id = str ( doc . pop ( \"_id\" )) if \"id\" not in doc : doc [ \"id\" ] = _id doc [ \"links\" ] = { \"self\" : AnyUrl ( url = f \" { CONFIG . base_url . strip ( '/' ) }{ BASE_URL_PREFIXES [ 'major' ] } / { cls . ENDPOINT } / { doc [ 'id' ] } \" , scheme = CONFIG . base_url . split ( \"://\" )[ 0 ], host = CONFIG . base_url . split ( \"://\" )[ 1 ] . split ( \"/\" )[ 0 ], ) } # Ensure the type does not change to \"databases\" # The `LinksMapper.map_back()` method ensures the value for doc[\"type\"] is kept. doc [ \"type\" ] = \"links\" return super () . map_back ( doc )","title":"map_back()"},{"location":"api_reference/mappers/gateways/","text":"gateways \u00b6 GatewaysMapper \u00b6 map_back ( doc ) classmethod \u00b6 Map properties from MongoDB to OPTIMADE. Starting from a MongoDB document doc , map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS . All fields not in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS + \"attributes\" will be removed. Finally, the type is given the value of the specified cls.ENDPOINT . Parameters: Name Type Description Default doc dict A resource object in MongoDB format. required Returns: Type Description dict A resource object in OPTIMADE format. Source code in optimade_gateway/mappers/gateways.py @classmethod def map_back ( cls , doc : dict ) -> dict : from optimade.server.routers.utils import BASE_URL_PREFIXES if \"_id\" in doc : _id = str ( doc . pop ( \"_id\" )) if \"id\" not in doc : doc [ \"id\" ] = _id doc [ \"links\" ] = { \"self\" : AnyUrl ( url = f \" { CONFIG . base_url . strip ( '/' ) }{ BASE_URL_PREFIXES [ 'major' ] } / { cls . ENDPOINT } / { doc [ 'id' ] } \" , scheme = CONFIG . base_url . split ( \"://\" )[ 0 ], host = CONFIG . base_url . split ( \"://\" )[ 1 ] . split ( \"/\" )[ 0 ], ) } return super () . map_back ( doc )","title":"gateways"},{"location":"api_reference/mappers/gateways/#gateways","text":"","title":"gateways"},{"location":"api_reference/mappers/gateways/#optimade_gateway.mappers.gateways.GatewaysMapper","text":"","title":"GatewaysMapper"},{"location":"api_reference/mappers/gateways/#optimade_gateway.mappers.gateways.GatewaysMapper.map_back","text":"Map properties from MongoDB to OPTIMADE. Starting from a MongoDB document doc , map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS . All fields not in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS + \"attributes\" will be removed. Finally, the type is given the value of the specified cls.ENDPOINT . Parameters: Name Type Description Default doc dict A resource object in MongoDB format. required Returns: Type Description dict A resource object in OPTIMADE format. Source code in optimade_gateway/mappers/gateways.py @classmethod def map_back ( cls , doc : dict ) -> dict : from optimade.server.routers.utils import BASE_URL_PREFIXES if \"_id\" in doc : _id = str ( doc . pop ( \"_id\" )) if \"id\" not in doc : doc [ \"id\" ] = _id doc [ \"links\" ] = { \"self\" : AnyUrl ( url = f \" { CONFIG . base_url . strip ( '/' ) }{ BASE_URL_PREFIXES [ 'major' ] } / { cls . ENDPOINT } / { doc [ 'id' ] } \" , scheme = CONFIG . base_url . split ( \"://\" )[ 0 ], host = CONFIG . base_url . split ( \"://\" )[ 1 ] . split ( \"/\" )[ 0 ], ) } return super () . map_back ( doc )","title":"map_back()"},{"location":"api_reference/mappers/queries/","text":"queries \u00b6 QueryMapper \u00b6 map_back ( doc ) classmethod \u00b6 Map properties from MongoDB to OPTIMADE. Starting from a MongoDB document doc , map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS . All fields not in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS + \"attributes\" will be removed. Finally, the type is given the value of the specified cls.ENDPOINT . Parameters: Name Type Description Default doc dict A resource object in MongoDB format. required Returns: Type Description dict A resource object in OPTIMADE format. Source code in optimade_gateway/mappers/queries.py @classmethod def map_back ( cls , doc : dict ) -> dict : from optimade.server.routers.utils import BASE_URL_PREFIXES if \"_id\" in doc : _id = str ( doc . pop ( \"_id\" )) if \"id\" not in doc : doc [ \"id\" ] = _id doc [ \"links\" ] = { \"self\" : AnyUrl ( url = f \" { CONFIG . base_url . strip ( '/' ) }{ BASE_URL_PREFIXES [ 'major' ] } / { cls . ENDPOINT } / { doc [ 'id' ] } \" , scheme = CONFIG . base_url . split ( \"://\" )[ 0 ], host = CONFIG . base_url . split ( \"://\" )[ 1 ] . split ( \"/\" )[ 0 ], ) } return super () . map_back ( doc )","title":"queries"},{"location":"api_reference/mappers/queries/#queries","text":"","title":"queries"},{"location":"api_reference/mappers/queries/#optimade_gateway.mappers.queries.QueryMapper","text":"","title":"QueryMapper"},{"location":"api_reference/mappers/queries/#optimade_gateway.mappers.queries.QueryMapper.map_back","text":"Map properties from MongoDB to OPTIMADE. Starting from a MongoDB document doc , map the DB fields to the corresponding OPTIMADE fields. Then, the fields are all added to the top-level field \"attributes\", with the exception of other top-level fields, defined in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS . All fields not in cls.TOP_LEVEL_NON_ATTRIBUTES_FIELDS + \"attributes\" will be removed. Finally, the type is given the value of the specified cls.ENDPOINT . Parameters: Name Type Description Default doc dict A resource object in MongoDB format. required Returns: Type Description dict A resource object in OPTIMADE format. Source code in optimade_gateway/mappers/queries.py @classmethod def map_back ( cls , doc : dict ) -> dict : from optimade.server.routers.utils import BASE_URL_PREFIXES if \"_id\" in doc : _id = str ( doc . pop ( \"_id\" )) if \"id\" not in doc : doc [ \"id\" ] = _id doc [ \"links\" ] = { \"self\" : AnyUrl ( url = f \" { CONFIG . base_url . strip ( '/' ) }{ BASE_URL_PREFIXES [ 'major' ] } / { cls . ENDPOINT } / { doc [ 'id' ] } \" , scheme = CONFIG . base_url . split ( \"://\" )[ 0 ], host = CONFIG . base_url . split ( \"://\" )[ 1 ] . split ( \"/\" )[ 0 ], ) } return super () . map_back ( doc )","title":"map_back()"},{"location":"api_reference/models/databases/","text":"databases \u00b6 Pydantic models/schemas for the LinksResource used in /databases DatabaseCreate pydantic-model \u00b6 Model for creating new LinksResources representing /databases resources in the MongoDB Required fields: name base_url Original required fields for a LinksResourceAttributes model: name description link_type ensure_database_link_type ( value ) classmethod \u00b6 Ensure databases are not index meta-database-only types I.e., ensure they're not of type \"root\" or \"providers\" . Note Both \"external\" and \"child\" can still represent index meta-dbs, but \"root\" and \"providers\" can not represent \"regular\" dbs. Source code in optimade_gateway/models/databases.py @validator ( \"link_type\" ) def ensure_database_link_type ( cls , value ) -> LinkType : \"\"\"Ensure databases are not index meta-database-only types I.e., ensure they're not of type `\"root\"` or `\"providers\"`. !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for gateway-usable \" f \"database resources. Given link_type: { value } \" ) return value","title":"databases"},{"location":"api_reference/models/databases/#databases","text":"Pydantic models/schemas for the LinksResource used in /databases","title":"databases"},{"location":"api_reference/models/databases/#optimade_gateway.models.databases.DatabaseCreate","text":"Model for creating new LinksResources representing /databases resources in the MongoDB Required fields: name base_url Original required fields for a LinksResourceAttributes model: name description link_type","title":"DatabaseCreate"},{"location":"api_reference/models/databases/#optimade_gateway.models.databases.DatabaseCreate.ensure_database_link_type","text":"Ensure databases are not index meta-database-only types I.e., ensure they're not of type \"root\" or \"providers\" . Note Both \"external\" and \"child\" can still represent index meta-dbs, but \"root\" and \"providers\" can not represent \"regular\" dbs. Source code in optimade_gateway/models/databases.py @validator ( \"link_type\" ) def ensure_database_link_type ( cls , value ) -> LinkType : \"\"\"Ensure databases are not index meta-database-only types I.e., ensure they're not of type `\"root\"` or `\"providers\"`. !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for gateway-usable \" f \"database resources. Given link_type: { value } \" ) return value","title":"ensure_database_link_type()"},{"location":"api_reference/models/gateways/","text":"gateways \u00b6 Pydantic models/schemas for the Gateways resource GatewayCreate pydantic-model \u00b6 Model for creating new Gateway resources in the MongoDB database_ids : Set [ str ] pydantic-field \u00b6 A unique list of database IDs for registered databases. specify_databases ( values ) classmethod \u00b6 Either database_ids or databases must be non-empty Source code in optimade_gateway/models/gateways.py @root_validator def specify_databases ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `databases` must be non-empty\"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"databases\" )): raise ValueError ( \"Either 'database_ids' or 'databases' MUST be specified\" ) return values GatewayResource pydantic-model \u00b6 OPTIMADE gateway A resource representing a dynamic collection of OPTIMADE databases. The gateway can be treated as any other OPTIMADE gateway, but the entries are an aggregate of multiple databases. The id of each aggregated resource will reflect the originating database. GatewayResourceAttributes pydantic-model \u00b6 Attributes for an OPTIMADE gateway databases : List [ optimade . models . links . LinksResource ] pydantic-field required \u00b6 List of databases (OPTIMADE 'links') to be queried in this gateway. no_index_databases ( value ) classmethod \u00b6 Ensure databases are not of type \"root\" or \"providers\" Note Both \"external\" and \"child\" can still represent index meta-dbs, but \"root\" and \"providers\" can not represent \"regular\" dbs. Source code in optimade_gateway/models/gateways.py @validator ( \"databases\" , each_item = True ) def no_index_databases ( cls , value : LinksResource ) -> LinksResource : \"\"\"Ensure databases are not of type `\"root\"` or `\"providers\"` !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value . attributes . link_type in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for gateway \" f \"resources. Given database: { value } \" ) return value unique_base_urls ( value ) classmethod \u00b6 Remove extra entries with repeated base_urls Source code in optimade_gateway/models/gateways.py @validator ( \"databases\" ) def unique_base_urls ( cls , value : List [ LinksResource ]) -> List [ LinksResource ]: \"\"\"Remove extra entries with repeated base_urls\"\"\" db_base_urls = [ _ . attributes . base_url for _ in value ] unique_base_urls = set ( db_base_urls ) if len ( db_base_urls ) == len ( unique_base_urls ): return value repeated_base_urls = [ _ for _ in unique_base_urls if db_base_urls . count ( _ ) > 1 ] new_databases = [ _ for _ in value if _ . attributes . base_url not in repeated_base_urls ] for base_url in repeated_base_urls : new_databases . append ( [ _ for _ in value if _ . attributes . base_url == base_url ][ 0 ] ) warnings . warn ( \"Removed extra database entries for a gateway, because the base_url was repeated. The \" \"first found database entry was kept, while the others were removed. Original number \" f \"of databases: { len ( value ) } . New number of databases: { len ( new_databases ) } Repeated \" \"base_urls (number of repeats): {} \" . format ( [ f \" { base_url } ( { db_base_urls . count ( base_url ) } )\" for base_url in repeated_base_urls ] ) ) return new_databases","title":"gateways"},{"location":"api_reference/models/gateways/#gateways","text":"Pydantic models/schemas for the Gateways resource","title":"gateways"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayCreate","text":"Model for creating new Gateway resources in the MongoDB","title":"GatewayCreate"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayCreate.database_ids","text":"A unique list of database IDs for registered databases.","title":"database_ids"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayCreate.specify_databases","text":"Either database_ids or databases must be non-empty Source code in optimade_gateway/models/gateways.py @root_validator def specify_databases ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `databases` must be non-empty\"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"databases\" )): raise ValueError ( \"Either 'database_ids' or 'databases' MUST be specified\" ) return values","title":"specify_databases()"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResource","text":"OPTIMADE gateway A resource representing a dynamic collection of OPTIMADE databases. The gateway can be treated as any other OPTIMADE gateway, but the entries are an aggregate of multiple databases. The id of each aggregated resource will reflect the originating database.","title":"GatewayResource"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResourceAttributes","text":"Attributes for an OPTIMADE gateway","title":"GatewayResourceAttributes"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResourceAttributes.databases","text":"List of databases (OPTIMADE 'links') to be queried in this gateway.","title":"databases"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResourceAttributes.no_index_databases","text":"Ensure databases are not of type \"root\" or \"providers\" Note Both \"external\" and \"child\" can still represent index meta-dbs, but \"root\" and \"providers\" can not represent \"regular\" dbs. Source code in optimade_gateway/models/gateways.py @validator ( \"databases\" , each_item = True ) def no_index_databases ( cls , value : LinksResource ) -> LinksResource : \"\"\"Ensure databases are not of type `\"root\"` or `\"providers\"` !!! note Both `\"external\"` and `\"child\"` can still represent index meta-dbs, but `\"root\"` and `\"providers\"` can not represent \"regular\" dbs. \"\"\" if value . attributes . link_type in ( LinkType . ROOT , LinkType . PROVIDERS ): raise ValueError ( \"Databases with 'root' or 'providers' link_type is not allowed for gateway \" f \"resources. Given database: { value } \" ) return value","title":"no_index_databases()"},{"location":"api_reference/models/gateways/#optimade_gateway.models.gateways.GatewayResourceAttributes.unique_base_urls","text":"Remove extra entries with repeated base_urls Source code in optimade_gateway/models/gateways.py @validator ( \"databases\" ) def unique_base_urls ( cls , value : List [ LinksResource ]) -> List [ LinksResource ]: \"\"\"Remove extra entries with repeated base_urls\"\"\" db_base_urls = [ _ . attributes . base_url for _ in value ] unique_base_urls = set ( db_base_urls ) if len ( db_base_urls ) == len ( unique_base_urls ): return value repeated_base_urls = [ _ for _ in unique_base_urls if db_base_urls . count ( _ ) > 1 ] new_databases = [ _ for _ in value if _ . attributes . base_url not in repeated_base_urls ] for base_url in repeated_base_urls : new_databases . append ( [ _ for _ in value if _ . attributes . base_url == base_url ][ 0 ] ) warnings . warn ( \"Removed extra database entries for a gateway, because the base_url was repeated. The \" \"first found database entry was kept, while the others were removed. Original number \" f \"of databases: { len ( value ) } . New number of databases: { len ( new_databases ) } Repeated \" \"base_urls (number of repeats): {} \" . format ( [ f \" { base_url } ( { db_base_urls . count ( base_url ) } )\" for base_url in repeated_base_urls ] ) ) return new_databases","title":"unique_base_urls()"},{"location":"api_reference/models/queries/","text":"queries \u00b6 Pydantic models/schemas for the Queries resource QUERY_PARAMETERS \u00b6 Entry listing URL query parameters from the optimade package ( EntryListingQueryParams ). OptimadeQueryParameters pydantic-model \u00b6 Common OPTIMADE entry listing endpoint query parameters. email_address : EmailStr pydantic-field \u00b6 An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: http://example.com/v1/structures?email_address=user@example.com filter : str pydantic-field \u00b6 A filter string, in the format described in section API Filtering Format Specification of the specification. include : str pydantic-field \u00b6 A server MAY implement the JSON API concept of returning compound documents by utilizing the include query parameter as specified by JSON API 1.0 . All related resource objects MUST be returned as part of an array value for the top-level included field, see the section JSON Response Schema: Common Fields. The value of include MUST be a comma-separated list of \"relationship paths\", as defined in the JSON API . If relationship paths are not supported, or a server is unable to identify a relationship path a 400 Bad Request response MUST be made. The default value for include is references . This means references entries MUST always be included under the top-level field included as default, since a server assumes if include is not specified by a client in the request, it is still specified as include=references . Note, if a client explicitly specifies include and leaves out references , references resource objects MUST NOT be included under the top-level field included , as per the definition of included , see section JSON Response Schema: Common Fields. Note : A query with the parameter include set to the empty string means no related resource objects are to be returned under the top-level field included . page_above : ConstrainedIntValue pydantic-field \u00b6 RECOMMENDED for use with value-based pagination: using page_above / page_below and page_limit is RECOMMENDED. Example: Fetch up to 100 structures above sort-field value 4000 (in this example, server chooses to fetch results sorted by increasing id , so page_above value refers to an id value): /structures?page_above=4000&page_limit=100 . page_below : ConstrainedIntValue pydantic-field \u00b6 RECOMMENDED for use with value-based pagination: using page_above / page_below and page_limit is RECOMMENDED. page_cursor : ConstrainedIntValue pydantic-field \u00b6 RECOMMENDED for use with cursor-based pagination: using page_cursor and page_limit is RECOMMENDED. page_limit : ConstrainedIntValue pydantic-field \u00b6 Sets a numerical limit on the number of entries returned. See JSON API 1.0 . The API implementation MUST return no more than the number specified. It MAY return fewer. The database MAY have a maximum limit and not accept larger numbers (in which case an error code -- 403 Forbidden -- MUST be returned). The default limit value is up to the API implementation to decide. Example: http://example.com/optimade/v1/structures?page_limit=100 page_number : ConstrainedIntValue pydantic-field \u00b6 RECOMMENDED for use with page-based pagination: using page_number and page_limit is RECOMMENDED. It is RECOMMENDED that the first page has number 1, i.e., that page_number is 1-based. Example: Fetch page 2 of up to 50 structures per page: /structures?page_number=2&page_limit=50 . page_offset : ConstrainedIntValue pydantic-field \u00b6 RECOMMENDED for use with offset-based pagination: using page_offset and page_limit is RECOMMENDED. Example: Skip 50 structures and fetch up to 100: /structures?page_offset=50&page_limit=100 . response_fields : ConstrainedStrValue pydantic-field \u00b6 A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: http://example.com/v1/structures?response_fields=last_modified,nsites response_format : str pydantic-field \u00b6 The output format requested (see section Response Format). Defaults to the format string 'json', which specifies the standard output format described in this specification. Example: http://example.com/v1/structures?response_format=xml sort : ConstrainedStrValue pydantic-field \u00b6 If supporting sortable queries, an implementation MUST use the sort query parameter with format as specified by JSON API 1.0 . An implementation MAY support multiple sort fields for a single query. If it does, it again MUST conform to the JSON API 1.0 specification. If an implementation supports sorting for an entry listing endpoint, then the /info/<entries> endpoint MUST include, for each field name <fieldname> in its data.properties.<fieldname> response value that can be used for sorting, the key sortable with value true . If a field name under an entry listing endpoint supporting sorting cannot be used for sorting, the server MUST either leave out the sortable key or set it equal to false for the specific field name. The set of field names, with sortable equal to true are allowed to be used in the \"sort fields\" list according to its definition in the JSON API 1.0 specification. The field sortable is in addition to each property description and other OPTIONAL fields. An example is shown in the section Entry Listing Info Endpoints. QueryCreate pydantic-model \u00b6 Model for creating new Query resources in the MongoDB QueryResource pydantic-model \u00b6 OPTIMADE query resource for a gateway QueryResourceAttributes pydantic-model \u00b6 Attributes for an OPTIMADE gateway query endpoint : str pydantic-field required \u00b6 The entry endpoint queried, e.g., 'structures'. endpoint_model : Tuple [ str , str ] pydantic-field required \u00b6 The full importable path to the pydantic response model class (not an instance of the class). It should be a tuple of the Python module and the Class name. gateway_id : str pydantic-field required \u00b6 The OPTIMADE gateway ID for this query. query_parameters : OptimadeQueryParameters pydantic-field required \u00b6 OPTIMADE query parameters for entry listing endpoints used for this query. response : Union [ optimade . models . responses . EntryResponseMany , optimade . models . responses . ErrorResponse ] pydantic-field \u00b6 Response from gateway query. state : QueryState pydantic-field \u00b6 Current state of Gateway Query. remove_endpoints_slashes ( value ) classmethod \u00b6 Remove prep-/appended slashes ( / ) Source code in optimade_gateway/models/queries.py @validator ( \"endpoint\" ) def remove_endpoints_slashes ( cls , value : str ) -> str : \"\"\"Remove prep-/appended slashes (`/`)\"\"\" org_value = value value = value . strip () while value . startswith ( \"/\" ): value = value [ 1 :] while value . endswith ( \"/\" ): value = value [: - 1 ] if not value : raise ValueError ( \"endpoint must not be an empty string or be prep-/appended with slashes (`/`). \" f \"Original value: { org_value !r} . Final value (after removing prep-/appended \" f \"slashes): { value !r} \" ) # Temporarily only allow queries to \"structures\" endpoints. if value != \"structures\" : raise NotImplementedError ( 'OPTIMADE Gateway temporarily only supports queries to \"structures\" endpoints, ' 'i.e.: endpoint=\"structures\"' ) return value QueryState \u00b6 Enumeration of possible states for a Gateway Query. The states are enumerated here in the expected evolvement. CREATED \u00b6 FINISHED \u00b6 IN_PROGRESS \u00b6 STARTED \u00b6","title":"queries"},{"location":"api_reference/models/queries/#queries","text":"Pydantic models/schemas for the Queries resource","title":"queries"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QUERY_PARAMETERS","text":"Entry listing URL query parameters from the optimade package ( EntryListingQueryParams ).","title":"QUERY_PARAMETERS"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters","text":"Common OPTIMADE entry listing endpoint query parameters.","title":"OptimadeQueryParameters"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.email_address","text":"An email address of the user making the request. The email SHOULD be that of a person and not an automatic system. Example: http://example.com/v1/structures?email_address=user@example.com","title":"email_address"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.filter","text":"A filter string, in the format described in section API Filtering Format Specification of the specification.","title":"filter"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.include","text":"A server MAY implement the JSON API concept of returning compound documents by utilizing the include query parameter as specified by JSON API 1.0 . All related resource objects MUST be returned as part of an array value for the top-level included field, see the section JSON Response Schema: Common Fields. The value of include MUST be a comma-separated list of \"relationship paths\", as defined in the JSON API . If relationship paths are not supported, or a server is unable to identify a relationship path a 400 Bad Request response MUST be made. The default value for include is references . This means references entries MUST always be included under the top-level field included as default, since a server assumes if include is not specified by a client in the request, it is still specified as include=references . Note, if a client explicitly specifies include and leaves out references , references resource objects MUST NOT be included under the top-level field included , as per the definition of included , see section JSON Response Schema: Common Fields. Note : A query with the parameter include set to the empty string means no related resource objects are to be returned under the top-level field included .","title":"include"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_above","text":"RECOMMENDED for use with value-based pagination: using page_above / page_below and page_limit is RECOMMENDED. Example: Fetch up to 100 structures above sort-field value 4000 (in this example, server chooses to fetch results sorted by increasing id , so page_above value refers to an id value): /structures?page_above=4000&page_limit=100 .","title":"page_above"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_below","text":"RECOMMENDED for use with value-based pagination: using page_above / page_below and page_limit is RECOMMENDED.","title":"page_below"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_cursor","text":"RECOMMENDED for use with cursor-based pagination: using page_cursor and page_limit is RECOMMENDED.","title":"page_cursor"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_limit","text":"Sets a numerical limit on the number of entries returned. See JSON API 1.0 . The API implementation MUST return no more than the number specified. It MAY return fewer. The database MAY have a maximum limit and not accept larger numbers (in which case an error code -- 403 Forbidden -- MUST be returned). The default limit value is up to the API implementation to decide. Example: http://example.com/optimade/v1/structures?page_limit=100","title":"page_limit"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_number","text":"RECOMMENDED for use with page-based pagination: using page_number and page_limit is RECOMMENDED. It is RECOMMENDED that the first page has number 1, i.e., that page_number is 1-based. Example: Fetch page 2 of up to 50 structures per page: /structures?page_number=2&page_limit=50 .","title":"page_number"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.page_offset","text":"RECOMMENDED for use with offset-based pagination: using page_offset and page_limit is RECOMMENDED. Example: Skip 50 structures and fetch up to 100: /structures?page_offset=50&page_limit=100 .","title":"page_offset"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.response_fields","text":"A comma-delimited set of fields to be provided in the output. If provided, these fields MUST be returned along with the REQUIRED fields. Other OPTIONAL fields MUST NOT be returned when this parameter is present. Example: http://example.com/v1/structures?response_fields=last_modified,nsites","title":"response_fields"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.response_format","text":"The output format requested (see section Response Format). Defaults to the format string 'json', which specifies the standard output format described in this specification. Example: http://example.com/v1/structures?response_format=xml","title":"response_format"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.OptimadeQueryParameters.sort","text":"If supporting sortable queries, an implementation MUST use the sort query parameter with format as specified by JSON API 1.0 . An implementation MAY support multiple sort fields for a single query. If it does, it again MUST conform to the JSON API 1.0 specification. If an implementation supports sorting for an entry listing endpoint, then the /info/<entries> endpoint MUST include, for each field name <fieldname> in its data.properties.<fieldname> response value that can be used for sorting, the key sortable with value true . If a field name under an entry listing endpoint supporting sorting cannot be used for sorting, the server MUST either leave out the sortable key or set it equal to false for the specific field name. The set of field names, with sortable equal to true are allowed to be used in the \"sort fields\" list according to its definition in the JSON API 1.0 specification. The field sortable is in addition to each property description and other OPTIONAL fields. An example is shown in the section Entry Listing Info Endpoints.","title":"sort"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryCreate","text":"Model for creating new Query resources in the MongoDB","title":"QueryCreate"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResource","text":"OPTIMADE query resource for a gateway","title":"QueryResource"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes","text":"Attributes for an OPTIMADE gateway query","title":"QueryResourceAttributes"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.endpoint","text":"The entry endpoint queried, e.g., 'structures'.","title":"endpoint"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.endpoint_model","text":"The full importable path to the pydantic response model class (not an instance of the class). It should be a tuple of the Python module and the Class name.","title":"endpoint_model"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.gateway_id","text":"The OPTIMADE gateway ID for this query.","title":"gateway_id"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.query_parameters","text":"OPTIMADE query parameters for entry listing endpoints used for this query.","title":"query_parameters"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.response","text":"Response from gateway query.","title":"response"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.state","text":"Current state of Gateway Query.","title":"state"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryResourceAttributes.remove_endpoints_slashes","text":"Remove prep-/appended slashes ( / ) Source code in optimade_gateway/models/queries.py @validator ( \"endpoint\" ) def remove_endpoints_slashes ( cls , value : str ) -> str : \"\"\"Remove prep-/appended slashes (`/`)\"\"\" org_value = value value = value . strip () while value . startswith ( \"/\" ): value = value [ 1 :] while value . endswith ( \"/\" ): value = value [: - 1 ] if not value : raise ValueError ( \"endpoint must not be an empty string or be prep-/appended with slashes (`/`). \" f \"Original value: { org_value !r} . Final value (after removing prep-/appended \" f \"slashes): { value !r} \" ) # Temporarily only allow queries to \"structures\" endpoints. if value != \"structures\" : raise NotImplementedError ( 'OPTIMADE Gateway temporarily only supports queries to \"structures\" endpoints, ' 'i.e.: endpoint=\"structures\"' ) return value","title":"remove_endpoints_slashes()"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryState","text":"Enumeration of possible states for a Gateway Query. The states are enumerated here in the expected evolvement.","title":"QueryState"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryState.CREATED","text":"","title":"CREATED"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryState.FINISHED","text":"","title":"FINISHED"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryState.IN_PROGRESS","text":"","title":"IN_PROGRESS"},{"location":"api_reference/models/queries/#optimade_gateway.models.queries.QueryState.STARTED","text":"","title":"STARTED"},{"location":"api_reference/models/resources/","text":"resources \u00b6 EntryResourceCreate pydantic-model \u00b6 Generic model for creating new entry resources in the MongoDB id : str pydantic-field \u00b6 Config \u00b6 __init__ ( self , ** data ) special \u00b6 Remove root_validator check_illegal_attributes_fields Source code in optimade_gateway/models/resources.py def __init__ ( self , ** data : Any ) -> None : \"\"\"Remove root_validator `check_illegal_attributes_fields`\"\"\" self . _remove_pre_root_validators () super () . __init__ ( ** data )","title":"resources"},{"location":"api_reference/models/resources/#resources","text":"","title":"resources"},{"location":"api_reference/models/resources/#optimade_gateway.models.resources.EntryResourceCreate","text":"Generic model for creating new entry resources in the MongoDB","title":"EntryResourceCreate"},{"location":"api_reference/models/resources/#optimade_gateway.models.resources.EntryResourceCreate.id","text":"","title":"id"},{"location":"api_reference/models/resources/#optimade_gateway.models.resources.EntryResourceCreate.Config","text":"","title":"Config"},{"location":"api_reference/models/resources/#optimade_gateway.models.resources.EntryResourceCreate.__init__","text":"Remove root_validator check_illegal_attributes_fields Source code in optimade_gateway/models/resources.py def __init__ ( self , ** data : Any ) -> None : \"\"\"Remove root_validator `check_illegal_attributes_fields`\"\"\" self . _remove_pre_root_validators () super () . __init__ ( ** data )","title":"__init__()"},{"location":"api_reference/models/responses/","text":"responses \u00b6 DatabasesResponse pydantic-model \u00b6 Successful response for GET /databases This model is essentially equal to LinksResponse with the exception of the `data\u00b4 field's description. DatabasesResponseSingle pydantic-model \u00b6 Successful response for POST /databases and GET /databases/{database_id} GatewaysResponse pydantic-model \u00b6 Successful response for GET /gateways GatewaysResponseSingle pydantic-model \u00b6 Successful response for POST /gateways and GET /gateways/{gateway_id} QueriesResponse pydantic-model \u00b6 Successful response for GET /gateways/{gateway_ID}/queries QueriesResponseSingle pydantic-model \u00b6 Successful response for POST /gateways/{gateway_ID}/queries and GET /gateways/{gateway_ID}/queries/{query_id}","title":"responses"},{"location":"api_reference/models/responses/#responses","text":"","title":"responses"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.DatabasesResponse","text":"Successful response for GET /databases This model is essentially equal to LinksResponse with the exception of the `data\u00b4 field's description.","title":"DatabasesResponse"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.DatabasesResponseSingle","text":"Successful response for POST /databases and GET /databases/{database_id}","title":"DatabasesResponseSingle"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.GatewaysResponse","text":"Successful response for GET /gateways","title":"GatewaysResponse"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.GatewaysResponseSingle","text":"Successful response for POST /gateways and GET /gateways/{gateway_id}","title":"GatewaysResponseSingle"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.QueriesResponse","text":"Successful response for GET /gateways/{gateway_ID}/queries","title":"QueriesResponse"},{"location":"api_reference/models/responses/#optimade_gateway.models.responses.QueriesResponseSingle","text":"Successful response for POST /gateways/{gateway_ID}/queries and GET /gateways/{gateway_ID}/queries/{query_id}","title":"QueriesResponseSingle"},{"location":"api_reference/models/search/","text":"search \u00b6 Search pydantic-model \u00b6 A general coordinated OPTIMADE search Important Either database_ids or optimade_urls MUST be specified. database_ids : Set [ str ] pydantic-field \u00b6 A list of registered database IDs. Go to /databases to get all registered databases. endpoint : str pydantic-field \u00b6 The entry endpoint queried. According to the OPTIMADE specification, this is the same as the resource's type. optimade_urls : Set [ pydantic . networks . AnyUrl ] pydantic-field \u00b6 A list of OPTIMADE base URLs. If a versioned base URL is supplied it will be used as is, as long as it represents a supported version. If an un-versioned base URL, standard version negotiation will be conducted to get the versioned base URL, which will be used as long as it represents a supported version. Note, a single URL can be supplied as well, and it will automatically be wrapped in a list in the server logic. query_parameters : OptimadeQueryParameters pydantic-field \u00b6 OPTIMADE query parameters for entry listing endpoints used for this query. either_ids_or_urls ( values ) classmethod \u00b6 Either database_ids or optimade_urls must be defined Source code in optimade_gateway/models/search.py @root_validator def either_ids_or_urls ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `optimade_urls` must be defined\"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"optimade_urls\" )): raise ValueError ( \"Either 'database_ids' or 'optimade_urls' MUST be specified.\" ) return values","title":"search"},{"location":"api_reference/models/search/#search","text":"","title":"search"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search","text":"A general coordinated OPTIMADE search Important Either database_ids or optimade_urls MUST be specified.","title":"Search"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search.database_ids","text":"A list of registered database IDs. Go to /databases to get all registered databases.","title":"database_ids"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search.endpoint","text":"The entry endpoint queried. According to the OPTIMADE specification, this is the same as the resource's type.","title":"endpoint"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search.optimade_urls","text":"A list of OPTIMADE base URLs. If a versioned base URL is supplied it will be used as is, as long as it represents a supported version. If an un-versioned base URL, standard version negotiation will be conducted to get the versioned base URL, which will be used as long as it represents a supported version. Note, a single URL can be supplied as well, and it will automatically be wrapped in a list in the server logic.","title":"optimade_urls"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search.query_parameters","text":"OPTIMADE query parameters for entry listing endpoints used for this query.","title":"query_parameters"},{"location":"api_reference/models/search/#optimade_gateway.models.search.Search.either_ids_or_urls","text":"Either database_ids or optimade_urls must be defined Source code in optimade_gateway/models/search.py @root_validator def either_ids_or_urls ( cls , values : dict ) -> dict : \"\"\"Either `database_ids` or `optimade_urls` must be defined\"\"\" if not any ( values . get ( field ) for field in ( \"database_ids\" , \"optimade_urls\" )): raise ValueError ( \"Either 'database_ids' or 'optimade_urls' MUST be specified.\" ) return values","title":"either_ids_or_urls()"},{"location":"api_reference/mongo/collection/","text":"collection \u00b6 AsyncMongoCollection \u00b6 MongoDB Collection for use with asyncio The asynchronicity is implemented using motor and asyncio . __init__ ( self , name , resource_cls , resource_mapper ) special \u00b6 Initialize the AsyncMongoCollection for the given parameters. Parameters: Name Type Description Default name str The name of the collection. required resource_cls EntryResource The EntryResource model that is stored by the collection. required resource_mapper BaseResourceMapper A resource mapper object that handles aliases and format changes between deserialization and response. required Source code in optimade_gateway/mongo/collection.py def __init__ ( self , name : str , resource_cls : EntryResource , resource_mapper : BaseResourceMapper , ): \"\"\"Initialize the AsyncMongoCollection for the given parameters. Parameters: name: The name of the collection. resource_cls: The `EntryResource` model that is stored by the collection. resource_mapper: A resource mapper object that handles aliases and format changes between deserialization and response. \"\"\" from optimade_gateway.mongo.database import MONGO_DB super () . __init__ ( resource_cls = resource_cls , resource_mapper = resource_mapper , transformer = MongoTransformer ( mapper = resource_mapper ), ) self . parser = LarkParser ( version = ( 1 , 0 , 0 ), variant = \"default\" ) self . collection : MongoCollection = MONGO_DB [ name ] # Check aliases do not clash with mongo operators self . _check_aliases ( self . resource_mapper . all_aliases ()) self . _check_aliases ( self . resource_mapper . all_length_aliases ()) __len__ ( self ) special \u00b6 Length of collection Source code in optimade_gateway/mongo/collection.py def __len__ ( self ) -> int : \"\"\"Length of collection\"\"\" import warnings warnings . warn ( \"Cannot calculate length of collection using `len()`. Use `count()` instead.\" ) return 0 __repr__ ( self ) special \u00b6 Representation of instance Source code in optimade_gateway/mongo/collection.py def __repr__ ( self ) -> str : \"\"\"Representation of instance\"\"\" return f \" { self . __class__ . __name__ } (name= { self . collection . name !r} , resource_cls= { self . resource_cls !r} , resource_mapper= { self . resource_mapper !r} \" __str__ ( self ) special \u00b6 Standard printing result for an instance Source code in optimade_gateway/mongo/collection.py def __str__ ( self ) -> str : \"\"\"Standard printing result for an instance\"\"\" return f \"< { self . __class__ . __name__ } : resource= { self . resource_cls . __name__ } endpoint(mapper)= { self . resource_mapper . ENDPOINT } DB_collection= { self . collection . name } >\" count ( self , params = None , ** kwargs ) async \u00b6 Count documents in Collection Parameters: Name Type Description Default params Union[optimade.server.query_params.EntryListingQueryParams, optimade.server.query_params.SingleEntryQueryParams] URL query parameters, either from a general entry endpoint or a single-entry endpoint. None kwargs dict Query parameters as keyword arguments. Valid keys will be passed to the AsyncIOMotorCollection.count_documents method. {} Returns: Type Description int int: The number of entries matching the query specified by the keyword arguments. Source code in optimade_gateway/mongo/collection.py async def count ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] = None , ** kwargs , ) -> int : \"\"\"Count documents in Collection Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. kwargs (dict): Query parameters as keyword arguments. Valid keys will be passed to the [`AsyncIOMotorCollection.count_documents`](https://motor.readthedocs.io/en/stable/api-asyncio/asyncio_motor_collection.html#motor.motor_asyncio.AsyncIOMotorCollection.count_documents) method. Returns: int: The number of entries matching the query specified by the keyword arguments. \"\"\" if params is not None and kwargs : raise ValueError ( \"When 'params' is supplied, no other parameters can be supplied.\" ) if params is not None : kwargs = await self . handle_query_params ( params ) valid_method_keys = ( \"filter\" , \"skip\" , \"limit\" , \"hint\" , \"maxTimeMS\" , \"collation\" , \"session\" , ) criteria = { key : kwargs [ key ] for key in valid_method_keys if key in kwargs } if criteria . get ( \"filter\" ) is None : criteria [ \"filter\" ] = {} return await self . collection . count_documents ( ** criteria ) create_one ( self , resource ) async \u00b6 Create a new document in the MongoDB collection based on query parameters. Update the newly created document with an \"id\" field. The value will be the string representation of the \"_id\" field. This will only be done if \"id\" is not already present in resource . Parameters: Name Type Description Default resource EntryResourceCreate The resource to be created. required Returns: Type Description EntryResource The newly created document as a pydantic model entry resource. Source code in optimade_gateway/mongo/collection.py async def create_one ( self , resource : EntryResourceCreate ) -> EntryResource : \"\"\"Create a new document in the MongoDB collection based on query parameters. Update the newly created document with an `\"id\"` field. The value will be the string representation of the `\"_id\"` field. This will only be done if `\"id\"` is not already present in `resource`. Parameters: resource: The resource to be created. Returns: The newly created document as a pydantic model entry resource. \"\"\" resource . last_modified = datetime . utcnow () result = await self . collection . insert_one ( await clean_python_types ( resource . dict ( exclude_unset = True )) ) LOGGER . debug ( \"Inserted resource %r in DB collection %s with ID %s \" , resource , self . collection . name , result . inserted_id , ) if not resource . id : LOGGER . debug ( \"Updating resource with an `id` field equal to str(id_).\" ) await self . collection . update_one ( { \"_id\" : result . inserted_id }, { \"$set\" : { \"id\" : str ( result . inserted_id )}} ) return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ({ \"_id\" : result . inserted_id }) ) ) exists ( self , entry_id ) async \u00b6 Assert whether entry_id exists in the collection (value of \"id\" ) Parameters: Name Type Description Default entry_id str The \"id\" value of the entry. required Source code in optimade_gateway/mongo/collection.py async def exists ( self , entry_id : str ) -> bool : \"\"\"Assert whether entry_id exists in the collection (value of `\"id\"`) Parameters: entry_id: The `\"id\"` value of the entry. \"\"\" return bool ( await self . collection . count_documents ({ \"id\" : entry_id })) find ( self , params = None , criteria = None ) async \u00b6 Perform the query on the underlying MongoDB Collection, handling projection and pagination of the output. Either provide params or criteria . Not both, but at least one. Parameters: Name Type Description Default params Union[optimade.server.query_params.EntryListingQueryParams, optimade.server.query_params.SingleEntryQueryParams] URL query parameters, either from a general entry endpoint or a single-entry endpoint. None criteria Dict[str, Any] Already handled/parsed URL query parameters. None Returns: Type Description Tuple[Union[List[optimade.models.entries.EntryResource], optimade.models.entries.EntryResource], bool, set] A list of entry resource objects, whether more data is available with pagination, and fields. Source code in optimade_gateway/mongo/collection.py async def find ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] = None , criteria : Dict [ str , Any ] = None , ) -> Tuple [ Union [ List [ EntryResource ], EntryResource ], bool , set ]: \"\"\"Perform the query on the underlying MongoDB Collection, handling projection and pagination of the output. Either provide `params` or `criteria`. Not both, but at least one. Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. criteria: Already handled/parsed URL query parameters. Returns: A list of entry resource objects, whether more data is available with pagination, and fields. \"\"\" if ( params is None and criteria is None ) or ( params is not None and criteria is not None ): raise ValueError ( \"Exacly one of either `params` and `criteria` must be specified.\" ) if criteria is None : criteria = await self . handle_query_params ( params ) fields = criteria . get ( \"fields\" , self . all_fields ) results = [] async for document in self . collection . find ( ** self . _valid_find_keys ( ** criteria )): if criteria . get ( \"projection\" , {}) . get ( \"_id\" ): document [ \"_id\" ] = str ( document [ \"_id\" ]) results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( document ))) if params is None or isinstance ( params , EntryListingQueryParams ): criteria_nolimit = criteria . copy () criteria_nolimit . pop ( \"limit\" , None ) more_data_available = len ( results ) < await self . count ( ** criteria_nolimit ) else : # SingleEntryQueryParams, e.g., /structures/{entry_id} more_data_available = False if len ( results ) > 1 : raise HTTPException ( status_code = 404 , detail = f \"Instead of a single entry, { len ( results ) } entries were found\" , ) results = results [ 0 ] if results else None return results , more_data_available , self . all_fields - fields get_multiple ( self , ** criteria ) async \u00b6 Get a list of resources based on criteria Warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a list of resources. Parameters: Name Type Description Default criteria Dict[str, Any] Already handled/parsed URL query parameters. {} Returns: Type Description List[optimade.models.entries.EntryResource] A list of resources from the MongoDB (mapped to pydantic models). Source code in optimade_gateway/mongo/collection.py async def get_multiple ( self , ** criteria : Dict [ str , Any ]) -> List [ EntryResource ]: \"\"\"Get a list of resources based on criteria !!! warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a list of resources. Parameters: criteria: Already handled/parsed URL query parameters. Returns: A list of resources from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} results = [] async for document in self . collection . find ( ** self . _valid_find_keys ( ** criteria )): results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( document ))) return results get_one ( self , ** criteria ) async \u00b6 Get one resource based on criteria Warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a single resource. Parameters: Name Type Description Default criteria Dict[str, Any] Already handled/parsed URL query parameters. {} Returns: Type Description EntryResource A single resource from the MongoDB (mapped to pydantic models). Source code in optimade_gateway/mongo/collection.py async def get_one ( self , ** criteria : Dict [ str , Any ]) -> EntryResource : \"\"\"Get one resource based on criteria !!! warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a single resource. Parameters: criteria: Already handled/parsed URL query parameters. Returns: A single resource from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ( ** self . _valid_find_keys ( ** criteria )) ) ) handle_query_params ( self , params ) async \u00b6 Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: Name Type Description Default params Union[optimade.server.query_params.EntryListingQueryParams, optimade.server.query_params.SingleEntryQueryParams] The initialized query parameter model from the server. required Exceptions: Type Description Forbidden If too large of a page limit is provided. BadRequest If an invalid request is made, e.g., with incorrect fields or response format. Returns: Type Description dict A dictionary representation of the query parameters. Source code in optimade_gateway/mongo/collection.py async def handle_query_params ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] ) -> dict : cursor_kwargs = super () . handle_query_params ( params ) if getattr ( params , \"response_fields\" , False ): fields = set ( params . response_fields . split ( \",\" )) fields |= self . resource_mapper . get_required_fields () cursor_kwargs [ \"fields\" ] = fields else : # cursor_kwargs[\"fields\"] is already set to self.all_fields pass return cursor_kwargs insert ( self , data ) async \u00b6 Add the given entries to the underlying database. Warning No validation is performed on the incoming data. Parameters: Name Type Description Default data List[optimade.models.entries.EntryResource] The entry resource objects to add to the database. required Source code in optimade_gateway/mongo/collection.py async def insert ( self , data : List [ EntryResource ]) -> None : \"\"\"Add the given entries to the underlying database. Warning: No validation is performed on the incoming data. Parameters: data: The entry resource objects to add to the database. \"\"\" await self . collection . insert_many ( await clean_python_types ( data ))","title":"collection"},{"location":"api_reference/mongo/collection/#collection","text":"","title":"collection"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection","text":"MongoDB Collection for use with asyncio The asynchronicity is implemented using motor and asyncio .","title":"AsyncMongoCollection"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.__init__","text":"Initialize the AsyncMongoCollection for the given parameters. Parameters: Name Type Description Default name str The name of the collection. required resource_cls EntryResource The EntryResource model that is stored by the collection. required resource_mapper BaseResourceMapper A resource mapper object that handles aliases and format changes between deserialization and response. required Source code in optimade_gateway/mongo/collection.py def __init__ ( self , name : str , resource_cls : EntryResource , resource_mapper : BaseResourceMapper , ): \"\"\"Initialize the AsyncMongoCollection for the given parameters. Parameters: name: The name of the collection. resource_cls: The `EntryResource` model that is stored by the collection. resource_mapper: A resource mapper object that handles aliases and format changes between deserialization and response. \"\"\" from optimade_gateway.mongo.database import MONGO_DB super () . __init__ ( resource_cls = resource_cls , resource_mapper = resource_mapper , transformer = MongoTransformer ( mapper = resource_mapper ), ) self . parser = LarkParser ( version = ( 1 , 0 , 0 ), variant = \"default\" ) self . collection : MongoCollection = MONGO_DB [ name ] # Check aliases do not clash with mongo operators self . _check_aliases ( self . resource_mapper . all_aliases ()) self . _check_aliases ( self . resource_mapper . all_length_aliases ())","title":"__init__()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.__len__","text":"Length of collection Source code in optimade_gateway/mongo/collection.py def __len__ ( self ) -> int : \"\"\"Length of collection\"\"\" import warnings warnings . warn ( \"Cannot calculate length of collection using `len()`. Use `count()` instead.\" ) return 0","title":"__len__()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.__repr__","text":"Representation of instance Source code in optimade_gateway/mongo/collection.py def __repr__ ( self ) -> str : \"\"\"Representation of instance\"\"\" return f \" { self . __class__ . __name__ } (name= { self . collection . name !r} , resource_cls= { self . resource_cls !r} , resource_mapper= { self . resource_mapper !r} \"","title":"__repr__()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.__str__","text":"Standard printing result for an instance Source code in optimade_gateway/mongo/collection.py def __str__ ( self ) -> str : \"\"\"Standard printing result for an instance\"\"\" return f \"< { self . __class__ . __name__ } : resource= { self . resource_cls . __name__ } endpoint(mapper)= { self . resource_mapper . ENDPOINT } DB_collection= { self . collection . name } >\"","title":"__str__()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.count","text":"Count documents in Collection Parameters: Name Type Description Default params Union[optimade.server.query_params.EntryListingQueryParams, optimade.server.query_params.SingleEntryQueryParams] URL query parameters, either from a general entry endpoint or a single-entry endpoint. None kwargs dict Query parameters as keyword arguments. Valid keys will be passed to the AsyncIOMotorCollection.count_documents method. {} Returns: Type Description int int: The number of entries matching the query specified by the keyword arguments. Source code in optimade_gateway/mongo/collection.py async def count ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] = None , ** kwargs , ) -> int : \"\"\"Count documents in Collection Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. kwargs (dict): Query parameters as keyword arguments. Valid keys will be passed to the [`AsyncIOMotorCollection.count_documents`](https://motor.readthedocs.io/en/stable/api-asyncio/asyncio_motor_collection.html#motor.motor_asyncio.AsyncIOMotorCollection.count_documents) method. Returns: int: The number of entries matching the query specified by the keyword arguments. \"\"\" if params is not None and kwargs : raise ValueError ( \"When 'params' is supplied, no other parameters can be supplied.\" ) if params is not None : kwargs = await self . handle_query_params ( params ) valid_method_keys = ( \"filter\" , \"skip\" , \"limit\" , \"hint\" , \"maxTimeMS\" , \"collation\" , \"session\" , ) criteria = { key : kwargs [ key ] for key in valid_method_keys if key in kwargs } if criteria . get ( \"filter\" ) is None : criteria [ \"filter\" ] = {} return await self . collection . count_documents ( ** criteria )","title":"count()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.create_one","text":"Create a new document in the MongoDB collection based on query parameters. Update the newly created document with an \"id\" field. The value will be the string representation of the \"_id\" field. This will only be done if \"id\" is not already present in resource . Parameters: Name Type Description Default resource EntryResourceCreate The resource to be created. required Returns: Type Description EntryResource The newly created document as a pydantic model entry resource. Source code in optimade_gateway/mongo/collection.py async def create_one ( self , resource : EntryResourceCreate ) -> EntryResource : \"\"\"Create a new document in the MongoDB collection based on query parameters. Update the newly created document with an `\"id\"` field. The value will be the string representation of the `\"_id\"` field. This will only be done if `\"id\"` is not already present in `resource`. Parameters: resource: The resource to be created. Returns: The newly created document as a pydantic model entry resource. \"\"\" resource . last_modified = datetime . utcnow () result = await self . collection . insert_one ( await clean_python_types ( resource . dict ( exclude_unset = True )) ) LOGGER . debug ( \"Inserted resource %r in DB collection %s with ID %s \" , resource , self . collection . name , result . inserted_id , ) if not resource . id : LOGGER . debug ( \"Updating resource with an `id` field equal to str(id_).\" ) await self . collection . update_one ( { \"_id\" : result . inserted_id }, { \"$set\" : { \"id\" : str ( result . inserted_id )}} ) return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ({ \"_id\" : result . inserted_id }) ) )","title":"create_one()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.exists","text":"Assert whether entry_id exists in the collection (value of \"id\" ) Parameters: Name Type Description Default entry_id str The \"id\" value of the entry. required Source code in optimade_gateway/mongo/collection.py async def exists ( self , entry_id : str ) -> bool : \"\"\"Assert whether entry_id exists in the collection (value of `\"id\"`) Parameters: entry_id: The `\"id\"` value of the entry. \"\"\" return bool ( await self . collection . count_documents ({ \"id\" : entry_id }))","title":"exists()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.find","text":"Perform the query on the underlying MongoDB Collection, handling projection and pagination of the output. Either provide params or criteria . Not both, but at least one. Parameters: Name Type Description Default params Union[optimade.server.query_params.EntryListingQueryParams, optimade.server.query_params.SingleEntryQueryParams] URL query parameters, either from a general entry endpoint or a single-entry endpoint. None criteria Dict[str, Any] Already handled/parsed URL query parameters. None Returns: Type Description Tuple[Union[List[optimade.models.entries.EntryResource], optimade.models.entries.EntryResource], bool, set] A list of entry resource objects, whether more data is available with pagination, and fields. Source code in optimade_gateway/mongo/collection.py async def find ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] = None , criteria : Dict [ str , Any ] = None , ) -> Tuple [ Union [ List [ EntryResource ], EntryResource ], bool , set ]: \"\"\"Perform the query on the underlying MongoDB Collection, handling projection and pagination of the output. Either provide `params` or `criteria`. Not both, but at least one. Parameters: params: URL query parameters, either from a general entry endpoint or a single-entry endpoint. criteria: Already handled/parsed URL query parameters. Returns: A list of entry resource objects, whether more data is available with pagination, and fields. \"\"\" if ( params is None and criteria is None ) or ( params is not None and criteria is not None ): raise ValueError ( \"Exacly one of either `params` and `criteria` must be specified.\" ) if criteria is None : criteria = await self . handle_query_params ( params ) fields = criteria . get ( \"fields\" , self . all_fields ) results = [] async for document in self . collection . find ( ** self . _valid_find_keys ( ** criteria )): if criteria . get ( \"projection\" , {}) . get ( \"_id\" ): document [ \"_id\" ] = str ( document [ \"_id\" ]) results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( document ))) if params is None or isinstance ( params , EntryListingQueryParams ): criteria_nolimit = criteria . copy () criteria_nolimit . pop ( \"limit\" , None ) more_data_available = len ( results ) < await self . count ( ** criteria_nolimit ) else : # SingleEntryQueryParams, e.g., /structures/{entry_id} more_data_available = False if len ( results ) > 1 : raise HTTPException ( status_code = 404 , detail = f \"Instead of a single entry, { len ( results ) } entries were found\" , ) results = results [ 0 ] if results else None return results , more_data_available , self . all_fields - fields","title":"find()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.get_multiple","text":"Get a list of resources based on criteria Warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a list of resources. Parameters: Name Type Description Default criteria Dict[str, Any] Already handled/parsed URL query parameters. {} Returns: Type Description List[optimade.models.entries.EntryResource] A list of resources from the MongoDB (mapped to pydantic models). Source code in optimade_gateway/mongo/collection.py async def get_multiple ( self , ** criteria : Dict [ str , Any ]) -> List [ EntryResource ]: \"\"\"Get a list of resources based on criteria !!! warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a list of resources. Parameters: criteria: Already handled/parsed URL query parameters. Returns: A list of resources from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} results = [] async for document in self . collection . find ( ** self . _valid_find_keys ( ** criteria )): results . append ( self . resource_cls ( ** self . resource_mapper . map_back ( document ))) return results","title":"get_multiple()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.get_one","text":"Get one resource based on criteria Warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a single resource. Parameters: Name Type Description Default criteria Dict[str, Any] Already handled/parsed URL query parameters. {} Returns: Type Description EntryResource A single resource from the MongoDB (mapped to pydantic models). Source code in optimade_gateway/mongo/collection.py async def get_one ( self , ** criteria : Dict [ str , Any ]) -> EntryResource : \"\"\"Get one resource based on criteria !!! warning This is not to be used for creating a REST API response, but is rather a utility function to easily retrieve a single resource. Parameters: criteria: Already handled/parsed URL query parameters. Returns: A single resource from the MongoDB (mapped to pydantic models). \"\"\" criteria = criteria or {} return self . resource_cls ( ** self . resource_mapper . map_back ( await self . collection . find_one ( ** self . _valid_find_keys ( ** criteria )) ) )","title":"get_one()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.handle_query_params","text":"Parse and interpret the backend-agnostic query parameter models into a dictionary that can be used by the specific backend. Note Currently this method returns the pymongo interpretation of the parameters, which will need modification for modified for other backends. Parameters: Name Type Description Default params Union[optimade.server.query_params.EntryListingQueryParams, optimade.server.query_params.SingleEntryQueryParams] The initialized query parameter model from the server. required Exceptions: Type Description Forbidden If too large of a page limit is provided. BadRequest If an invalid request is made, e.g., with incorrect fields or response format. Returns: Type Description dict A dictionary representation of the query parameters. Source code in optimade_gateway/mongo/collection.py async def handle_query_params ( self , params : Union [ EntryListingQueryParams , SingleEntryQueryParams ] ) -> dict : cursor_kwargs = super () . handle_query_params ( params ) if getattr ( params , \"response_fields\" , False ): fields = set ( params . response_fields . split ( \",\" )) fields |= self . resource_mapper . get_required_fields () cursor_kwargs [ \"fields\" ] = fields else : # cursor_kwargs[\"fields\"] is already set to self.all_fields pass return cursor_kwargs","title":"handle_query_params()"},{"location":"api_reference/mongo/collection/#optimade_gateway.mongo.collection.AsyncMongoCollection.insert","text":"Add the given entries to the underlying database. Warning No validation is performed on the incoming data. Parameters: Name Type Description Default data List[optimade.models.entries.EntryResource] The entry resource objects to add to the database. required Source code in optimade_gateway/mongo/collection.py async def insert ( self , data : List [ EntryResource ]) -> None : \"\"\"Add the given entries to the underlying database. Warning: No validation is performed on the incoming data. Parameters: data: The entry resource objects to add to the database. \"\"\" await self . collection . insert_many ( await clean_python_types ( data ))","title":"insert()"},{"location":"api_reference/mongo/database/","text":"database \u00b6 MONGO_CLIENT : MongoClient \u00b6 The MongoDB motor client. MONGO_DB : Database \u00b6 The MongoDB motor database. This is a representation of the database used for the gateway service.","title":"database"},{"location":"api_reference/mongo/database/#database","text":"","title":"database"},{"location":"api_reference/mongo/database/#optimade_gateway.mongo.database.MONGO_CLIENT","text":"The MongoDB motor client.","title":"MONGO_CLIENT"},{"location":"api_reference/mongo/database/#optimade_gateway.mongo.database.MONGO_DB","text":"The MongoDB motor database. This is a representation of the database used for the gateway service.","title":"MONGO_DB"},{"location":"api_reference/queries/params/","text":"params \u00b6 SearchQueryParams \u00b6 URL query parameters for GET /search This is an extension of the EntryListingQueryParams class in `optimade\u00b4, which defines the standard entry listing endpoint query parameters. The extra query parameters are as follows. Attributes: Name Type Description database_ids Set[str] List of possible database IDs that are already known by the gateway. To be known they need to be registered with the gateway (currently not possible). optimade_urls Set[AnyUrl] A list of OPTIMADE base URLs. If a versioned base URL is supplied it will be used as is, as long as it represents a supported version. If an un-versioned base URL, standard version negotiation will be conducted to get the versioned base URL, which will be used as long as it represents a supported version. Example : http://example.org/optimade/v1/search?optimade_urls=\"https://example.org/optimade_db/v1\",\"https://optimade.herokuapp.com\" endpoint str The entry endpoint queried. According to the OPTIMADE specification, this is the same as the resource's type. Example : structures timeout int Timeout time (in seconds) to wait for a query to finish before redirecting ( after starting the query). Note, if the query has not finished after the timeout time, a redirection will still be performed, but to a zero-results page, which can be refreshed to get the finished query (once it has finished).","title":"params"},{"location":"api_reference/queries/params/#params","text":"","title":"params"},{"location":"api_reference/queries/params/#optimade_gateway.queries.params.SearchQueryParams","text":"URL query parameters for GET /search This is an extension of the EntryListingQueryParams class in `optimade\u00b4, which defines the standard entry listing endpoint query parameters. The extra query parameters are as follows. Attributes: Name Type Description database_ids Set[str] List of possible database IDs that are already known by the gateway. To be known they need to be registered with the gateway (currently not possible). optimade_urls Set[AnyUrl] A list of OPTIMADE base URLs. If a versioned base URL is supplied it will be used as is, as long as it represents a supported version. If an un-versioned base URL, standard version negotiation will be conducted to get the versioned base URL, which will be used as long as it represents a supported version. Example : http://example.org/optimade/v1/search?optimade_urls=\"https://example.org/optimade_db/v1\",\"https://optimade.herokuapp.com\" endpoint str The entry endpoint queried. According to the OPTIMADE specification, this is the same as the resource's type. Example : structures timeout int Timeout time (in seconds) to wait for a query to finish before redirecting ( after starting the query). Note, if the query has not finished after the timeout time, a redirection will still be performed, but to a zero-results page, which can be refreshed to get the finished query (once it has finished).","title":"SearchQueryParams"},{"location":"api_reference/queries/perform/","text":"perform \u00b6 db_find ( database , endpoint , response_model , query_params = '' , raw_url = None ) \u00b6 Imitate Collection.find() for any given database for entry-resource endpoints Parameters: Name Type Description Default database Union[optimade.models.links.LinksResource, Dict[str, Any]] The OPTIMADE implementation to be queried. It must have a valid base URL and id. required endpoint str The entry-listing endpoint, e.g., \"structures\" . required response_model Union[optimade.models.responses.EntryResponseMany, optimade.models.responses.EntryResponseOne] The expected OPTIMADE pydantic response model, e.g., optimade.models.StructureResponseMany . required query_params str URL query parameters to pass to the database. '' raw_url str A raw URL to use straight up instead of deriving a URL from database , endpoint , and query_params . None Returns: Type Description Tuple[Union[optimade.models.responses.ErrorResponse, optimade.models.responses.EntryResponseMany, optimade.models.responses.EntryResponseOne], str] Response as an optimade pydantic model and the database 's ID. Source code in optimade_gateway/queries/perform.py def db_find ( database : Union [ LinksResource , Dict [ str , Any ]], endpoint : str , response_model : Union [ EntryResponseMany , EntryResponseOne ], query_params : str = \"\" , raw_url : str = None , ) -> Tuple [ Union [ ErrorResponse , EntryResponseMany , EntryResponseOne ], str ]: \"\"\"Imitate `Collection.find()` for any given database for entry-resource endpoints Parameters: database: The OPTIMADE implementation to be queried. It **must** have a valid base URL and id. endpoint: The entry-listing endpoint, e.g., `\"structures\"`. response_model: The expected OPTIMADE pydantic response model, e.g., `optimade.models.StructureResponseMany`. query_params: URL query parameters to pass to the database. raw_url: A raw URL to use straight up instead of deriving a URL from `database`, `endpoint`, and `query_params`. Returns: Response as an `optimade` pydantic model and the `database`'s ID. \"\"\" import httpx if raw_url : url = raw_url else : url = ( f \" { str ( get_resource_attribute ( database , 'attributes.base_url' )) . strip ( '/' ) } \" f \" { BASE_URL_PREFIXES [ 'major' ] } / { endpoint . strip ( '/' ) } ? { query_params } \" ) response : httpx . Response = httpx . get ( url , timeout = 60 ) try : response = response . json () except json . JSONDecodeError : return ( ErrorResponse ( errors = [ { \"detail\" : f \"Could not JSONify response from { url } \" , \"id\" : \"OPTIMADE_GATEWAY_DB_FIND_MANY_JSONDECODEERROR\" , } ], meta = { \"query\" : { \"representation\" : f \"/ { endpoint . strip ( '/' ) } ? { query_params } \" }, \"api_version\" : __api_version__ , \"more_data_available\" : False , }, ), get_resource_attribute ( database , \"id\" ), ) try : response = response_model ( ** response ) except ValidationError : try : response = ErrorResponse ( ** response ) except ValidationError as exc : return ( ErrorResponse ( errors = [ { \"detail\" : f \"Could not pass response from { url } as either a { response_model . __name__ !r} or 'ErrorResponse'. ValidationError: { exc } \" , \"id\" : \"OPTIMADE_GATEWAY_DB_FIND_MANY_VALIDATIONERROR\" , } ], meta = { \"query\" : { \"representation\" : f \"/ { endpoint . strip ( '/' ) } ? { query_params } \" }, \"api_version\" : __api_version__ , \"more_data_available\" : False , }, ), get_resource_attribute ( database , \"id\" ), ) return response , get_resource_attribute ( database , \"id\" ) db_get_all_resources ( database , endpoint , response_model , query_params = '' , raw_url = None ) async \u00b6 Recursively retrieve all resources from an entry-listing endpoint Parameters: Name Type Description Default database Union[optimade.models.links.LinksResource, Dict[str, Any]] The OPTIMADE implementation to be queried. It must have a valid base URL and id. required endpoint str The entry-listing endpoint, e.g., \"structures\" . required response_model EntryResponseMany The expected OPTIMADE pydantic response model, e.g., optimade.models.StructureResponseMany . required query_params str URL query parameters to pass to the database. '' raw_url str A raw URL to use straight up instead of deriving a URL from database , endpoint , and query_params . None Returns: Type Description Tuple[List[Union[optimade.models.entries.EntryResource, Dict[str, Any]]], Union[optimade.models.links.LinksResource, Dict[str, Any]]] A collected list of successful responses' data value and the database 's ID. Source code in optimade_gateway/queries/perform.py async def db_get_all_resources ( database : Union [ LinksResource , Dict [ str , Any ]], endpoint : str , response_model : EntryResponseMany , query_params : str = \"\" , raw_url : str = None , ) -> Tuple [ List [ Union [ EntryResource , Dict [ str , Any ]]], Union [ LinksResource , Dict [ str , Any ]] ]: \"\"\"Recursively retrieve all resources from an entry-listing endpoint Parameters: database: The OPTIMADE implementation to be queried. It **must** have a valid base URL and id. endpoint: The entry-listing endpoint, e.g., `\"structures\"`. response_model: The expected OPTIMADE pydantic response model, e.g., `optimade.models.StructureResponseMany`. query_params: URL query parameters to pass to the database. raw_url: A raw URL to use straight up instead of deriving a URL from `database`, `endpoint`, and `query_params`. Returns: A collected list of successful responses' `data` value and the `database`'s ID. \"\"\" resulting_resources = [] response , _ = db_find ( database = database , endpoint = endpoint , response_model = response_model , query_params = query_params , raw_url = raw_url , ) if isinstance ( response , ErrorResponse ): # An errored response will result in no databases from a provider. LOGGER . error ( \"Error while querying database (id= %r ). Full response: %s \" , get_resource_attribute ( database , \"id\" ), response . json ( indent = 2 ), ) return [], database resulting_resources . extend ( response . data ) if response . meta . more_data_available : next_page = get_resource_attribute ( response , \"links.next\" ) if next_page is None : LOGGER . error ( \"Could not find a 'next' link for an OPTIMADE query request to %r (id= %r ). Cannot \" \"get all resources from / %s , even though this was asked and `more_data_available` \" \"is `True` in the response.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), endpoint , ) return resulting_resources , database more_resources , _ = await db_get_all_resources ( database = database , endpoint = endpoint , response_model = response_model , query_params = query_params , raw_url = next_page , ) resulting_resources . extend ( more_resources ) return resulting_resources , database perform_query ( url , query , use_query_resource = True ) async \u00b6 Perform OPTIMADE query with gateway. Parameters: Name Type Description Default url URL Original request URL. required query QueryResource The query to be performed. required use_query_resource bool Whether or not to update the passed QueryResource or not. The URL will be changed if this is True , to allow for requesting the query back through the /queries endpoint. True Returns: Type Description Union[optimade.models.responses.EntryResponseMany, optimade.models.responses.ErrorResponse] This function returns the final response; either an ErrorResponse or a subclass of EntryResponseMany . Source code in optimade_gateway/queries/perform.py async def perform_query ( url : URL , query : QueryResource , use_query_resource : bool = True , ) -> Union [ EntryResponseMany , ErrorResponse ]: \"\"\"Perform OPTIMADE query with gateway. Parameters: url: Original request URL. query: The query to be performed. use_query_resource: Whether or not to update the passed [`QueryResource`][optimade_gateway.models.queries.QueryResource] or not. The URL will be changed if this is `True`, to allow for requesting the query back through the `/queries` endpoint. Returns: This function returns the final response; either an `ErrorResponse` or a subclass of `EntryResponseMany`. \"\"\" from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.utils import get_valid_resource data_available = data_returned = 0 errors = [] more_data_available = False results = [] gateway : GatewayResource = await get_valid_resource ( GATEWAYS_COLLECTION , query . attributes . gateway_id ) ( filter_queries , response_model ) = await prepare_query ( database_ids = [ _ . id for _ in gateway . attributes . databases ], endpoint_model = query . attributes . endpoint_model , filter_query = query . attributes . query_parameters . filter , ) loop = asyncio . get_running_loop () with ThreadPoolExecutor ( max_workers = min ( 32 , os . cpu_count () + 4 , len ( gateway . attributes . databases )) ) as executor : # Run OPTIMADE DB queries in a thread pool, i.e., not using the main OS thread, where the # asyncio event loop is running. query_tasks = [] for database in gateway . attributes . databases : query_params = await get_query_params ( query_parameters = query . attributes . query_parameters , database_id = database . id , filter_mapping = filter_queries , ) query_tasks . append ( loop . run_in_executor ( executor = executor , func = functools . partial ( db_find , database = database , endpoint = query . attributes . endpoint , response_model = response_model , query_params = query_params , ), ) ) if use_query_resource : await update_query ( query , \"state\" , QueryState . STARTED ) for query_task in query_tasks : ( response , db_id ) = await query_task if use_query_resource and query . attributes . state != QueryState . IN_PROGRESS : await update_query ( query , \"state\" , QueryState . IN_PROGRESS ) if isinstance ( response , ErrorResponse ): for error in response . errors : if isinstance ( error . id , str ) and error . id . startswith ( \"OPTIMADE_GATEWAY\" ): import warnings warnings . warn ( error . detail ) else : meta = {} if error . meta : meta = error . meta . dict () meta . update ( { \"optimade_gateway\" : { \"gateway\" : gateway , \"source_database_id\" : db_id , } } ) error . meta = Meta ( ** meta ) errors . append ( error ) else : for datum in response . data : if isinstance ( datum , dict ) and datum . get ( \"id\" ) is not None : datum [ \"id\" ] = f \" { db_id } / { datum [ 'id' ] } \" else : datum . id = f \" { db_id } / { datum . id } \" results . extend ( response . data ) data_available += response . meta . data_available or 0 data_returned += response . meta . data_returned or len ( response . data ) if not more_data_available : # Keep it True, if set to True once. more_data_available = response . meta . more_data_available if use_query_resource : url = url . replace ( path = f \" { url . path . rstrip ( '/' ) } / { query . id } \" ) meta = meta_values ( url = url , data_available = data_available , data_returned = data_returned , more_data_available = more_data_available , ) if errors : response = ErrorResponse ( errors = errors , meta = meta ) else : # Sort results over two steps, first by database id, # and then by (original) \"id\", since \"id\" MUST always be present. # NOTE: Possbly remove this sorting? results . sort ( key = lambda data : data [ \"id\" ] if \"id\" in data else data . id ) results . sort ( key = lambda data : \"/\" . join ( data [ \"id\" ] . split ( \"/\" )[ 1 :]) if \"id\" in data else \"/\" . join ( data . id . split ( \"/\" )[ 1 :]) ) if more_data_available : # Deduce the `next` link from the current request query_string = urllib . parse . parse_qs ( url . query ) query_string [ \"page_offset\" ] = int ( query_string . get ( \"page_offset\" , [ 0 ])[ 0 ] ) + len ( results [: query . attributes . query_parameters . page_limit ]) urlencoded = urllib . parse . urlencode ( query_string , doseq = True ) base_url = get_base_url ( url ) links = ToplevelLinks ( next = f \" { base_url }{ url . path } ? { urlencoded } \" ) else : links = ToplevelLinks ( next = None ) response = response_model ( links = links , data = results , meta = meta , ) if use_query_resource : await update_query ( query , \"response\" , response ) await update_query ( query , \"state\" , QueryState . FINISHED ) return response","title":"perform"},{"location":"api_reference/queries/perform/#perform","text":"","title":"perform"},{"location":"api_reference/queries/perform/#optimade_gateway.queries.perform.db_find","text":"Imitate Collection.find() for any given database for entry-resource endpoints Parameters: Name Type Description Default database Union[optimade.models.links.LinksResource, Dict[str, Any]] The OPTIMADE implementation to be queried. It must have a valid base URL and id. required endpoint str The entry-listing endpoint, e.g., \"structures\" . required response_model Union[optimade.models.responses.EntryResponseMany, optimade.models.responses.EntryResponseOne] The expected OPTIMADE pydantic response model, e.g., optimade.models.StructureResponseMany . required query_params str URL query parameters to pass to the database. '' raw_url str A raw URL to use straight up instead of deriving a URL from database , endpoint , and query_params . None Returns: Type Description Tuple[Union[optimade.models.responses.ErrorResponse, optimade.models.responses.EntryResponseMany, optimade.models.responses.EntryResponseOne], str] Response as an optimade pydantic model and the database 's ID. Source code in optimade_gateway/queries/perform.py def db_find ( database : Union [ LinksResource , Dict [ str , Any ]], endpoint : str , response_model : Union [ EntryResponseMany , EntryResponseOne ], query_params : str = \"\" , raw_url : str = None , ) -> Tuple [ Union [ ErrorResponse , EntryResponseMany , EntryResponseOne ], str ]: \"\"\"Imitate `Collection.find()` for any given database for entry-resource endpoints Parameters: database: The OPTIMADE implementation to be queried. It **must** have a valid base URL and id. endpoint: The entry-listing endpoint, e.g., `\"structures\"`. response_model: The expected OPTIMADE pydantic response model, e.g., `optimade.models.StructureResponseMany`. query_params: URL query parameters to pass to the database. raw_url: A raw URL to use straight up instead of deriving a URL from `database`, `endpoint`, and `query_params`. Returns: Response as an `optimade` pydantic model and the `database`'s ID. \"\"\" import httpx if raw_url : url = raw_url else : url = ( f \" { str ( get_resource_attribute ( database , 'attributes.base_url' )) . strip ( '/' ) } \" f \" { BASE_URL_PREFIXES [ 'major' ] } / { endpoint . strip ( '/' ) } ? { query_params } \" ) response : httpx . Response = httpx . get ( url , timeout = 60 ) try : response = response . json () except json . JSONDecodeError : return ( ErrorResponse ( errors = [ { \"detail\" : f \"Could not JSONify response from { url } \" , \"id\" : \"OPTIMADE_GATEWAY_DB_FIND_MANY_JSONDECODEERROR\" , } ], meta = { \"query\" : { \"representation\" : f \"/ { endpoint . strip ( '/' ) } ? { query_params } \" }, \"api_version\" : __api_version__ , \"more_data_available\" : False , }, ), get_resource_attribute ( database , \"id\" ), ) try : response = response_model ( ** response ) except ValidationError : try : response = ErrorResponse ( ** response ) except ValidationError as exc : return ( ErrorResponse ( errors = [ { \"detail\" : f \"Could not pass response from { url } as either a { response_model . __name__ !r} or 'ErrorResponse'. ValidationError: { exc } \" , \"id\" : \"OPTIMADE_GATEWAY_DB_FIND_MANY_VALIDATIONERROR\" , } ], meta = { \"query\" : { \"representation\" : f \"/ { endpoint . strip ( '/' ) } ? { query_params } \" }, \"api_version\" : __api_version__ , \"more_data_available\" : False , }, ), get_resource_attribute ( database , \"id\" ), ) return response , get_resource_attribute ( database , \"id\" )","title":"db_find()"},{"location":"api_reference/queries/perform/#optimade_gateway.queries.perform.db_get_all_resources","text":"Recursively retrieve all resources from an entry-listing endpoint Parameters: Name Type Description Default database Union[optimade.models.links.LinksResource, Dict[str, Any]] The OPTIMADE implementation to be queried. It must have a valid base URL and id. required endpoint str The entry-listing endpoint, e.g., \"structures\" . required response_model EntryResponseMany The expected OPTIMADE pydantic response model, e.g., optimade.models.StructureResponseMany . required query_params str URL query parameters to pass to the database. '' raw_url str A raw URL to use straight up instead of deriving a URL from database , endpoint , and query_params . None Returns: Type Description Tuple[List[Union[optimade.models.entries.EntryResource, Dict[str, Any]]], Union[optimade.models.links.LinksResource, Dict[str, Any]]] A collected list of successful responses' data value and the database 's ID. Source code in optimade_gateway/queries/perform.py async def db_get_all_resources ( database : Union [ LinksResource , Dict [ str , Any ]], endpoint : str , response_model : EntryResponseMany , query_params : str = \"\" , raw_url : str = None , ) -> Tuple [ List [ Union [ EntryResource , Dict [ str , Any ]]], Union [ LinksResource , Dict [ str , Any ]] ]: \"\"\"Recursively retrieve all resources from an entry-listing endpoint Parameters: database: The OPTIMADE implementation to be queried. It **must** have a valid base URL and id. endpoint: The entry-listing endpoint, e.g., `\"structures\"`. response_model: The expected OPTIMADE pydantic response model, e.g., `optimade.models.StructureResponseMany`. query_params: URL query parameters to pass to the database. raw_url: A raw URL to use straight up instead of deriving a URL from `database`, `endpoint`, and `query_params`. Returns: A collected list of successful responses' `data` value and the `database`'s ID. \"\"\" resulting_resources = [] response , _ = db_find ( database = database , endpoint = endpoint , response_model = response_model , query_params = query_params , raw_url = raw_url , ) if isinstance ( response , ErrorResponse ): # An errored response will result in no databases from a provider. LOGGER . error ( \"Error while querying database (id= %r ). Full response: %s \" , get_resource_attribute ( database , \"id\" ), response . json ( indent = 2 ), ) return [], database resulting_resources . extend ( response . data ) if response . meta . more_data_available : next_page = get_resource_attribute ( response , \"links.next\" ) if next_page is None : LOGGER . error ( \"Could not find a 'next' link for an OPTIMADE query request to %r (id= %r ). Cannot \" \"get all resources from / %s , even though this was asked and `more_data_available` \" \"is `True` in the response.\" , get_resource_attribute ( database , \"attributes.name\" , \"N/A\" ), get_resource_attribute ( database , \"id\" ), endpoint , ) return resulting_resources , database more_resources , _ = await db_get_all_resources ( database = database , endpoint = endpoint , response_model = response_model , query_params = query_params , raw_url = next_page , ) resulting_resources . extend ( more_resources ) return resulting_resources , database","title":"db_get_all_resources()"},{"location":"api_reference/queries/perform/#optimade_gateway.queries.perform.perform_query","text":"Perform OPTIMADE query with gateway. Parameters: Name Type Description Default url URL Original request URL. required query QueryResource The query to be performed. required use_query_resource bool Whether or not to update the passed QueryResource or not. The URL will be changed if this is True , to allow for requesting the query back through the /queries endpoint. True Returns: Type Description Union[optimade.models.responses.EntryResponseMany, optimade.models.responses.ErrorResponse] This function returns the final response; either an ErrorResponse or a subclass of EntryResponseMany . Source code in optimade_gateway/queries/perform.py async def perform_query ( url : URL , query : QueryResource , use_query_resource : bool = True , ) -> Union [ EntryResponseMany , ErrorResponse ]: \"\"\"Perform OPTIMADE query with gateway. Parameters: url: Original request URL. query: The query to be performed. use_query_resource: Whether or not to update the passed [`QueryResource`][optimade_gateway.models.queries.QueryResource] or not. The URL will be changed if this is `True`, to allow for requesting the query back through the `/queries` endpoint. Returns: This function returns the final response; either an `ErrorResponse` or a subclass of `EntryResponseMany`. \"\"\" from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.utils import get_valid_resource data_available = data_returned = 0 errors = [] more_data_available = False results = [] gateway : GatewayResource = await get_valid_resource ( GATEWAYS_COLLECTION , query . attributes . gateway_id ) ( filter_queries , response_model ) = await prepare_query ( database_ids = [ _ . id for _ in gateway . attributes . databases ], endpoint_model = query . attributes . endpoint_model , filter_query = query . attributes . query_parameters . filter , ) loop = asyncio . get_running_loop () with ThreadPoolExecutor ( max_workers = min ( 32 , os . cpu_count () + 4 , len ( gateway . attributes . databases )) ) as executor : # Run OPTIMADE DB queries in a thread pool, i.e., not using the main OS thread, where the # asyncio event loop is running. query_tasks = [] for database in gateway . attributes . databases : query_params = await get_query_params ( query_parameters = query . attributes . query_parameters , database_id = database . id , filter_mapping = filter_queries , ) query_tasks . append ( loop . run_in_executor ( executor = executor , func = functools . partial ( db_find , database = database , endpoint = query . attributes . endpoint , response_model = response_model , query_params = query_params , ), ) ) if use_query_resource : await update_query ( query , \"state\" , QueryState . STARTED ) for query_task in query_tasks : ( response , db_id ) = await query_task if use_query_resource and query . attributes . state != QueryState . IN_PROGRESS : await update_query ( query , \"state\" , QueryState . IN_PROGRESS ) if isinstance ( response , ErrorResponse ): for error in response . errors : if isinstance ( error . id , str ) and error . id . startswith ( \"OPTIMADE_GATEWAY\" ): import warnings warnings . warn ( error . detail ) else : meta = {} if error . meta : meta = error . meta . dict () meta . update ( { \"optimade_gateway\" : { \"gateway\" : gateway , \"source_database_id\" : db_id , } } ) error . meta = Meta ( ** meta ) errors . append ( error ) else : for datum in response . data : if isinstance ( datum , dict ) and datum . get ( \"id\" ) is not None : datum [ \"id\" ] = f \" { db_id } / { datum [ 'id' ] } \" else : datum . id = f \" { db_id } / { datum . id } \" results . extend ( response . data ) data_available += response . meta . data_available or 0 data_returned += response . meta . data_returned or len ( response . data ) if not more_data_available : # Keep it True, if set to True once. more_data_available = response . meta . more_data_available if use_query_resource : url = url . replace ( path = f \" { url . path . rstrip ( '/' ) } / { query . id } \" ) meta = meta_values ( url = url , data_available = data_available , data_returned = data_returned , more_data_available = more_data_available , ) if errors : response = ErrorResponse ( errors = errors , meta = meta ) else : # Sort results over two steps, first by database id, # and then by (original) \"id\", since \"id\" MUST always be present. # NOTE: Possbly remove this sorting? results . sort ( key = lambda data : data [ \"id\" ] if \"id\" in data else data . id ) results . sort ( key = lambda data : \"/\" . join ( data [ \"id\" ] . split ( \"/\" )[ 1 :]) if \"id\" in data else \"/\" . join ( data . id . split ( \"/\" )[ 1 :]) ) if more_data_available : # Deduce the `next` link from the current request query_string = urllib . parse . parse_qs ( url . query ) query_string [ \"page_offset\" ] = int ( query_string . get ( \"page_offset\" , [ 0 ])[ 0 ] ) + len ( results [: query . attributes . query_parameters . page_limit ]) urlencoded = urllib . parse . urlencode ( query_string , doseq = True ) base_url = get_base_url ( url ) links = ToplevelLinks ( next = f \" { base_url }{ url . path } ? { urlencoded } \" ) else : links = ToplevelLinks ( next = None ) response = response_model ( links = links , data = results , meta = meta , ) if use_query_resource : await update_query ( query , \"response\" , response ) await update_query ( query , \"state\" , QueryState . FINISHED ) return response","title":"perform_query()"},{"location":"api_reference/queries/prepare/","text":"prepare \u00b6 get_query_params ( query_parameters , database_id , filter_mapping ) async \u00b6 Construct the parsed URL query parameters Source code in optimade_gateway/queries/prepare.py async def get_query_params ( query_parameters : OptimadeQueryParameters , database_id : str , filter_mapping : Dict [ str , Union [ str , None ]], ) -> str : \"\"\"Construct the parsed URL query parameters\"\"\" query_params = { param : value for param , value in query_parameters . dict () . items () if value } if filter_mapping [ database_id ]: query_params . update ({ \"filter\" : filter_mapping [ database_id ]}) return urllib . parse . urlencode ( query_params ) get_response_model ( endpoint_model ) async \u00b6 Import and return response model based on endpoint_model . Parameters: Name Type Description Default endpoint_model Tuple[str, str] The endpoint_model from the QueryResource attributes . required Returns: Type Description Union[optimade.models.responses.EntryResponseMany, optimade.models.responses.EntryResponseOne] The imported response model class, e.g., StructureResponseMany . Source code in optimade_gateway/queries/prepare.py async def get_response_model ( endpoint_model : Tuple [ str , str ] ) -> Union [ EntryResponseMany , EntryResponseOne ]: \"\"\"Import and return response model based on `endpoint_model`. Parameters: endpoint_model: The [`endpoint_model`][optimade_gateway.models.queries.QueryResourceAttributes.endpoint_model] from the [`QueryResource` attributes][optimade_gateway.models.queries.QueryResourceAttributes]. Returns: The imported response model class, e.g., `StructureResponseMany`. \"\"\" module , name = endpoint_model return getattr ( importlib . import_module ( module ), name ) prepare_query ( database_ids , endpoint_model , filter_query ) async \u00b6 Prepare a query by returning necessary variables. Source code in optimade_gateway/queries/prepare.py async def prepare_query ( database_ids : List [ str ], endpoint_model : Tuple [ str , str ], filter_query : Union [ str , None ], ) -> Tuple [ Dict [ str , Union [ str , None ]], Union [ EntryResponseMany , EntryResponseOne ]]: \"\"\"Prepare a query by returning necessary variables.\"\"\" return ( await update_query_filter ( database_ids , filter_query ), await get_response_model ( endpoint_model ), ) update_query_filter ( database_ids , filter_query ) async \u00b6 Update the query parameter filter value to be database-specific This is needed due to the served change of id values. If someone searches for a gateway-changed id , it needs to be reverted to be database-specific. Parameters: Name Type Description Default database_ids List[str] List of the databases to create updated filter values for. These values are part of the gateway-changed id values and are essential. required filter_query Optional[str] The submitted filter query parameter value. Can be None if not supplied. required Returns: Type Description Dict[str, Optional[str]] A mapping for database IDs to database-specific filter query parameter values. Source code in optimade_gateway/queries/prepare.py async def update_query_filter ( database_ids : List [ str ], filter_query : Union [ str , None ] ) -> Dict [ str , Union [ str , None ]]: \"\"\"Update the query parameter `filter` value to be database-specific This is needed due to the served change of `id` values. If someone searches for a gateway-changed `id`, it needs to be reverted to be database-specific. Parameters: database_ids: List of the databases to create updated filter values for. These values are part of the gateway-changed `id` values and are essential. filter_query: The submitted `filter` query parameter value. Can be `None` if not supplied. Returns: A mapping for database IDs to database-specific `filter` query parameter values. \"\"\" updated_filter = {} . fromkeys ( database_ids , filter_query ) if not filter_query : return updated_filter for id_match in re . finditer ( r '\"(?P<id_value_l>[^\\s]*)\"[\\s]*(<|>|<=|>=|=|!=|CONTAINS|STARTS WITH|ENDS WITH|STARTS|ENDS)' r '[\\s]*id|[^_]+id[\\s]*(<|>|<=|>=|=|!=|CONTAINS|STARTS WITH|ENDS WITH|STARTS|ENDS)[\\s]*\"' r '(?P<id_value_r>[^\\s]*)\"' , f \"= { filter_query } \" if filter_query else \"\" , ): matched_id = id_match . group ( \"id_value_l\" ) or id_match . group ( \"id_value_r\" ) for database_id in database_ids : if matched_id . startswith ( f \" { database_id } /\" ): # Database found updated_filter [ database_id ] = updated_filter [ database_id ] . replace ( f \" { database_id } /\" , \"\" , 1 ) break # TODO: Remove `id=\"value\"` sections here for queries to databases that doesn't match the id value! else : raise BadRequest ( detail = ( f \"Structures entry <id= { matched_id } > not found. To get a specific structures \" \"entry one needs to prepend the ID with a database ID belonging to the gateway,\" f \" e.g., ' { database_ids [ 0 ] } /<local_database_ID>'. Available\" f \"databases for this gateway: { database_ids } \" ) ) return updated_filter","title":"prepare"},{"location":"api_reference/queries/prepare/#prepare","text":"","title":"prepare"},{"location":"api_reference/queries/prepare/#optimade_gateway.queries.prepare.get_query_params","text":"Construct the parsed URL query parameters Source code in optimade_gateway/queries/prepare.py async def get_query_params ( query_parameters : OptimadeQueryParameters , database_id : str , filter_mapping : Dict [ str , Union [ str , None ]], ) -> str : \"\"\"Construct the parsed URL query parameters\"\"\" query_params = { param : value for param , value in query_parameters . dict () . items () if value } if filter_mapping [ database_id ]: query_params . update ({ \"filter\" : filter_mapping [ database_id ]}) return urllib . parse . urlencode ( query_params )","title":"get_query_params()"},{"location":"api_reference/queries/prepare/#optimade_gateway.queries.prepare.get_response_model","text":"Import and return response model based on endpoint_model . Parameters: Name Type Description Default endpoint_model Tuple[str, str] The endpoint_model from the QueryResource attributes . required Returns: Type Description Union[optimade.models.responses.EntryResponseMany, optimade.models.responses.EntryResponseOne] The imported response model class, e.g., StructureResponseMany . Source code in optimade_gateway/queries/prepare.py async def get_response_model ( endpoint_model : Tuple [ str , str ] ) -> Union [ EntryResponseMany , EntryResponseOne ]: \"\"\"Import and return response model based on `endpoint_model`. Parameters: endpoint_model: The [`endpoint_model`][optimade_gateway.models.queries.QueryResourceAttributes.endpoint_model] from the [`QueryResource` attributes][optimade_gateway.models.queries.QueryResourceAttributes]. Returns: The imported response model class, e.g., `StructureResponseMany`. \"\"\" module , name = endpoint_model return getattr ( importlib . import_module ( module ), name )","title":"get_response_model()"},{"location":"api_reference/queries/prepare/#optimade_gateway.queries.prepare.prepare_query","text":"Prepare a query by returning necessary variables. Source code in optimade_gateway/queries/prepare.py async def prepare_query ( database_ids : List [ str ], endpoint_model : Tuple [ str , str ], filter_query : Union [ str , None ], ) -> Tuple [ Dict [ str , Union [ str , None ]], Union [ EntryResponseMany , EntryResponseOne ]]: \"\"\"Prepare a query by returning necessary variables.\"\"\" return ( await update_query_filter ( database_ids , filter_query ), await get_response_model ( endpoint_model ), )","title":"prepare_query()"},{"location":"api_reference/queries/prepare/#optimade_gateway.queries.prepare.update_query_filter","text":"Update the query parameter filter value to be database-specific This is needed due to the served change of id values. If someone searches for a gateway-changed id , it needs to be reverted to be database-specific. Parameters: Name Type Description Default database_ids List[str] List of the databases to create updated filter values for. These values are part of the gateway-changed id values and are essential. required filter_query Optional[str] The submitted filter query parameter value. Can be None if not supplied. required Returns: Type Description Dict[str, Optional[str]] A mapping for database IDs to database-specific filter query parameter values. Source code in optimade_gateway/queries/prepare.py async def update_query_filter ( database_ids : List [ str ], filter_query : Union [ str , None ] ) -> Dict [ str , Union [ str , None ]]: \"\"\"Update the query parameter `filter` value to be database-specific This is needed due to the served change of `id` values. If someone searches for a gateway-changed `id`, it needs to be reverted to be database-specific. Parameters: database_ids: List of the databases to create updated filter values for. These values are part of the gateway-changed `id` values and are essential. filter_query: The submitted `filter` query parameter value. Can be `None` if not supplied. Returns: A mapping for database IDs to database-specific `filter` query parameter values. \"\"\" updated_filter = {} . fromkeys ( database_ids , filter_query ) if not filter_query : return updated_filter for id_match in re . finditer ( r '\"(?P<id_value_l>[^\\s]*)\"[\\s]*(<|>|<=|>=|=|!=|CONTAINS|STARTS WITH|ENDS WITH|STARTS|ENDS)' r '[\\s]*id|[^_]+id[\\s]*(<|>|<=|>=|=|!=|CONTAINS|STARTS WITH|ENDS WITH|STARTS|ENDS)[\\s]*\"' r '(?P<id_value_r>[^\\s]*)\"' , f \"= { filter_query } \" if filter_query else \"\" , ): matched_id = id_match . group ( \"id_value_l\" ) or id_match . group ( \"id_value_r\" ) for database_id in database_ids : if matched_id . startswith ( f \" { database_id } /\" ): # Database found updated_filter [ database_id ] = updated_filter [ database_id ] . replace ( f \" { database_id } /\" , \"\" , 1 ) break # TODO: Remove `id=\"value\"` sections here for queries to databases that doesn't match the id value! else : raise BadRequest ( detail = ( f \"Structures entry <id= { matched_id } > not found. To get a specific structures \" \"entry one needs to prepend the ID with a database ID belonging to the gateway,\" f \" e.g., ' { database_ids [ 0 ] } /<local_database_ID>'. Available\" f \"databases for this gateway: { database_ids } \" ) ) return updated_filter","title":"update_query_filter()"},{"location":"api_reference/queries/utils/","text":"utils \u00b6 update_query ( query , field , value ) async \u00b6 Update a query's field attribute with value . Note This can only update a field for a query's attributes , i.e., this function cannot update id , type or any other top-level resource field. Parameters: Name Type Description Default query QueryResource The query to be updated. required field str The attributes field (key) to be set. required value Any The (possibly) new value for field . required Source code in optimade_gateway/queries/utils.py async def update_query ( query : QueryResource , field : str , value : Any ) -> None : \"\"\"Update a query's `field` attribute with `value`. !!! note This can _only_ update a field for a query's `attributes`, i.e., this function cannot update `id`, `type` or any other top-level resource field. Parameters: query: The query to be updated. field: The `attributes` field (key) to be set. value: The (possibly) new value for `field`. \"\"\" from datetime import datetime from optimade_gateway.common.utils import clean_python_types from optimade_gateway.routers.queries import QUERIES_COLLECTION update_time = datetime . utcnow () # MongoDB result : UpdateResult = await QUERIES_COLLECTION . collection . update_one ( filter = { \"id\" : { \"$eq\" : query . id }}, update = { \"$set\" : { \"last_modified\" : update_time , field : await clean_python_types ( value ), } }, ) if result . matched_count != 1 : LOGGER . error ( \"matched_count should have been exactly 1, it was: %s . Returned update_one result: %s \" , result . matched_count , result . raw_result , ) # Pydantic model instance query . attributes . last_modified = update_time setattr ( query . attributes , field , value )","title":"utils"},{"location":"api_reference/queries/utils/#utils","text":"","title":"utils"},{"location":"api_reference/queries/utils/#optimade_gateway.queries.utils.update_query","text":"Update a query's field attribute with value . Note This can only update a field for a query's attributes , i.e., this function cannot update id , type or any other top-level resource field. Parameters: Name Type Description Default query QueryResource The query to be updated. required field str The attributes field (key) to be set. required value Any The (possibly) new value for field . required Source code in optimade_gateway/queries/utils.py async def update_query ( query : QueryResource , field : str , value : Any ) -> None : \"\"\"Update a query's `field` attribute with `value`. !!! note This can _only_ update a field for a query's `attributes`, i.e., this function cannot update `id`, `type` or any other top-level resource field. Parameters: query: The query to be updated. field: The `attributes` field (key) to be set. value: The (possibly) new value for `field`. \"\"\" from datetime import datetime from optimade_gateway.common.utils import clean_python_types from optimade_gateway.routers.queries import QUERIES_COLLECTION update_time = datetime . utcnow () # MongoDB result : UpdateResult = await QUERIES_COLLECTION . collection . update_one ( filter = { \"id\" : { \"$eq\" : query . id }}, update = { \"$set\" : { \"last_modified\" : update_time , field : await clean_python_types ( value ), } }, ) if result . matched_count != 1 : LOGGER . error ( \"matched_count should have been exactly 1, it was: %s . Returned update_one result: %s \" , result . matched_count , result . raw_result , ) # Pydantic model instance query . attributes . last_modified = update_time setattr ( query . attributes , field , value )","title":"update_query()"},{"location":"api_reference/routers/databases/","text":"databases \u00b6 /databases/* This file describes the router for: /databases/{id} where, id may be left out. Database resources represent the available databases that may be used for the gateways. One can register a new database (by using POST /databases ) or look through the available databases (by using GET /databases ) using standard OPTIMADE filtering. get_database ( request , database_id , params = Depends ( NoneType )) async \u00b6 GET /databases/{database ID} Return a single LinksResource representing the database resource object with id={database ID} . Source code in optimade_gateway/routers/databases.py @ROUTER . get ( \"/databases/{database_id:path}\" , response_model = Union [ DatabasesResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], ) async def get_database ( request : Request , database_id : str , params : SingleEntryQueryParams = Depends (), ) -> DatabasesResponseSingle : \"\"\"`GET /databases/{database ID}` Return a single [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) representing the database resource object with `id={database ID}`. \"\"\" params . filter = f 'id=\" { database_id } \"' result , _ , fields = await DATABASES_COLLECTION . find ( params = params ) if fields and result is not None : result = handle_response_fields ( result , fields )[ 0 ] return DatabasesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 0 if result is None else 1 , data_available = await DATABASES_COLLECTION . count (), more_data_available = False , ), ) get_databases ( request , params = Depends ( NoneType )) async \u00b6 GET /databases Return overview of all (active) databases. Source code in optimade_gateway/routers/databases.py @ROUTER . get ( \"/databases\" , response_model = Union [ DatabasesResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], ) async def get_databases ( request : Request , params : EntryListingQueryParams = Depends (), ) -> DatabasesResponse : \"\"\"`GET /databases` Return overview of all (active) databases. \"\"\" from optimade_gateway.routers.utils import get_entries return await get_entries ( collection = DATABASES_COLLECTION , response_cls = DatabasesResponse , request = request , params = params , ) post_databases ( request , database ) async \u00b6 POST /databases Create/Register or return an existing LinksResource , representing a database resource object, according to database . Source code in optimade_gateway/routers/databases.py @ROUTER . post ( \"/databases\" , response_model = Union [ DatabasesResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], ) async def post_databases ( request : Request , database : DatabaseCreate ) -> DatabasesResponseSingle : \"\"\"`POST /databases` Create/Register or return an existing [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource), representing a database resource object, according to `database`. \"\"\" from optimade_gateway.routers.utils import resource_factory result , created = await resource_factory ( database ) return DatabasesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await DATABASES_COLLECTION . count (), more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"databases"},{"location":"api_reference/routers/databases/#databases","text":"/databases/* This file describes the router for: /databases/{id} where, id may be left out. Database resources represent the available databases that may be used for the gateways. One can register a new database (by using POST /databases ) or look through the available databases (by using GET /databases ) using standard OPTIMADE filtering.","title":"databases"},{"location":"api_reference/routers/databases/#optimade_gateway.routers.databases.get_database","text":"GET /databases/{database ID} Return a single LinksResource representing the database resource object with id={database ID} . Source code in optimade_gateway/routers/databases.py @ROUTER . get ( \"/databases/{database_id:path}\" , response_model = Union [ DatabasesResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], ) async def get_database ( request : Request , database_id : str , params : SingleEntryQueryParams = Depends (), ) -> DatabasesResponseSingle : \"\"\"`GET /databases/{database ID}` Return a single [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) representing the database resource object with `id={database ID}`. \"\"\" params . filter = f 'id=\" { database_id } \"' result , _ , fields = await DATABASES_COLLECTION . find ( params = params ) if fields and result is not None : result = handle_response_fields ( result , fields )[ 0 ] return DatabasesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 0 if result is None else 1 , data_available = await DATABASES_COLLECTION . count (), more_data_available = False , ), )","title":"get_database()"},{"location":"api_reference/routers/databases/#optimade_gateway.routers.databases.get_databases","text":"GET /databases Return overview of all (active) databases. Source code in optimade_gateway/routers/databases.py @ROUTER . get ( \"/databases\" , response_model = Union [ DatabasesResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], ) async def get_databases ( request : Request , params : EntryListingQueryParams = Depends (), ) -> DatabasesResponse : \"\"\"`GET /databases` Return overview of all (active) databases. \"\"\" from optimade_gateway.routers.utils import get_entries return await get_entries ( collection = DATABASES_COLLECTION , response_cls = DatabasesResponse , request = request , params = params , )","title":"get_databases()"},{"location":"api_reference/routers/databases/#optimade_gateway.routers.databases.post_databases","text":"POST /databases Create/Register or return an existing LinksResource , representing a database resource object, according to database . Source code in optimade_gateway/routers/databases.py @ROUTER . post ( \"/databases\" , response_model = Union [ DatabasesResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Databases\" ], ) async def post_databases ( request : Request , database : DatabaseCreate ) -> DatabasesResponseSingle : \"\"\"`POST /databases` Create/Register or return an existing [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource), representing a database resource object, according to `database`. \"\"\" from optimade_gateway.routers.utils import resource_factory result , created = await resource_factory ( database ) return DatabasesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await DATABASES_COLLECTION . count (), more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"post_databases()"},{"location":"api_reference/routers/gateways/","text":"gateways \u00b6 /gateways/* This file describes the router for: /gateways/{id} where, id may be left out. get_gateway ( request , gateway_id ) async \u00b6 GET /gateways/{gateway ID} Represent an OPTIMADE server. Note For now, redirect to the gateway's /structures entry listing endpoint. Source code in optimade_gateway/routers/gateways.py @ROUTER . get ( \"/gateways/ {gateway_id} \" , response_model = Union [ GatewaysResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], ) async def get_gateway ( request : Request , gateway_id : str ) -> GatewaysResponseSingle : \"\"\"`GET /gateways/{gateway ID}` Represent an OPTIMADE server. !!! note For now, redirect to the gateway's `/structures` entry listing endpoint. \"\"\" from optimade_gateway.routers.utils import validate_resource await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) return RedirectResponse ( request . url . replace ( path = f \" { request . url . path . rstrip ( '/' ) } /structures\" ) ) get_gateways ( request , params = Depends ( NoneType )) async \u00b6 GET /gateways Return overview of all (active) gateways. Source code in optimade_gateway/routers/gateways.py @ROUTER . get ( \"/gateways\" , response_model = Union [ GatewaysResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], ) async def get_gateways ( request : Request , params : EntryListingQueryParams = Depends (), ) -> GatewaysResponse : \"\"\"`GET /gateways` Return overview of all (active) gateways. \"\"\" from optimade_gateway.routers.utils import get_entries return await get_entries ( collection = GATEWAYS_COLLECTION , response_cls = GatewaysResponse , request = request , params = params , ) post_gateways ( request , gateway ) async \u00b6 POST /gateways Create or return existing gateway according to gateway . Source code in optimade_gateway/routers/gateways.py @ROUTER . post ( \"/gateways\" , response_model = Union [ GatewaysResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], ) async def post_gateways ( request : Request , gateway : GatewayCreate ) -> GatewaysResponseSingle : \"\"\"`POST /gateways` Create or return existing gateway according to `gateway`. \"\"\" from optimade_gateway.common.utils import clean_python_types from optimade_gateway.routers.utils import resource_factory if gateway . database_ids : from optimade_gateway.routers.databases import DATABASES_COLLECTION databases = await DATABASES_COLLECTION . get_multiple ( filter = { \"id\" : { \"$in\" : await clean_python_types ( gateway . database_ids )}} ) if not isinstance ( gateway . databases , list ): gateway . databases = [] current_database_ids = [ _ . id for _ in gateway . databases ] gateway . databases . extend ( ( _ for _ in databases if _ . id not in current_database_ids ) ) result , created = await resource_factory ( gateway ) return GatewaysResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await GATEWAYS_COLLECTION . count (), more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"gateways"},{"location":"api_reference/routers/gateways/#gateways","text":"/gateways/* This file describes the router for: /gateways/{id} where, id may be left out.","title":"gateways"},{"location":"api_reference/routers/gateways/#optimade_gateway.routers.gateways.get_gateway","text":"GET /gateways/{gateway ID} Represent an OPTIMADE server. Note For now, redirect to the gateway's /structures entry listing endpoint. Source code in optimade_gateway/routers/gateways.py @ROUTER . get ( \"/gateways/ {gateway_id} \" , response_model = Union [ GatewaysResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], ) async def get_gateway ( request : Request , gateway_id : str ) -> GatewaysResponseSingle : \"\"\"`GET /gateways/{gateway ID}` Represent an OPTIMADE server. !!! note For now, redirect to the gateway's `/structures` entry listing endpoint. \"\"\" from optimade_gateway.routers.utils import validate_resource await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) return RedirectResponse ( request . url . replace ( path = f \" { request . url . path . rstrip ( '/' ) } /structures\" ) )","title":"get_gateway()"},{"location":"api_reference/routers/gateways/#optimade_gateway.routers.gateways.get_gateways","text":"GET /gateways Return overview of all (active) gateways. Source code in optimade_gateway/routers/gateways.py @ROUTER . get ( \"/gateways\" , response_model = Union [ GatewaysResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], ) async def get_gateways ( request : Request , params : EntryListingQueryParams = Depends (), ) -> GatewaysResponse : \"\"\"`GET /gateways` Return overview of all (active) gateways. \"\"\" from optimade_gateway.routers.utils import get_entries return await get_entries ( collection = GATEWAYS_COLLECTION , response_cls = GatewaysResponse , request = request , params = params , )","title":"get_gateways()"},{"location":"api_reference/routers/gateways/#optimade_gateway.routers.gateways.post_gateways","text":"POST /gateways Create or return existing gateway according to gateway . Source code in optimade_gateway/routers/gateways.py @ROUTER . post ( \"/gateways\" , response_model = Union [ GatewaysResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" ], ) async def post_gateways ( request : Request , gateway : GatewayCreate ) -> GatewaysResponseSingle : \"\"\"`POST /gateways` Create or return existing gateway according to `gateway`. \"\"\" from optimade_gateway.common.utils import clean_python_types from optimade_gateway.routers.utils import resource_factory if gateway . database_ids : from optimade_gateway.routers.databases import DATABASES_COLLECTION databases = await DATABASES_COLLECTION . get_multiple ( filter = { \"id\" : { \"$in\" : await clean_python_types ( gateway . database_ids )}} ) if not isinstance ( gateway . databases , list ): gateway . databases = [] current_database_ids = [ _ . id for _ in gateway . databases ] gateway . databases . extend ( ( _ for _ in databases if _ . id not in current_database_ids ) ) result , created = await resource_factory ( gateway ) return GatewaysResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await GATEWAYS_COLLECTION . count (), more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"post_gateways()"},{"location":"api_reference/routers/info/","text":"info \u00b6 /info/* This file describes the router for: /info/{entry} where, entry may be left out. get_entry_info ( request , entry ) async \u00b6 GET /info/{entry} Get information about the gateway service's entry-listing endpoints. Source code in optimade_gateway/routers/info.py @ROUTER . get ( \"/info/ {entry} \" , response_model = Union [ EntryInfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_entry_info ( request : Request , entry : str ) -> EntryInfoResponse : \"\"\"`GET /info/{entry}` Get information about the gateway service's entry-listing endpoints. \"\"\" from optimade.models import EntryInfoResource from optimade.server.exceptions import BadRequest from optimade_gateway.routers.utils import aretrieve_queryable_properties valid_entry_info_endpoints = ENTRY_INFO_SCHEMAS . keys () if entry not in valid_entry_info_endpoints : raise BadRequest ( title = \"Not Found\" , status_code = 404 , detail = ( f \"Entry info not found for { entry } , valid entry info endpoints are: \" f \" { ', ' . join ( valid_entry_info_endpoints ) } \" ), ) schema = ENTRY_INFO_SCHEMAS [ entry ]() queryable_properties = { \"id\" , \"type\" , \"attributes\" } properties = await aretrieve_queryable_properties ( schema , queryable_properties ) output_fields_by_format = { \"json\" : list ( properties . keys ())} return EntryInfoResponse ( data = EntryInfoResource ( formats = list ( output_fields_by_format . keys ()), description = schema . get ( \"description\" , \"Entry Resources\" ), properties = properties , output_fields_by_format = output_fields_by_format , ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , ), ) get_info ( request ) async \u00b6 GET /info An introspective endpoint for the gateway service. Source code in optimade_gateway/routers/info.py @ROUTER . get ( \"/info\" , response_model = Union [ InfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_info ( request : Request ) -> InfoResponse : \"\"\"`GET /info` An introspective endpoint for the gateway service. \"\"\" return InfoResponse ( data = BaseInfoResource ( id = BaseInfoResource . schema ()[ \"properties\" ][ \"id\" ][ \"const\" ], type = BaseInfoResource . schema ()[ \"properties\" ][ \"type\" ][ \"const\" ], attributes = BaseInfoAttributes ( api_version = __api_version__ , available_api_versions = [ { \"url\" : f \" { get_base_url ( request . url ) } /v { __api_version__ . split ( '.' )[ 0 ] } \" , \"version\" : __api_version__ , } ], formats = [ \"json\" ], entry_types_by_format = { \"json\" : list ( ENTRY_INFO_SCHEMAS . keys ())}, available_endpoints = sorted ( [ \"docs\" , \"info\" , \"links\" , \"openapi.json\" , \"redoc\" , \"search\" , ] + list ( ENTRY_INFO_SCHEMAS . keys ()) ), is_index = False , ), ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , ), )","title":"info"},{"location":"api_reference/routers/info/#info","text":"/info/* This file describes the router for: /info/{entry} where, entry may be left out.","title":"info"},{"location":"api_reference/routers/info/#optimade_gateway.routers.info.get_entry_info","text":"GET /info/{entry} Get information about the gateway service's entry-listing endpoints. Source code in optimade_gateway/routers/info.py @ROUTER . get ( \"/info/ {entry} \" , response_model = Union [ EntryInfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_entry_info ( request : Request , entry : str ) -> EntryInfoResponse : \"\"\"`GET /info/{entry}` Get information about the gateway service's entry-listing endpoints. \"\"\" from optimade.models import EntryInfoResource from optimade.server.exceptions import BadRequest from optimade_gateway.routers.utils import aretrieve_queryable_properties valid_entry_info_endpoints = ENTRY_INFO_SCHEMAS . keys () if entry not in valid_entry_info_endpoints : raise BadRequest ( title = \"Not Found\" , status_code = 404 , detail = ( f \"Entry info not found for { entry } , valid entry info endpoints are: \" f \" { ', ' . join ( valid_entry_info_endpoints ) } \" ), ) schema = ENTRY_INFO_SCHEMAS [ entry ]() queryable_properties = { \"id\" , \"type\" , \"attributes\" } properties = await aretrieve_queryable_properties ( schema , queryable_properties ) output_fields_by_format = { \"json\" : list ( properties . keys ())} return EntryInfoResponse ( data = EntryInfoResource ( formats = list ( output_fields_by_format . keys ()), description = schema . get ( \"description\" , \"Entry Resources\" ), properties = properties , output_fields_by_format = output_fields_by_format , ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , ), )","title":"get_entry_info()"},{"location":"api_reference/routers/info/#optimade_gateway.routers.info.get_info","text":"GET /info An introspective endpoint for the gateway service. Source code in optimade_gateway/routers/info.py @ROUTER . get ( \"/info\" , response_model = Union [ InfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_info ( request : Request ) -> InfoResponse : \"\"\"`GET /info` An introspective endpoint for the gateway service. \"\"\" return InfoResponse ( data = BaseInfoResource ( id = BaseInfoResource . schema ()[ \"properties\" ][ \"id\" ][ \"const\" ], type = BaseInfoResource . schema ()[ \"properties\" ][ \"type\" ][ \"const\" ], attributes = BaseInfoAttributes ( api_version = __api_version__ , available_api_versions = [ { \"url\" : f \" { get_base_url ( request . url ) } /v { __api_version__ . split ( '.' )[ 0 ] } \" , \"version\" : __api_version__ , } ], formats = [ \"json\" ], entry_types_by_format = { \"json\" : list ( ENTRY_INFO_SCHEMAS . keys ())}, available_endpoints = sorted ( [ \"docs\" , \"info\" , \"links\" , \"openapi.json\" , \"redoc\" , \"search\" , ] + list ( ENTRY_INFO_SCHEMAS . keys ()) ), is_index = False , ), ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , ), )","title":"get_info()"},{"location":"api_reference/routers/links/","text":"links \u00b6 /links/* This file describes the router for: /links get_links ( request , params = Depends ( NoneType )) async \u00b6 GET /links Return a regular /links response for an OPTIMADE implementation. Source code in optimade_gateway/routers/links.py @ROUTER . get ( \"/links\" , response_model = Union [ LinksResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Links\" ], ) async def get_links ( request : Request , params : EntryListingQueryParams = Depends () ) -> LinksResponse : \"\"\"`GET /links` Return a regular `/links` response for an OPTIMADE implementation. \"\"\" return await get_entries ( collection = LINKS_COLLECTION , response_cls = LinksResponse , request = request , params = params , )","title":"links"},{"location":"api_reference/routers/links/#links","text":"/links/* This file describes the router for: /links","title":"links"},{"location":"api_reference/routers/links/#optimade_gateway.routers.links.get_links","text":"GET /links Return a regular /links response for an OPTIMADE implementation. Source code in optimade_gateway/routers/links.py @ROUTER . get ( \"/links\" , response_model = Union [ LinksResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Links\" ], ) async def get_links ( request : Request , params : EntryListingQueryParams = Depends () ) -> LinksResponse : \"\"\"`GET /links` Return a regular `/links` response for an OPTIMADE implementation. \"\"\" return await get_entries ( collection = LINKS_COLLECTION , response_cls = LinksResponse , request = request , params = params , )","title":"get_links()"},{"location":"api_reference/routers/queries/","text":"queries \u00b6 General /queries endpoint to handle gateway queries This file describes the router for: /queries/{id} where, id may be left out. get_queries ( request , params = Depends ( NoneType )) async \u00b6 GET /queries Return overview of all (active) queries. Source code in optimade_gateway/routers/queries.py @ROUTER . get ( \"/queries\" , response_model = Union [ QueriesResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], ) async def get_queries ( request : Request , params : EntryListingQueryParams = Depends (), ) -> QueriesResponse : \"\"\"`GET /queries` Return overview of all (active) queries. \"\"\" from optimade_gateway.routers.utils import get_entries return await get_entries ( collection = QUERIES_COLLECTION , response_cls = QueriesResponse , request = request , params = params , ) get_query ( request , query_id , response ) async \u00b6 GET /queries/{query_id} Return the response from a query ( QueryResource.attributes.response ). Source code in optimade_gateway/routers/queries.py @ROUTER . get ( \"/queries/{query_id:path}\" , response_model = Union [ EntryResponseMany , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], ) async def get_query ( request : Request , query_id : str , response : Response , ) -> Union [ EntryResponseMany , ErrorResponse ]: \"\"\"`GET /queries/{query_id}` Return the response from a query ([`QueryResource.attributes.response`][optimade_gateway.models.queries.QueryResourceAttributes.response]). \"\"\" from optimade_gateway.routers.utils import get_valid_resource LOGGER . debug ( \"At /queries/<id> with id= %s \" , query_id ) query : QueryResource = await get_valid_resource ( QUERIES_COLLECTION , query_id ) LOGGER . debug ( \"Found query (in /queries/<id>): %s \" , query ) if query . attributes . state != QueryState . FINISHED : return EntryResponseMany ( data = [], meta = meta_values ( url = request . url , data_returned = 0 , data_available = None , # It is at this point unknown more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _query\" : query }, ), ) if query . attributes . response . errors : for error in query . attributes . response . errors : if error . status : response . status_code = int ( error . status ) break else : response . status_code = 500 return query . attributes . response post_queries ( request , query ) async \u00b6 POST /queries Create or return existing gateway query according to query . Source code in optimade_gateway/routers/queries.py @ROUTER . post ( \"/queries\" , response_model = Union [ QueriesResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], status_code = status . HTTP_202_ACCEPTED , ) async def post_queries ( request : Request , query : QueryCreate , ) -> QueriesResponseSingle : \"\"\"`POST /queries` Create or return existing gateway query according to `query`. \"\"\" from optimade_gateway.queries import perform_query from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.utils import resource_factory , validate_resource await validate_resource ( GATEWAYS_COLLECTION , query . gateway_id ) result , created = await resource_factory ( query ) if created : asyncio . create_task ( perform_query ( url = request . url , query = result , use_query_resource = True ) ) return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await QUERIES_COLLECTION . count (), more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"queries"},{"location":"api_reference/routers/queries/#queries","text":"General /queries endpoint to handle gateway queries This file describes the router for: /queries/{id} where, id may be left out.","title":"queries"},{"location":"api_reference/routers/queries/#optimade_gateway.routers.queries.get_queries","text":"GET /queries Return overview of all (active) queries. Source code in optimade_gateway/routers/queries.py @ROUTER . get ( \"/queries\" , response_model = Union [ QueriesResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], ) async def get_queries ( request : Request , params : EntryListingQueryParams = Depends (), ) -> QueriesResponse : \"\"\"`GET /queries` Return overview of all (active) queries. \"\"\" from optimade_gateway.routers.utils import get_entries return await get_entries ( collection = QUERIES_COLLECTION , response_cls = QueriesResponse , request = request , params = params , )","title":"get_queries()"},{"location":"api_reference/routers/queries/#optimade_gateway.routers.queries.get_query","text":"GET /queries/{query_id} Return the response from a query ( QueryResource.attributes.response ). Source code in optimade_gateway/routers/queries.py @ROUTER . get ( \"/queries/{query_id:path}\" , response_model = Union [ EntryResponseMany , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], ) async def get_query ( request : Request , query_id : str , response : Response , ) -> Union [ EntryResponseMany , ErrorResponse ]: \"\"\"`GET /queries/{query_id}` Return the response from a query ([`QueryResource.attributes.response`][optimade_gateway.models.queries.QueryResourceAttributes.response]). \"\"\" from optimade_gateway.routers.utils import get_valid_resource LOGGER . debug ( \"At /queries/<id> with id= %s \" , query_id ) query : QueryResource = await get_valid_resource ( QUERIES_COLLECTION , query_id ) LOGGER . debug ( \"Found query (in /queries/<id>): %s \" , query ) if query . attributes . state != QueryState . FINISHED : return EntryResponseMany ( data = [], meta = meta_values ( url = request . url , data_returned = 0 , data_available = None , # It is at this point unknown more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _query\" : query }, ), ) if query . attributes . response . errors : for error in query . attributes . response . errors : if error . status : response . status_code = int ( error . status ) break else : response . status_code = 500 return query . attributes . response","title":"get_query()"},{"location":"api_reference/routers/queries/#optimade_gateway.routers.queries.post_queries","text":"POST /queries Create or return existing gateway query according to query . Source code in optimade_gateway/routers/queries.py @ROUTER . post ( \"/queries\" , response_model = Union [ QueriesResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Queries\" ], status_code = status . HTTP_202_ACCEPTED , ) async def post_queries ( request : Request , query : QueryCreate , ) -> QueriesResponseSingle : \"\"\"`POST /queries` Create or return existing gateway query according to `query`. \"\"\" from optimade_gateway.queries import perform_query from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.utils import resource_factory , validate_resource await validate_resource ( GATEWAYS_COLLECTION , query . gateway_id ) result , created = await resource_factory ( query ) if created : asyncio . create_task ( perform_query ( url = request . url , query = result , use_query_resource = True ) ) return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = result , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await QUERIES_COLLECTION . count (), more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"post_queries()"},{"location":"api_reference/routers/search/","text":"search \u00b6 General /search endpoint to completely coordinate an OPTIMADE gateway query This file describes the router for: /search get_search ( request , response , search_params = Depends ( NoneType ), entry_params = Depends ( NoneType )) async \u00b6 GET /search Coordinate a new OPTIMADE query in multiple databases through a gateway: Create a Search POST data - calling POST /search Wait search_params.timeout seconds until the query has finished Return successful response Contingency If the query has not finished within the set timeout period, the client will be redirected to the query's URL instead. Source code in optimade_gateway/routers/search.py @ROUTER . get ( \"/search\" , response_model = Union [ EntryResponseMany , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Search\" ], ) async def get_search ( request : Request , response : Response , search_params : SearchQueryParams = Depends (), entry_params : EntryListingQueryParams = Depends (), ) -> Union [ EntryResponseMany , ErrorResponse , RedirectResponse ]: \"\"\"`GET /search` Coordinate a new OPTIMADE query in multiple databases through a gateway: 1. Create a [`Search`][optimade_gateway.models.search.Search] `POST` data - calling `POST /search` 1. Wait [`search_params.timeout`][optimade_gateway.queries.params.SearchQueryParams] seconds until the query has finished 1. Return successful response !!! important \"Contingency\" If the query has not finished within the set timeout period, the client will be redirected to the query's URL instead. \"\"\" from time import time from optimade_gateway.routers.queries import QUERIES_COLLECTION try : search = Search ( query_parameters = OptimadeQueryParameters ( ** { field : getattr ( entry_params , field ) for field in OptimadeQueryParameters . __fields__ if getattr ( entry_params , field ) } ), optimade_urls = search_params . optimade_urls , endpoint = search_params . endpoint , database_ids = search_params . database_ids , ) except ValidationError as exc : raise BadRequest ( detail = ( \"A Search object could not be created from the given URL query parameters. \" f \"Error(s): { [ exc . errors ] } \" ) ) queries_response = await post_search ( request , search = search ) once = True start_time = time () while time () < ( start_time + search_params . timeout ) or once : # Make sure to run this at least once (e.g., if timeout=0) once = False query : QueryResource = await QUERIES_COLLECTION . get_one ( ** { \"filter\" : { \"id\" : queries_response . data . id }} ) if query . attributes . state == QueryState . FINISHED : if query . attributes . response . errors : for error in query . attributes . response . errors : if error . status : response . status_code = int ( error . status ) break else : response . status_code = 500 return query . attributes . response await asyncio . sleep ( 0.1 ) # The query has not yet succeeded and we're past the timeout time -> Redirect to /queries/<id> return RedirectResponse ( query . links . self ) post_search ( request , search ) async \u00b6 POST /search Coordinate a new OPTIMADE query in multiple databases through a gateway: Search for gateway in DB using optimade_urls and database_ids Create GatewayCreate model POST gateway resource to get ID - using functionality of POST /gateways Create new Query resource POST Query resource - using functionality of POST /queries Return POST /queries response - QueriesResponseSingle Source code in optimade_gateway/routers/search.py @ROUTER . post ( \"/search\" , response_model = Union [ QueriesResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Search\" ], status_code = status . HTTP_202_ACCEPTED , ) async def post_search ( request : Request , search : Search ) -> QueriesResponseSingle : \"\"\"`POST /search` Coordinate a new OPTIMADE query in multiple databases through a gateway: 1. Search for gateway in DB using `optimade_urls` and `database_ids` 1. Create [`GatewayCreate`][optimade_gateway.models.gateways.GatewayCreate] model 1. `POST` gateway resource to get ID - using functionality of `POST /gateways` 1. Create new [Query][optimade_gateway.models.queries.QueryCreate] resource 1. `POST` Query resource - using functionality of `POST /queries` 1. Return `POST /queries` response - [`QueriesResponseSingle`][optimade_gateway.models.responses.QueriesResponseSingle] \"\"\" from optimade_gateway.routers.databases import DATABASES_COLLECTION from optimade_gateway.routers.queries import QUERIES_COLLECTION from optimade_gateway.routers.utils import resource_factory # NOTE: It may be that the final list of base URLs (`base_urls`) contains the same provider(s), # but with differring base URLS, if, for example, a versioned base URL is supplied. base_urls = set () if search . database_ids : databases = await DATABASES_COLLECTION . get_multiple ( filter = { \"id\" : { \"$in\" : await clean_python_types ( search . database_ids )}} ) base_urls |= set ( [ get_resource_attribute ( database , \"attributes.base_url\" ) for database in databases if get_resource_attribute ( database , \"attributes.base_url\" ) is not None ] ) if search . optimade_urls : base_urls |= set ([ _ for _ in search . optimade_urls if _ is not None ]) if not base_urls : msg = \"No (valid) OPTIMADE URLs with:\" if search . database_ids : msg += ( f \" \\n Database IDs: { search . database_ids } and corresponding found URLs: \" f \" { [ get_resource_attribute ( database , 'attributes.base_url' ) for database in databases ] } \" ) if search . optimade_urls : msg += f \" \\n Passed OPTIMADE URLs: { search . optimade_urls } \" raise BadRequest ( detail = msg ) # Ensure all URLs are `pydantic.AnyUrl`s if not all ([ isinstance ( _ , AnyUrl ) for _ in base_urls ]): raise HTTPException ( status_code = 500 , detail = \"Could unexpectedly not get all base URLs as `pydantic.AnyUrl`s.\" , ) gateway = GatewayCreate ( databases = [ LinksResource ( id = ( f \" { url . user + '@' if url . user else '' }{ url . host } \" f \" { ':' + url . port if url . port else '' } \" f \" { url . path . rstrip ( '/' ) if url . path else '' } \" ), type = \"links\" , attributes = LinksResourceAttributes ( name = ( f \" { url . user + '@' if url . user else '' }{ url . host } \" f \" { ':' + url . port if url . port else '' } \" f \" { url . path . rstrip ( '/' ) if url . path else '' } \" ), description = \"\" , base_url = url , link_type = LinkType . CHILD , homepage = None , ), ) for url in base_urls ] ) gateway , created = await resource_factory ( gateway ) if created : LOGGER . debug ( \"A new gateway was created for a query (id= %r )\" , gateway . id ) else : LOGGER . debug ( \"A gateway was found and reused for a query (id= %r )\" , gateway . id ) query = QueryCreate ( endpoint = search . endpoint , endpoint_model = ENDPOINT_MODELS . get ( search . endpoint ), gateway_id = gateway . id , query_parameters = search . query_parameters , ) query , created = await resource_factory ( query ) if created : asyncio . create_task ( perform_query ( url = request . url , query = query , use_query_resource = True ) ) return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = query , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await QUERIES_COLLECTION . count (), more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"search"},{"location":"api_reference/routers/search/#search","text":"General /search endpoint to completely coordinate an OPTIMADE gateway query This file describes the router for: /search","title":"search"},{"location":"api_reference/routers/search/#optimade_gateway.routers.search.get_search","text":"GET /search Coordinate a new OPTIMADE query in multiple databases through a gateway: Create a Search POST data - calling POST /search Wait search_params.timeout seconds until the query has finished Return successful response Contingency If the query has not finished within the set timeout period, the client will be redirected to the query's URL instead. Source code in optimade_gateway/routers/search.py @ROUTER . get ( \"/search\" , response_model = Union [ EntryResponseMany , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Search\" ], ) async def get_search ( request : Request , response : Response , search_params : SearchQueryParams = Depends (), entry_params : EntryListingQueryParams = Depends (), ) -> Union [ EntryResponseMany , ErrorResponse , RedirectResponse ]: \"\"\"`GET /search` Coordinate a new OPTIMADE query in multiple databases through a gateway: 1. Create a [`Search`][optimade_gateway.models.search.Search] `POST` data - calling `POST /search` 1. Wait [`search_params.timeout`][optimade_gateway.queries.params.SearchQueryParams] seconds until the query has finished 1. Return successful response !!! important \"Contingency\" If the query has not finished within the set timeout period, the client will be redirected to the query's URL instead. \"\"\" from time import time from optimade_gateway.routers.queries import QUERIES_COLLECTION try : search = Search ( query_parameters = OptimadeQueryParameters ( ** { field : getattr ( entry_params , field ) for field in OptimadeQueryParameters . __fields__ if getattr ( entry_params , field ) } ), optimade_urls = search_params . optimade_urls , endpoint = search_params . endpoint , database_ids = search_params . database_ids , ) except ValidationError as exc : raise BadRequest ( detail = ( \"A Search object could not be created from the given URL query parameters. \" f \"Error(s): { [ exc . errors ] } \" ) ) queries_response = await post_search ( request , search = search ) once = True start_time = time () while time () < ( start_time + search_params . timeout ) or once : # Make sure to run this at least once (e.g., if timeout=0) once = False query : QueryResource = await QUERIES_COLLECTION . get_one ( ** { \"filter\" : { \"id\" : queries_response . data . id }} ) if query . attributes . state == QueryState . FINISHED : if query . attributes . response . errors : for error in query . attributes . response . errors : if error . status : response . status_code = int ( error . status ) break else : response . status_code = 500 return query . attributes . response await asyncio . sleep ( 0.1 ) # The query has not yet succeeded and we're past the timeout time -> Redirect to /queries/<id> return RedirectResponse ( query . links . self )","title":"get_search()"},{"location":"api_reference/routers/search/#optimade_gateway.routers.search.post_search","text":"POST /search Coordinate a new OPTIMADE query in multiple databases through a gateway: Search for gateway in DB using optimade_urls and database_ids Create GatewayCreate model POST gateway resource to get ID - using functionality of POST /gateways Create new Query resource POST Query resource - using functionality of POST /queries Return POST /queries response - QueriesResponseSingle Source code in optimade_gateway/routers/search.py @ROUTER . post ( \"/search\" , response_model = Union [ QueriesResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Search\" ], status_code = status . HTTP_202_ACCEPTED , ) async def post_search ( request : Request , search : Search ) -> QueriesResponseSingle : \"\"\"`POST /search` Coordinate a new OPTIMADE query in multiple databases through a gateway: 1. Search for gateway in DB using `optimade_urls` and `database_ids` 1. Create [`GatewayCreate`][optimade_gateway.models.gateways.GatewayCreate] model 1. `POST` gateway resource to get ID - using functionality of `POST /gateways` 1. Create new [Query][optimade_gateway.models.queries.QueryCreate] resource 1. `POST` Query resource - using functionality of `POST /queries` 1. Return `POST /queries` response - [`QueriesResponseSingle`][optimade_gateway.models.responses.QueriesResponseSingle] \"\"\" from optimade_gateway.routers.databases import DATABASES_COLLECTION from optimade_gateway.routers.queries import QUERIES_COLLECTION from optimade_gateway.routers.utils import resource_factory # NOTE: It may be that the final list of base URLs (`base_urls`) contains the same provider(s), # but with differring base URLS, if, for example, a versioned base URL is supplied. base_urls = set () if search . database_ids : databases = await DATABASES_COLLECTION . get_multiple ( filter = { \"id\" : { \"$in\" : await clean_python_types ( search . database_ids )}} ) base_urls |= set ( [ get_resource_attribute ( database , \"attributes.base_url\" ) for database in databases if get_resource_attribute ( database , \"attributes.base_url\" ) is not None ] ) if search . optimade_urls : base_urls |= set ([ _ for _ in search . optimade_urls if _ is not None ]) if not base_urls : msg = \"No (valid) OPTIMADE URLs with:\" if search . database_ids : msg += ( f \" \\n Database IDs: { search . database_ids } and corresponding found URLs: \" f \" { [ get_resource_attribute ( database , 'attributes.base_url' ) for database in databases ] } \" ) if search . optimade_urls : msg += f \" \\n Passed OPTIMADE URLs: { search . optimade_urls } \" raise BadRequest ( detail = msg ) # Ensure all URLs are `pydantic.AnyUrl`s if not all ([ isinstance ( _ , AnyUrl ) for _ in base_urls ]): raise HTTPException ( status_code = 500 , detail = \"Could unexpectedly not get all base URLs as `pydantic.AnyUrl`s.\" , ) gateway = GatewayCreate ( databases = [ LinksResource ( id = ( f \" { url . user + '@' if url . user else '' }{ url . host } \" f \" { ':' + url . port if url . port else '' } \" f \" { url . path . rstrip ( '/' ) if url . path else '' } \" ), type = \"links\" , attributes = LinksResourceAttributes ( name = ( f \" { url . user + '@' if url . user else '' }{ url . host } \" f \" { ':' + url . port if url . port else '' } \" f \" { url . path . rstrip ( '/' ) if url . path else '' } \" ), description = \"\" , base_url = url , link_type = LinkType . CHILD , homepage = None , ), ) for url in base_urls ] ) gateway , created = await resource_factory ( gateway ) if created : LOGGER . debug ( \"A new gateway was created for a query (id= %r )\" , gateway . id ) else : LOGGER . debug ( \"A gateway was found and reused for a query (id= %r )\" , gateway . id ) query = QueryCreate ( endpoint = search . endpoint , endpoint_model = ENDPOINT_MODELS . get ( search . endpoint ), gateway_id = gateway . id , query_parameters = search . query_parameters , ) query , created = await resource_factory ( query ) if created : asyncio . create_task ( perform_query ( url = request . url , query = query , use_query_resource = True ) ) return QueriesResponseSingle ( links = ToplevelLinks ( next = None ), data = query , meta = meta_values ( url = request . url , data_returned = 1 , data_available = await QUERIES_COLLECTION . count (), more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _created\" : created }, ), )","title":"post_search()"},{"location":"api_reference/routers/utils/","text":"utils \u00b6 Utility functions for all routers aretrieve_queryable_properties ( schema , queryable_properties ) async \u00b6 Asynchronous implementation of retrieve_queryable_properties() from optimade Reference to the function in the optimade API documentation: retrieve_queryable_properties() . Recursively loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: Name Type Description Default schema dict The schema of the pydantic model. required queryable_properties list The list of properties to find in the schema. required Returns: Type Description dict A flat dictionary with properties as keys, containing the field description, unit, sortability, support level, queryability and type, where provided. Source code in optimade_gateway/routers/utils.py async def aretrieve_queryable_properties ( schema : dict , queryable_properties : list ) -> dict : \"\"\"Asynchronous implementation of `retrieve_queryable_properties()` from `optimade` Reference to the function in the `optimade` API documentation: [`retrieve_queryable_properties()`](https://www.optimade.org/optimade-python-tools/api_reference/server/schemas/#optimade.server.schemas.retrieve_queryable_properties). Recursively loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: schema: The schema of the pydantic model. queryable_properties: The list of properties to find in the schema. Returns: A flat dictionary with properties as keys, containing the field description, unit, sortability, support level, queryability and type, where provided. \"\"\" from optimade.server.schemas import retrieve_queryable_properties return retrieve_queryable_properties ( schema = schema , queryable_properties = queryable_properties , ) get_entries ( collection , response_cls , request , params ) async \u00b6 Generalized /{entries} endpoint getter Source code in optimade_gateway/routers/utils.py async def get_entries ( collection : AsyncMongoCollection , response_cls : EntryResponseMany , request : Request , params : EntryListingQueryParams , ) -> EntryResponseMany : \"\"\"Generalized `/{entries}` endpoint getter\"\"\" results , more_data_available , fields = await collection . find ( params = params ) if more_data_available : # Deduce the `next` link from the current request query = urllib . parse . parse_qs ( request . url . query ) query [ \"page_offset\" ] = int ( query . get ( \"page_offset\" , [ 0 ])[ 0 ]) + len ( results ) urlencoded = urllib . parse . urlencode ( query , doseq = True ) base_url = get_base_url ( request . url ) links = ToplevelLinks ( next = f \" { base_url }{ request . url . path } ? { urlencoded } \" ) else : links = ToplevelLinks ( next = None ) if fields : results = handle_response_fields ( results , fields ) return response_cls ( links = links , data = results , meta = meta_values ( url = request . url , data_returned = await collection . count ( params = params ), data_available = await collection . count (), more_data_available = more_data_available , ), ) get_valid_resource ( collection , entry_id ) async \u00b6 Validate and retrieve a resource Source code in optimade_gateway/routers/utils.py async def get_valid_resource ( collection : AsyncMongoCollection , entry_id : str ) -> EntryResource : \"\"\"Validate and retrieve a resource\"\"\" from optimade_gateway.routers.utils import validate_resource await validate_resource ( collection , entry_id ) return await collection . get_one ( filter = { \"id\" : entry_id }) resource_factory ( create_resource ) async \u00b6 Get or create a resource Currently supported resources: \"databases\" ( DatabaseCreate -> LinksResource ) \"gateways\" ( GatewayCreate -> GatewayResource ) \"queries\" ( QueryCreate -> QueryResource ) For each of the resources, \"uniqueness\" is determined in the following way: Databases The base_url field is considered unique across all databases. If a base_url is provided via a Link model, the base_url.href value is used to query the MongoDB. Gateways The collected list of databases.attributes.base_url values is considered unique across all gateways. In the database, the search is done as a combination of the length/size of the databases ' Python list/MongoDB array and a match on all (using the MongoDB $all operator) of the databases.attributes.base_url element values, when compared with the create_resource . Queries The gateway_id , query_parameters , and endpoint fields are collectively considered to define uniqueness for a QueryResource in the MongoDB collection. Attention Only the /structures entry endpoint can be queried with multiple expected responses. This means the endpoint field defaults to \"structures\" and endpoint_model defaults to (\"optimade.models.responses\", \"StructureResponseMany\") , i.e., the StructureResponseMany response model. Parameters: Name Type Description Default create_resource Union[optimade_gateway.models.databases.DatabaseCreate, optimade_gateway.models.gateways.GatewayCreate, optimade_gateway.models.queries.QueryCreate] The resource to be retrieved or created anew. required Returns: Type Description Tuple[Union[optimade.models.links.LinksResource, optimade_gateway.models.gateways.GatewayResource, optimade_gateway.models.queries.QueryResource], bool] Two things in a tuple: Either a GatewayResource ; a QueryResource ; or a LinksResource and whether or not the resource was newly created. Source code in optimade_gateway/routers/utils.py async def resource_factory ( create_resource : Union [ DatabaseCreate , GatewayCreate , QueryCreate ] ) -> Tuple [ Union [ LinksResource , GatewayResource , QueryResource ], bool ]: \"\"\"Get or create a resource Currently supported resources: - `\"databases\"` ([`DatabaseCreate`][optimade_gateway.models.databases.DatabaseCreate] -> [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource)) - `\"gateways\"` ([`GatewayCreate`][optimade_gateway.models.gateways.GatewayCreate] -> [`GatewayResource`][optimade_gateway.models.gateways.GatewayResource]) - `\"queries\"` ([`QueryCreate`][optimade_gateway.models.queries.QueryCreate] -> [`QueryResource`][optimade_gateway.models.queries.QueryResource]) For each of the resources, \"uniqueness\" is determined in the following way: === \"Databases\" The `base_url` field is considered unique across all databases. If a `base_url` is provided via a [`Link`](https://www.optimade.org/optimade-python-tools/api_reference/models/jsonapi/#optimade.models.jsonapi.Link) model, the `base_url.href` value is used to query the MongoDB. === \"Gateways\" The collected list of `databases.attributes.base_url` values is considered unique across all gateways. In the database, the search is done as a combination of the length/size of the `databases`' Python list/MongoDB array and a match on all (using the MongoDB `$all` operator) of the [`databases.attributes.base_url`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResourceAttributes.base_url) element values, when compared with the `create_resource`. === \"Queries\" The `gateway_id`, `query_parameters`, and `endpoint` fields are collectively considered to define uniqueness for a [`QueryResource`][optimade_gateway.models.queries.QueryResource] in the MongoDB collection. !!! attention Only the `/structures` entry endpoint can be queried with multiple expected responses. This means the `endpoint` field defaults to `\"structures\"` and `endpoint_model` defaults to `(\"optimade.models.responses\", \"StructureResponseMany\")`, i.e., the [`StructureResponseMany`](https://www.optimade.org/optimade-python-tools/api_reference/models/responses/#optimade.models.responses.StructureResponseMany) response model. Parameters: create_resource: The resource to be retrieved or created anew. Returns: Two things in a tuple: - Either a [`GatewayResource`][optimade_gateway.models.gateways.GatewayResource]; a [`QueryResource`][optimade_gateway.models.queries.QueryResource]; or a [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) and - whether or not the resource was newly created. \"\"\" from optimade_gateway.common.utils import clean_python_types , get_resource_attribute created = False if isinstance ( create_resource , DatabaseCreate ): from optimade_gateway.routers.databases import ( DATABASES_COLLECTION as RESOURCE_COLLECTION , ) base_url = get_resource_attribute ( create_resource , \"base_url\" ) mongo_query = { \"$or\" : [ { \"base_url\" : { \"$eq\" : await clean_python_types ( base_url )}}, { \"base_url.href\" : { \"$eq\" : await clean_python_types ( base_url )}}, ] } elif isinstance ( create_resource , GatewayCreate ): from optimade_gateway.routers.gateways import ( GATEWAYS_COLLECTION as RESOURCE_COLLECTION , ) mongo_query = { \"databases\" : { \"$size\" : len ( create_resource . databases )}, \"databases.attributes.base_url\" : { \"$all\" : await clean_python_types ( [ _ . attributes . base_url for _ in create_resource . databases ] ) }, } elif isinstance ( create_resource , QueryCreate ): from optimade_gateway.models.queries import QueryState from optimade_gateway.routers.queries import ( QUERIES_COLLECTION as RESOURCE_COLLECTION , ) # Currently only /structures entry endpoints can be queried with multiple expected responses. create_resource . endpoint = ( create_resource . endpoint if create_resource . endpoint else \"structures\" ) create_resource . endpoint_model = ( create_resource . endpoint_model if create_resource . endpoint_model else ( \"optimade.models.responses\" , \"StructureResponseMany\" ) ) mongo_query = { \"gateway_id\" : { \"$eq\" : create_resource . gateway_id }, \"query_parameters\" : { \"$eq\" : await clean_python_types ( create_resource . query_parameters ), }, \"endpoint\" : { \"$eq\" : create_resource . endpoint }, } else : raise TypeError ( \"create_resource must be either a GatewayCreate or QueryCreate object not \" f \" { type ( create_resource ) !r} \" ) result , more_data_available , _ = await RESOURCE_COLLECTION . find ( criteria = { \"filter\" : mongo_query } ) if more_data_available : raise OptimadeGatewayError ( \"more_data_available MUST be False for a single entry response, however it is \" f \" { more_data_available } \" ) if result : if len ( result ) > 1 : raise OptimadeGatewayError ( f \"More than one { result [ 0 ] . type } were found. IDs of found { result [ 0 ] . type } : \" f \" { [ _ . id for _ in result ] } \" ) result = result [ 0 ] else : if isinstance ( create_resource , DatabaseCreate ): # Set required `LinksResourceAttributes` values if not set if not create_resource . description : create_resource . description = f \" { create_resource . name } created by OPTIMADE gateway database registration.\" if not create_resource . link_type : create_resource . link_type = LinkType . EXTERNAL if not create_resource . homepage : create_resource . homepage = None elif isinstance ( create_resource , GatewayCreate ): # Do not store `database_ids` if \"database_ids\" in create_resource . __fields_set__ : create_resource . database_ids = None create_resource . __fields_set__ . remove ( \"database_ids\" ) elif isinstance ( create_resource , QueryCreate ): create_resource . state = QueryState . CREATED result = await RESOURCE_COLLECTION . create_one ( create_resource ) LOGGER . debug ( \"Created new %s : %r \" , result . type , result ) created = True return result , created validate_resource ( collection , entry_id ) async \u00b6 Validate whether a resource exists in a collection Source code in optimade_gateway/routers/utils.py async def validate_resource ( collection : AsyncMongoCollection , entry_id : str ) -> None : \"\"\"Validate whether a resource exists in a collection\"\"\" if not await collection . exists ( entry_id ): raise BadRequest ( title = \"Not Found\" , status_code = 404 , detail = f \"Resource <id= { entry_id } > not found in { collection } .\" , )","title":"utils"},{"location":"api_reference/routers/utils/#utils","text":"Utility functions for all routers","title":"utils"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.aretrieve_queryable_properties","text":"Asynchronous implementation of retrieve_queryable_properties() from optimade Reference to the function in the optimade API documentation: retrieve_queryable_properties() . Recursively loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: Name Type Description Default schema dict The schema of the pydantic model. required queryable_properties list The list of properties to find in the schema. required Returns: Type Description dict A flat dictionary with properties as keys, containing the field description, unit, sortability, support level, queryability and type, where provided. Source code in optimade_gateway/routers/utils.py async def aretrieve_queryable_properties ( schema : dict , queryable_properties : list ) -> dict : \"\"\"Asynchronous implementation of `retrieve_queryable_properties()` from `optimade` Reference to the function in the `optimade` API documentation: [`retrieve_queryable_properties()`](https://www.optimade.org/optimade-python-tools/api_reference/server/schemas/#optimade.server.schemas.retrieve_queryable_properties). Recursively loops through the schema of a pydantic model and resolves all references, returning a dictionary of all the OPTIMADE-queryable properties of that model. Parameters: schema: The schema of the pydantic model. queryable_properties: The list of properties to find in the schema. Returns: A flat dictionary with properties as keys, containing the field description, unit, sortability, support level, queryability and type, where provided. \"\"\" from optimade.server.schemas import retrieve_queryable_properties return retrieve_queryable_properties ( schema = schema , queryable_properties = queryable_properties , )","title":"aretrieve_queryable_properties()"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.get_entries","text":"Generalized /{entries} endpoint getter Source code in optimade_gateway/routers/utils.py async def get_entries ( collection : AsyncMongoCollection , response_cls : EntryResponseMany , request : Request , params : EntryListingQueryParams , ) -> EntryResponseMany : \"\"\"Generalized `/{entries}` endpoint getter\"\"\" results , more_data_available , fields = await collection . find ( params = params ) if more_data_available : # Deduce the `next` link from the current request query = urllib . parse . parse_qs ( request . url . query ) query [ \"page_offset\" ] = int ( query . get ( \"page_offset\" , [ 0 ])[ 0 ]) + len ( results ) urlencoded = urllib . parse . urlencode ( query , doseq = True ) base_url = get_base_url ( request . url ) links = ToplevelLinks ( next = f \" { base_url }{ request . url . path } ? { urlencoded } \" ) else : links = ToplevelLinks ( next = None ) if fields : results = handle_response_fields ( results , fields ) return response_cls ( links = links , data = results , meta = meta_values ( url = request . url , data_returned = await collection . count ( params = params ), data_available = await collection . count (), more_data_available = more_data_available , ), )","title":"get_entries()"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.get_valid_resource","text":"Validate and retrieve a resource Source code in optimade_gateway/routers/utils.py async def get_valid_resource ( collection : AsyncMongoCollection , entry_id : str ) -> EntryResource : \"\"\"Validate and retrieve a resource\"\"\" from optimade_gateway.routers.utils import validate_resource await validate_resource ( collection , entry_id ) return await collection . get_one ( filter = { \"id\" : entry_id })","title":"get_valid_resource()"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.resource_factory","text":"Get or create a resource Currently supported resources: \"databases\" ( DatabaseCreate -> LinksResource ) \"gateways\" ( GatewayCreate -> GatewayResource ) \"queries\" ( QueryCreate -> QueryResource ) For each of the resources, \"uniqueness\" is determined in the following way: Databases The base_url field is considered unique across all databases. If a base_url is provided via a Link model, the base_url.href value is used to query the MongoDB. Gateways The collected list of databases.attributes.base_url values is considered unique across all gateways. In the database, the search is done as a combination of the length/size of the databases ' Python list/MongoDB array and a match on all (using the MongoDB $all operator) of the databases.attributes.base_url element values, when compared with the create_resource . Queries The gateway_id , query_parameters , and endpoint fields are collectively considered to define uniqueness for a QueryResource in the MongoDB collection. Attention Only the /structures entry endpoint can be queried with multiple expected responses. This means the endpoint field defaults to \"structures\" and endpoint_model defaults to (\"optimade.models.responses\", \"StructureResponseMany\") , i.e., the StructureResponseMany response model. Parameters: Name Type Description Default create_resource Union[optimade_gateway.models.databases.DatabaseCreate, optimade_gateway.models.gateways.GatewayCreate, optimade_gateway.models.queries.QueryCreate] The resource to be retrieved or created anew. required Returns: Type Description Tuple[Union[optimade.models.links.LinksResource, optimade_gateway.models.gateways.GatewayResource, optimade_gateway.models.queries.QueryResource], bool] Two things in a tuple: Either a GatewayResource ; a QueryResource ; or a LinksResource and whether or not the resource was newly created. Source code in optimade_gateway/routers/utils.py async def resource_factory ( create_resource : Union [ DatabaseCreate , GatewayCreate , QueryCreate ] ) -> Tuple [ Union [ LinksResource , GatewayResource , QueryResource ], bool ]: \"\"\"Get or create a resource Currently supported resources: - `\"databases\"` ([`DatabaseCreate`][optimade_gateway.models.databases.DatabaseCreate] -> [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource)) - `\"gateways\"` ([`GatewayCreate`][optimade_gateway.models.gateways.GatewayCreate] -> [`GatewayResource`][optimade_gateway.models.gateways.GatewayResource]) - `\"queries\"` ([`QueryCreate`][optimade_gateway.models.queries.QueryCreate] -> [`QueryResource`][optimade_gateway.models.queries.QueryResource]) For each of the resources, \"uniqueness\" is determined in the following way: === \"Databases\" The `base_url` field is considered unique across all databases. If a `base_url` is provided via a [`Link`](https://www.optimade.org/optimade-python-tools/api_reference/models/jsonapi/#optimade.models.jsonapi.Link) model, the `base_url.href` value is used to query the MongoDB. === \"Gateways\" The collected list of `databases.attributes.base_url` values is considered unique across all gateways. In the database, the search is done as a combination of the length/size of the `databases`' Python list/MongoDB array and a match on all (using the MongoDB `$all` operator) of the [`databases.attributes.base_url`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResourceAttributes.base_url) element values, when compared with the `create_resource`. === \"Queries\" The `gateway_id`, `query_parameters`, and `endpoint` fields are collectively considered to define uniqueness for a [`QueryResource`][optimade_gateway.models.queries.QueryResource] in the MongoDB collection. !!! attention Only the `/structures` entry endpoint can be queried with multiple expected responses. This means the `endpoint` field defaults to `\"structures\"` and `endpoint_model` defaults to `(\"optimade.models.responses\", \"StructureResponseMany\")`, i.e., the [`StructureResponseMany`](https://www.optimade.org/optimade-python-tools/api_reference/models/responses/#optimade.models.responses.StructureResponseMany) response model. Parameters: create_resource: The resource to be retrieved or created anew. Returns: Two things in a tuple: - Either a [`GatewayResource`][optimade_gateway.models.gateways.GatewayResource]; a [`QueryResource`][optimade_gateway.models.queries.QueryResource]; or a [`LinksResource`](https://www.optimade.org/optimade-python-tools/api_reference/models/links/#optimade.models.links.LinksResource) and - whether or not the resource was newly created. \"\"\" from optimade_gateway.common.utils import clean_python_types , get_resource_attribute created = False if isinstance ( create_resource , DatabaseCreate ): from optimade_gateway.routers.databases import ( DATABASES_COLLECTION as RESOURCE_COLLECTION , ) base_url = get_resource_attribute ( create_resource , \"base_url\" ) mongo_query = { \"$or\" : [ { \"base_url\" : { \"$eq\" : await clean_python_types ( base_url )}}, { \"base_url.href\" : { \"$eq\" : await clean_python_types ( base_url )}}, ] } elif isinstance ( create_resource , GatewayCreate ): from optimade_gateway.routers.gateways import ( GATEWAYS_COLLECTION as RESOURCE_COLLECTION , ) mongo_query = { \"databases\" : { \"$size\" : len ( create_resource . databases )}, \"databases.attributes.base_url\" : { \"$all\" : await clean_python_types ( [ _ . attributes . base_url for _ in create_resource . databases ] ) }, } elif isinstance ( create_resource , QueryCreate ): from optimade_gateway.models.queries import QueryState from optimade_gateway.routers.queries import ( QUERIES_COLLECTION as RESOURCE_COLLECTION , ) # Currently only /structures entry endpoints can be queried with multiple expected responses. create_resource . endpoint = ( create_resource . endpoint if create_resource . endpoint else \"structures\" ) create_resource . endpoint_model = ( create_resource . endpoint_model if create_resource . endpoint_model else ( \"optimade.models.responses\" , \"StructureResponseMany\" ) ) mongo_query = { \"gateway_id\" : { \"$eq\" : create_resource . gateway_id }, \"query_parameters\" : { \"$eq\" : await clean_python_types ( create_resource . query_parameters ), }, \"endpoint\" : { \"$eq\" : create_resource . endpoint }, } else : raise TypeError ( \"create_resource must be either a GatewayCreate or QueryCreate object not \" f \" { type ( create_resource ) !r} \" ) result , more_data_available , _ = await RESOURCE_COLLECTION . find ( criteria = { \"filter\" : mongo_query } ) if more_data_available : raise OptimadeGatewayError ( \"more_data_available MUST be False for a single entry response, however it is \" f \" { more_data_available } \" ) if result : if len ( result ) > 1 : raise OptimadeGatewayError ( f \"More than one { result [ 0 ] . type } were found. IDs of found { result [ 0 ] . type } : \" f \" { [ _ . id for _ in result ] } \" ) result = result [ 0 ] else : if isinstance ( create_resource , DatabaseCreate ): # Set required `LinksResourceAttributes` values if not set if not create_resource . description : create_resource . description = f \" { create_resource . name } created by OPTIMADE gateway database registration.\" if not create_resource . link_type : create_resource . link_type = LinkType . EXTERNAL if not create_resource . homepage : create_resource . homepage = None elif isinstance ( create_resource , GatewayCreate ): # Do not store `database_ids` if \"database_ids\" in create_resource . __fields_set__ : create_resource . database_ids = None create_resource . __fields_set__ . remove ( \"database_ids\" ) elif isinstance ( create_resource , QueryCreate ): create_resource . state = QueryState . CREATED result = await RESOURCE_COLLECTION . create_one ( create_resource ) LOGGER . debug ( \"Created new %s : %r \" , result . type , result ) created = True return result , created","title":"resource_factory()"},{"location":"api_reference/routers/utils/#optimade_gateway.routers.utils.validate_resource","text":"Validate whether a resource exists in a collection Source code in optimade_gateway/routers/utils.py async def validate_resource ( collection : AsyncMongoCollection , entry_id : str ) -> None : \"\"\"Validate whether a resource exists in a collection\"\"\" if not await collection . exists ( entry_id ): raise BadRequest ( title = \"Not Found\" , status_code = 404 , detail = f \"Resource <id= { entry_id } > not found in { collection } .\" , )","title":"validate_resource()"},{"location":"api_reference/routers/gateway/info/","text":"info \u00b6 /gateways/{id}/info/* This file describes the router for: /gateways/{id}/{version}/info/{entry} where version and entry may be left out. get_gateways_entry_info ( request , gateway_id , entry ) async \u00b6 GET /gateways/{gateway_id}/info/{entry} Get information about the gateway {gateway_id} 's entry-listing endpoints. Source code in optimade_gateway/routers/gateway/info.py @ROUTER . get ( \"/gateways/ {gateway_id} /info/ {entry} \" , response_model = Union [ EntryInfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_gateways_entry_info ( request : Request , gateway_id : str , entry : str ) -> EntryInfoResponse : \"\"\"`GET /gateways/{gateway_id}/info/{entry}` Get information about the gateway `{gateway_id}`'s entry-listing endpoints. \"\"\" from optimade.models import EntryInfoResource from optimade.server.exceptions import BadRequest from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.utils import ( aretrieve_queryable_properties , validate_resource , ) await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) valid_entry_info_endpoints = ENTRY_INFO_SCHEMAS . keys () if entry not in valid_entry_info_endpoints : raise BadRequest ( title = \"Not Found\" , status_code = 404 , detail = ( f \"Entry info not found for { entry } , valid entry info endpoints are: \" f \" { ', ' . join ( valid_entry_info_endpoints ) } \" ), ) schema = ENTRY_INFO_SCHEMAS [ entry ]() queryable_properties = { \"id\" , \"type\" , \"attributes\" } properties = await aretrieve_queryable_properties ( schema , queryable_properties ) output_fields_by_format = { \"json\" : list ( properties . keys ())} return EntryInfoResponse ( data = EntryInfoResource ( formats = list ( output_fields_by_format . keys ()), description = schema . get ( \"description\" , \"Entry Resources\" ), properties = properties , output_fields_by_format = output_fields_by_format , ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , ), ) get_gateways_info ( request , gateway_id ) async \u00b6 GET /gateways/{gateway_id}/info Return a regular /info response for an OPTIMADE implementation, including extra information from all the gateway's databases. The general information will be a minimum set from the gateway's databases. Source code in optimade_gateway/routers/gateway/info.py @ROUTER . get ( \"/gateways/ {gateway_id} /info\" , response_model = Union [ InfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_gateways_info ( request : Request , gateway_id : str , ) -> InfoResponse : \"\"\"`GET /gateways/{gateway_id}/info` Return a regular `/info` response for an OPTIMADE implementation, including extra information from all the gateway's databases. The general information will be a minimum set from the gateway's databases. \"\"\" from optimade_gateway.common.config import CONFIG from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.utils import get_valid_resource gateway = await get_valid_resource ( GATEWAYS_COLLECTION , gateway_id ) return InfoResponse ( data = BaseInfoResource ( id = BaseInfoResource . schema ()[ \"properties\" ][ \"id\" ][ \"const\" ], type = BaseInfoResource . schema ()[ \"properties\" ][ \"type\" ][ \"const\" ], attributes = BaseInfoAttributes ( api_version = __api_version__ , available_api_versions = [ { \"url\" : f \" { get_base_url ( request . url ) } /v { __api_version__ . split ( '.' )[ 0 ] } /gateways/ { gateway_id } /v { __api_version__ . split ( '.' )[ 0 ] } \" , \"version\" : __api_version__ , } ], formats = [ \"json\" ], entry_types_by_format = { \"json\" : list ( ENTRY_INFO_SCHEMAS . keys ())}, available_endpoints = sorted ( [ \"info\" , \"links\" ] + list ( ENTRY_INFO_SCHEMAS . keys ()) ), is_index = False , ), ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _gateway\" : { \"databases\" : [ { \"id\" : _ . id , \"type\" : _ . type } for _ in gateway . attributes . databases ], } }, ), ) get_versioned_gateways_entry_info ( request , gateway_id , version , entry ) async \u00b6 GET /gateways/{gateway_id}/{version}/info/{entry} Same as GET /gateways/{gateway_id}/info/{entry} . Source code in optimade_gateway/routers/gateway/info.py @ROUTER . get ( \"/gateways/ {gateway_id} / {version} /info/ {entry} \" , response_model = Union [ EntryInfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_versioned_gateways_entry_info ( request : Request , gateway_id : str , version : str , entry : str , ) -> EntryInfoResponse : \"\"\"`GET /gateways/{gateway_id}/{version}/info/{entry}` Same as `GET /gateways/{gateway_id}/info/{entry}`. \"\"\" from optimade_gateway.routers.gateway.utils import validate_version await validate_version ( version ) return await get_gateways_entry_info ( request , gateway_id , entry ) get_versioned_gateways_info ( request , gateway_id , version ) async \u00b6 GET /gateways/{gateway_id}/{version}/info Same as GET /gateways/{gateway_id}/info . Source code in optimade_gateway/routers/gateway/info.py @ROUTER . get ( \"/gateways/ {gateway_id} / {version} /info\" , response_model = Union [ InfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_versioned_gateways_info ( request : Request , gateway_id : str , version : str , ) -> InfoResponse : \"\"\"`GET /gateways/{gateway_id}/{version}/info` Same as `GET /gateways/{gateway_id}/info`. \"\"\" from optimade_gateway.routers.gateway.utils import validate_version await validate_version ( version ) return await get_gateways_info ( request , gateway_id )","title":"info"},{"location":"api_reference/routers/gateway/info/#info","text":"/gateways/{id}/info/* This file describes the router for: /gateways/{id}/{version}/info/{entry} where version and entry may be left out.","title":"info"},{"location":"api_reference/routers/gateway/info/#optimade_gateway.routers.gateway.info.get_gateways_entry_info","text":"GET /gateways/{gateway_id}/info/{entry} Get information about the gateway {gateway_id} 's entry-listing endpoints. Source code in optimade_gateway/routers/gateway/info.py @ROUTER . get ( \"/gateways/ {gateway_id} /info/ {entry} \" , response_model = Union [ EntryInfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_gateways_entry_info ( request : Request , gateway_id : str , entry : str ) -> EntryInfoResponse : \"\"\"`GET /gateways/{gateway_id}/info/{entry}` Get information about the gateway `{gateway_id}`'s entry-listing endpoints. \"\"\" from optimade.models import EntryInfoResource from optimade.server.exceptions import BadRequest from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.utils import ( aretrieve_queryable_properties , validate_resource , ) await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) valid_entry_info_endpoints = ENTRY_INFO_SCHEMAS . keys () if entry not in valid_entry_info_endpoints : raise BadRequest ( title = \"Not Found\" , status_code = 404 , detail = ( f \"Entry info not found for { entry } , valid entry info endpoints are: \" f \" { ', ' . join ( valid_entry_info_endpoints ) } \" ), ) schema = ENTRY_INFO_SCHEMAS [ entry ]() queryable_properties = { \"id\" , \"type\" , \"attributes\" } properties = await aretrieve_queryable_properties ( schema , queryable_properties ) output_fields_by_format = { \"json\" : list ( properties . keys ())} return EntryInfoResponse ( data = EntryInfoResource ( formats = list ( output_fields_by_format . keys ()), description = schema . get ( \"description\" , \"Entry Resources\" ), properties = properties , output_fields_by_format = output_fields_by_format , ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , ), )","title":"get_gateways_entry_info()"},{"location":"api_reference/routers/gateway/info/#optimade_gateway.routers.gateway.info.get_gateways_info","text":"GET /gateways/{gateway_id}/info Return a regular /info response for an OPTIMADE implementation, including extra information from all the gateway's databases. The general information will be a minimum set from the gateway's databases. Source code in optimade_gateway/routers/gateway/info.py @ROUTER . get ( \"/gateways/ {gateway_id} /info\" , response_model = Union [ InfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_gateways_info ( request : Request , gateway_id : str , ) -> InfoResponse : \"\"\"`GET /gateways/{gateway_id}/info` Return a regular `/info` response for an OPTIMADE implementation, including extra information from all the gateway's databases. The general information will be a minimum set from the gateway's databases. \"\"\" from optimade_gateway.common.config import CONFIG from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.utils import get_valid_resource gateway = await get_valid_resource ( GATEWAYS_COLLECTION , gateway_id ) return InfoResponse ( data = BaseInfoResource ( id = BaseInfoResource . schema ()[ \"properties\" ][ \"id\" ][ \"const\" ], type = BaseInfoResource . schema ()[ \"properties\" ][ \"type\" ][ \"const\" ], attributes = BaseInfoAttributes ( api_version = __api_version__ , available_api_versions = [ { \"url\" : f \" { get_base_url ( request . url ) } /v { __api_version__ . split ( '.' )[ 0 ] } /gateways/ { gateway_id } /v { __api_version__ . split ( '.' )[ 0 ] } \" , \"version\" : __api_version__ , } ], formats = [ \"json\" ], entry_types_by_format = { \"json\" : list ( ENTRY_INFO_SCHEMAS . keys ())}, available_endpoints = sorted ( [ \"info\" , \"links\" ] + list ( ENTRY_INFO_SCHEMAS . keys ()) ), is_index = False , ), ), meta = meta_values ( url = request . url , data_returned = 1 , data_available = 1 , more_data_available = False , ** { f \"_ { CONFIG . provider . prefix } _gateway\" : { \"databases\" : [ { \"id\" : _ . id , \"type\" : _ . type } for _ in gateway . attributes . databases ], } }, ), )","title":"get_gateways_info()"},{"location":"api_reference/routers/gateway/info/#optimade_gateway.routers.gateway.info.get_versioned_gateways_entry_info","text":"GET /gateways/{gateway_id}/{version}/info/{entry} Same as GET /gateways/{gateway_id}/info/{entry} . Source code in optimade_gateway/routers/gateway/info.py @ROUTER . get ( \"/gateways/ {gateway_id} / {version} /info/ {entry} \" , response_model = Union [ EntryInfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_versioned_gateways_entry_info ( request : Request , gateway_id : str , version : str , entry : str , ) -> EntryInfoResponse : \"\"\"`GET /gateways/{gateway_id}/{version}/info/{entry}` Same as `GET /gateways/{gateway_id}/info/{entry}`. \"\"\" from optimade_gateway.routers.gateway.utils import validate_version await validate_version ( version ) return await get_gateways_entry_info ( request , gateway_id , entry )","title":"get_versioned_gateways_entry_info()"},{"location":"api_reference/routers/gateway/info/#optimade_gateway.routers.gateway.info.get_versioned_gateways_info","text":"GET /gateways/{gateway_id}/{version}/info Same as GET /gateways/{gateway_id}/info . Source code in optimade_gateway/routers/gateway/info.py @ROUTER . get ( \"/gateways/ {gateway_id} / {version} /info\" , response_model = Union [ InfoResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Info\" ], ) async def get_versioned_gateways_info ( request : Request , gateway_id : str , version : str , ) -> InfoResponse : \"\"\"`GET /gateways/{gateway_id}/{version}/info` Same as `GET /gateways/{gateway_id}/info`. \"\"\" from optimade_gateway.routers.gateway.utils import validate_version await validate_version ( version ) return await get_gateways_info ( request , gateway_id )","title":"get_versioned_gateways_info()"},{"location":"api_reference/routers/gateway/links/","text":"links \u00b6 /gateways/{id}/links This file describes the router for: /gateways/{id}/{version}/links where version may be left out. get_gateways_links ( request , gateway_id , params = Depends ( NoneType )) async \u00b6 GET /gateways/{gateway_id}/links Return a regular /links response for an OPTIMADE implementation. Source code in optimade_gateway/routers/gateway/links.py @ROUTER . get ( \"/gateways/ {gateway_id} /links\" , response_model = Union [ LinksResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Links\" ], ) async def get_gateways_links ( request : Request , gateway_id : str , params : EntryListingQueryParams = Depends (), ) -> LinksResponse : \"\"\"`GET /gateways/{gateway_id}/links` Return a regular `/links` response for an OPTIMADE implementation. \"\"\" from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.links import get_links from optimade_gateway.routers.utils import validate_resource await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) return await get_links ( request = request , params = params ) get_versioned_gateways_links ( request , gateway_id , version , params = Depends ( NoneType )) async \u00b6 GET /gateways/{gateway_id}/{version}/links Same as GET /gateways/{gateway_id}/links . Source code in optimade_gateway/routers/gateway/links.py @ROUTER . get ( \"/gateways/ {gateway_id} / {version} /links\" , response_model = Union [ LinksResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Links\" ], ) async def get_versioned_gateways_links ( request : Request , gateway_id : str , version : str , params : EntryListingQueryParams = Depends (), ) -> LinksResponse : \"\"\"`GET /gateways/{gateway_id}/{version}/links` Same as `GET /gateways/{gateway_id}/links`. \"\"\" from optimade_gateway.routers.gateway.utils import validate_version await validate_version ( version ) return await get_gateways_links ( request , gateway_id , params )","title":"links"},{"location":"api_reference/routers/gateway/links/#links","text":"/gateways/{id}/links This file describes the router for: /gateways/{id}/{version}/links where version may be left out.","title":"links"},{"location":"api_reference/routers/gateway/links/#optimade_gateway.routers.gateway.links.get_gateways_links","text":"GET /gateways/{gateway_id}/links Return a regular /links response for an OPTIMADE implementation. Source code in optimade_gateway/routers/gateway/links.py @ROUTER . get ( \"/gateways/ {gateway_id} /links\" , response_model = Union [ LinksResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Links\" ], ) async def get_gateways_links ( request : Request , gateway_id : str , params : EntryListingQueryParams = Depends (), ) -> LinksResponse : \"\"\"`GET /gateways/{gateway_id}/links` Return a regular `/links` response for an OPTIMADE implementation. \"\"\" from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.links import get_links from optimade_gateway.routers.utils import validate_resource await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) return await get_links ( request = request , params = params )","title":"get_gateways_links()"},{"location":"api_reference/routers/gateway/links/#optimade_gateway.routers.gateway.links.get_versioned_gateways_links","text":"GET /gateways/{gateway_id}/{version}/links Same as GET /gateways/{gateway_id}/links . Source code in optimade_gateway/routers/gateway/links.py @ROUTER . get ( \"/gateways/ {gateway_id} / {version} /links\" , response_model = Union [ LinksResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Links\" ], ) async def get_versioned_gateways_links ( request : Request , gateway_id : str , version : str , params : EntryListingQueryParams = Depends (), ) -> LinksResponse : \"\"\"`GET /gateways/{gateway_id}/{version}/links` Same as `GET /gateways/{gateway_id}/links`. \"\"\" from optimade_gateway.routers.gateway.utils import validate_version await validate_version ( version ) return await get_gateways_links ( request , gateway_id , params )","title":"get_versioned_gateways_links()"},{"location":"api_reference/routers/gateway/queries/","text":"queries \u00b6 Special /queries endpoint for a gateway to perform and list queries This file describes the router for: /gateways/{id}/{version}/queries/{id} where version and the last id may be left out. get_gateway_queries ( request , gateway_id , params = Depends ( NoneType )) async \u00b6 GET /gateways/{gateway_id}/queries Return overview of all (active) queries for specific gateway. Source code in optimade_gateway/routers/gateway/queries.py @ROUTER . get ( \"/gateways/ {gateway_id} /queries\" , response_model = Union [ QueriesResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" , \"Queries\" ], ) async def get_gateway_queries ( request : Request , gateway_id : str , params : EntryListingQueryParams = Depends (), ) -> QueriesResponse : \"\"\"`GET /gateways/{gateway_id}/queries` Return overview of all (active) queries for specific gateway. \"\"\" from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.queries import get_queries await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) params . filter = ( f '( { params . filter } ) AND ( gateway=\" { gateway_id } \" )' if params . filter else f 'gateway=\" { gateway_id } \"' ) return await get_queries ( request , params ) get_gateway_query ( request , gateway_id , query_id ) async \u00b6 GET /gateways/{gateway_id}/queries/{query_id} Return the response from a gateway query ( QueryResource.attributes.response ). Source code in optimade_gateway/routers/gateway/queries.py @ROUTER . get ( \"/gateways/ {gateway_id} /queries/ {query_id} \" , response_model = Union [ EntryResponseMany , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" , \"Queries\" ], ) async def get_gateway_query ( request : Request , gateway_id : str , query_id : str ) -> EntryResponseMany : \"\"\"`GET /gateways/{gateway_id}/queries/{query_id}` Return the response from a gateway query ([`QueryResource.attributes.response`][optimade_gateway.models.queries.QueryResourceAttributes.response]). \"\"\" from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.queries import get_query await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) return await get_query ( request , query_id ) post_gateway_queries ( request , gateway_id , query ) async \u00b6 POST /gateways/{gateway_id}/queries Create or return existing gateway query according to query . Source code in optimade_gateway/routers/gateway/queries.py @ROUTER . post ( \"/gateways/ {gateway_id} /queries\" , response_model = Union [ QueriesResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" , \"Queries\" ], status_code = status . HTTP_202_ACCEPTED , ) async def post_gateway_queries ( request : Request , gateway_id : str , query : QueryCreate , ) -> QueriesResponseSingle : \"\"\"`POST /gateways/{gateway_id}/queries` Create or return existing gateway query according to `query`. \"\"\" from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.queries import post_queries await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) if query . gateway_id and query . gateway_id != gateway_id : raise BadRequest ( status_code = 403 , title = \"Forbidden\" , detail = ( f \"The gateway ID in the posted data (<gateway= { query . gateway_id } >) does not align \" f \"with the gateway ID specified in the URL (/ { gateway_id } /).\" ), ) return await post_queries ( request , query )","title":"queries"},{"location":"api_reference/routers/gateway/queries/#queries","text":"Special /queries endpoint for a gateway to perform and list queries This file describes the router for: /gateways/{id}/{version}/queries/{id} where version and the last id may be left out.","title":"queries"},{"location":"api_reference/routers/gateway/queries/#optimade_gateway.routers.gateway.queries.get_gateway_queries","text":"GET /gateways/{gateway_id}/queries Return overview of all (active) queries for specific gateway. Source code in optimade_gateway/routers/gateway/queries.py @ROUTER . get ( \"/gateways/ {gateway_id} /queries\" , response_model = Union [ QueriesResponse , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" , \"Queries\" ], ) async def get_gateway_queries ( request : Request , gateway_id : str , params : EntryListingQueryParams = Depends (), ) -> QueriesResponse : \"\"\"`GET /gateways/{gateway_id}/queries` Return overview of all (active) queries for specific gateway. \"\"\" from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.queries import get_queries await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) params . filter = ( f '( { params . filter } ) AND ( gateway=\" { gateway_id } \" )' if params . filter else f 'gateway=\" { gateway_id } \"' ) return await get_queries ( request , params )","title":"get_gateway_queries()"},{"location":"api_reference/routers/gateway/queries/#optimade_gateway.routers.gateway.queries.get_gateway_query","text":"GET /gateways/{gateway_id}/queries/{query_id} Return the response from a gateway query ( QueryResource.attributes.response ). Source code in optimade_gateway/routers/gateway/queries.py @ROUTER . get ( \"/gateways/ {gateway_id} /queries/ {query_id} \" , response_model = Union [ EntryResponseMany , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" , \"Queries\" ], ) async def get_gateway_query ( request : Request , gateway_id : str , query_id : str ) -> EntryResponseMany : \"\"\"`GET /gateways/{gateway_id}/queries/{query_id}` Return the response from a gateway query ([`QueryResource.attributes.response`][optimade_gateway.models.queries.QueryResourceAttributes.response]). \"\"\" from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.queries import get_query await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) return await get_query ( request , query_id )","title":"get_gateway_query()"},{"location":"api_reference/routers/gateway/queries/#optimade_gateway.routers.gateway.queries.post_gateway_queries","text":"POST /gateways/{gateway_id}/queries Create or return existing gateway query according to query . Source code in optimade_gateway/routers/gateway/queries.py @ROUTER . post ( \"/gateways/ {gateway_id} /queries\" , response_model = Union [ QueriesResponseSingle , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Gateways\" , \"Queries\" ], status_code = status . HTTP_202_ACCEPTED , ) async def post_gateway_queries ( request : Request , gateway_id : str , query : QueryCreate , ) -> QueriesResponseSingle : \"\"\"`POST /gateways/{gateway_id}/queries` Create or return existing gateway query according to `query`. \"\"\" from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.queries import post_queries await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) if query . gateway_id and query . gateway_id != gateway_id : raise BadRequest ( status_code = 403 , title = \"Forbidden\" , detail = ( f \"The gateway ID in the posted data (<gateway= { query . gateway_id } >) does not align \" f \"with the gateway ID specified in the URL (/ { gateway_id } /).\" ), ) return await post_queries ( request , query )","title":"post_gateway_queries()"},{"location":"api_reference/routers/gateway/structures/","text":"structures \u00b6 /gateways/{id}/structures/* This file describes the router for: /gateways/{id}/{version}/structures/{id} where version and the last id may be left out. get_single_structure ( request , gateway_id , structure_id , params = Depends ( NoneType )) async \u00b6 GET /gateways/{gateway_id}/structures/{structure_id} Return a regular /structures/{id} response for an OPTIMADE implementation. The structure_id must be of the type {database ID}/{id} . Source code in optimade_gateway/routers/gateway/structures.py @ROUTER . get ( \"/gateways/ {gateway_id} /structures/{structure_id:path}\" , response_model = Union [ StructureResponseOne , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Structures\" ], ) async def get_single_structure ( request : Request , gateway_id : str , structure_id : str , params : SingleEntryQueryParams = Depends (), ) -> StructureResponseOne : \"\"\"`GET /gateways/{gateway_id}/structures/{structure_id}` Return a regular `/structures/{id}` response for an OPTIMADE implementation. The `structure_id` must be of the type `{database ID}/{id}`. \"\"\" from optimade_gateway.models import GatewayResource from optimade_gateway.queries import db_find from optimade_gateway.routers.utils import get_valid_resource gateway : GatewayResource = await get_valid_resource ( GATEWAYS_COLLECTION , gateway_id ) local_structure_id = None for database in gateway . attributes . databases : if structure_id . startswith ( f \" { database . id } /\" ): # Database found local_structure_id = structure_id [ len ( f \" { database . id } /\" ) :] break else : raise BadRequest ( detail = ( f \"Structures entry <id= { structure_id } > not found. To get a specific structures entry \" \"one needs to prepend the ID with a database ID belonging to the gateway, e.g., \" f \"' { gateway . attributes . databases [ 0 ] . id } /<local_database_ID>'. Available databases for \" f \"gateway { gateway_id !r} : { [ _ . id for _ in gateway . attributes . databases ] } \" ) ) errors = [] result = None parsed_params = urllib . parse . urlencode ( { param : value for param , value in params . __dict__ . items () if value } ) ( response , _ ) = await asyncio . get_running_loop () . run_in_executor ( executor = None , # Run in thread with the event loop func = functools . partial ( db_find , database = database , endpoint = f \"structures/ { local_structure_id } \" , response_model = StructureResponseOne , query_params = parsed_params , ), ) if isinstance ( response , ErrorResponse ): for error in response . errors : if isinstance ( error . id , str ) and error . id . startswith ( \"OPTIMADE_GATEWAY\" ): warnings . warn ( error . detail ) else : meta = {} if error . meta : meta = error . meta . dict () meta . update ( { \"optimade_gateway\" : { \"gateway\" : gateway , \"source_database_id\" : database . id , } } ) error . meta = Meta ( ** meta ) errors . append ( error ) else : result = response . data if isinstance ( result , dict ) and result . get ( \"id\" ) is not None : result [ \"id\" ] = f \" { database . id } / { result [ 'id' ] } \" elif result is None : pass else : result . id = f \" { database . id } / { result . id } \" meta = meta_values ( url = request . url , data_returned = response . meta . data_returned , data_available = None , # Don't set this, as we'd have to request ALL gateway databases more_data_available = response . meta . more_data_available , ) del meta . data_available if errors : return ErrorResponse ( errors = errors , meta = meta ) return StructureResponseOne ( links = ToplevelLinks ( next = None ), data = result , meta = meta ) get_structures ( request , gateway_id , params = Depends ( NoneType )) async \u00b6 GET /gateways/{gateway_id}/structures Return a regular /structures response for an OPTIMADE implementation, including responses from all the gateway's databases. Source code in optimade_gateway/routers/gateway/structures.py @ROUTER . get ( \"/gateways/ {gateway_id} /structures\" , response_model = Union [ StructureResponseMany , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Structures\" ], ) async def get_structures ( request : Request , gateway_id : str , params : EntryListingQueryParams = Depends (), ) -> StructureResponseMany : \"\"\"`GET /gateways/{gateway_id}/structures` Return a regular `/structures` response for an OPTIMADE implementation, including responses from all the gateway's databases. \"\"\" from optimade_gateway.queries import perform_query from optimade_gateway.routers.utils import validate_resource await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) return await perform_query ( url = request . url , query = QueryResource ( ** { \"id\" : \"temp\" , \"type\" : \"queries\" , \"attributes\" : { \"last_modified\" : datetime . utcnow (), \"gateway_id\" : gateway_id , \"state\" : \"created\" , \"query_parameters\" : { key : value for key , value in params . __dict__ . items () if value }, \"endpoint\" : \"structures\" , \"endpoint_model\" : ( StructureResponseMany . __module__ , StructureResponseMany . __name__ , ), }, } ), use_query_resource = False , ) get_versioned_single_structure ( request , gateway_id , version , structure_id , params = Depends ( NoneType )) async \u00b6 GET /gateways/{gateway_id}/{version}/structures/{structure_id} Same as GET /gateways/{gateway_id}/structures/{structure_id} . Source code in optimade_gateway/routers/gateway/structures.py @ROUTER . get ( \"/gateways/ {gateway_id} / {version} /structures/{structure_id:path}\" , response_model = Union [ StructureResponseOne , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Structures\" ], include_in_schema = False , ) async def get_versioned_single_structure ( request : Request , gateway_id : str , version : str , structure_id : str , params : SingleEntryQueryParams = Depends (), ) -> StructureResponseOne : \"\"\"`GET /gateways/{gateway_id}/{version}/structures/{structure_id}` Same as `GET /gateways/{gateway_id}/structures/{structure_id}`. \"\"\" await validate_version ( version ) return await get_single_structure ( request , gateway_id , structure_id , params ) get_versioned_structures ( request , gateway_id , version , params = Depends ( NoneType )) async \u00b6 GET /gateways/{gateway_id}/{version}/structures Same as GET /gateways/{gateway_id}/structures . Source code in optimade_gateway/routers/gateway/structures.py @ROUTER . get ( \"/gateways/ {gateway_id} / {version} /structures\" , response_model = Union [ StructureResponseMany , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Structures\" ], include_in_schema = False , ) async def get_versioned_structures ( request : Request , gateway_id : str , version : str , params : EntryListingQueryParams = Depends (), ) -> StructureResponseMany : \"\"\"`GET /gateways/{gateway_id}/{version}/structures` Same as `GET /gateways/{gateway_id}/structures`. \"\"\" await validate_version ( version ) return await get_structures ( request , gateway_id , params )","title":"structures"},{"location":"api_reference/routers/gateway/structures/#structures","text":"/gateways/{id}/structures/* This file describes the router for: /gateways/{id}/{version}/structures/{id} where version and the last id may be left out.","title":"structures"},{"location":"api_reference/routers/gateway/structures/#optimade_gateway.routers.gateway.structures.get_single_structure","text":"GET /gateways/{gateway_id}/structures/{structure_id} Return a regular /structures/{id} response for an OPTIMADE implementation. The structure_id must be of the type {database ID}/{id} . Source code in optimade_gateway/routers/gateway/structures.py @ROUTER . get ( \"/gateways/ {gateway_id} /structures/{structure_id:path}\" , response_model = Union [ StructureResponseOne , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Structures\" ], ) async def get_single_structure ( request : Request , gateway_id : str , structure_id : str , params : SingleEntryQueryParams = Depends (), ) -> StructureResponseOne : \"\"\"`GET /gateways/{gateway_id}/structures/{structure_id}` Return a regular `/structures/{id}` response for an OPTIMADE implementation. The `structure_id` must be of the type `{database ID}/{id}`. \"\"\" from optimade_gateway.models import GatewayResource from optimade_gateway.queries import db_find from optimade_gateway.routers.utils import get_valid_resource gateway : GatewayResource = await get_valid_resource ( GATEWAYS_COLLECTION , gateway_id ) local_structure_id = None for database in gateway . attributes . databases : if structure_id . startswith ( f \" { database . id } /\" ): # Database found local_structure_id = structure_id [ len ( f \" { database . id } /\" ) :] break else : raise BadRequest ( detail = ( f \"Structures entry <id= { structure_id } > not found. To get a specific structures entry \" \"one needs to prepend the ID with a database ID belonging to the gateway, e.g., \" f \"' { gateway . attributes . databases [ 0 ] . id } /<local_database_ID>'. Available databases for \" f \"gateway { gateway_id !r} : { [ _ . id for _ in gateway . attributes . databases ] } \" ) ) errors = [] result = None parsed_params = urllib . parse . urlencode ( { param : value for param , value in params . __dict__ . items () if value } ) ( response , _ ) = await asyncio . get_running_loop () . run_in_executor ( executor = None , # Run in thread with the event loop func = functools . partial ( db_find , database = database , endpoint = f \"structures/ { local_structure_id } \" , response_model = StructureResponseOne , query_params = parsed_params , ), ) if isinstance ( response , ErrorResponse ): for error in response . errors : if isinstance ( error . id , str ) and error . id . startswith ( \"OPTIMADE_GATEWAY\" ): warnings . warn ( error . detail ) else : meta = {} if error . meta : meta = error . meta . dict () meta . update ( { \"optimade_gateway\" : { \"gateway\" : gateway , \"source_database_id\" : database . id , } } ) error . meta = Meta ( ** meta ) errors . append ( error ) else : result = response . data if isinstance ( result , dict ) and result . get ( \"id\" ) is not None : result [ \"id\" ] = f \" { database . id } / { result [ 'id' ] } \" elif result is None : pass else : result . id = f \" { database . id } / { result . id } \" meta = meta_values ( url = request . url , data_returned = response . meta . data_returned , data_available = None , # Don't set this, as we'd have to request ALL gateway databases more_data_available = response . meta . more_data_available , ) del meta . data_available if errors : return ErrorResponse ( errors = errors , meta = meta ) return StructureResponseOne ( links = ToplevelLinks ( next = None ), data = result , meta = meta )","title":"get_single_structure()"},{"location":"api_reference/routers/gateway/structures/#optimade_gateway.routers.gateway.structures.get_structures","text":"GET /gateways/{gateway_id}/structures Return a regular /structures response for an OPTIMADE implementation, including responses from all the gateway's databases. Source code in optimade_gateway/routers/gateway/structures.py @ROUTER . get ( \"/gateways/ {gateway_id} /structures\" , response_model = Union [ StructureResponseMany , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Structures\" ], ) async def get_structures ( request : Request , gateway_id : str , params : EntryListingQueryParams = Depends (), ) -> StructureResponseMany : \"\"\"`GET /gateways/{gateway_id}/structures` Return a regular `/structures` response for an OPTIMADE implementation, including responses from all the gateway's databases. \"\"\" from optimade_gateway.queries import perform_query from optimade_gateway.routers.utils import validate_resource await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) return await perform_query ( url = request . url , query = QueryResource ( ** { \"id\" : \"temp\" , \"type\" : \"queries\" , \"attributes\" : { \"last_modified\" : datetime . utcnow (), \"gateway_id\" : gateway_id , \"state\" : \"created\" , \"query_parameters\" : { key : value for key , value in params . __dict__ . items () if value }, \"endpoint\" : \"structures\" , \"endpoint_model\" : ( StructureResponseMany . __module__ , StructureResponseMany . __name__ , ), }, } ), use_query_resource = False , )","title":"get_structures()"},{"location":"api_reference/routers/gateway/structures/#optimade_gateway.routers.gateway.structures.get_versioned_single_structure","text":"GET /gateways/{gateway_id}/{version}/structures/{structure_id} Same as GET /gateways/{gateway_id}/structures/{structure_id} . Source code in optimade_gateway/routers/gateway/structures.py @ROUTER . get ( \"/gateways/ {gateway_id} / {version} /structures/{structure_id:path}\" , response_model = Union [ StructureResponseOne , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Structures\" ], include_in_schema = False , ) async def get_versioned_single_structure ( request : Request , gateway_id : str , version : str , structure_id : str , params : SingleEntryQueryParams = Depends (), ) -> StructureResponseOne : \"\"\"`GET /gateways/{gateway_id}/{version}/structures/{structure_id}` Same as `GET /gateways/{gateway_id}/structures/{structure_id}`. \"\"\" await validate_version ( version ) return await get_single_structure ( request , gateway_id , structure_id , params )","title":"get_versioned_single_structure()"},{"location":"api_reference/routers/gateway/structures/#optimade_gateway.routers.gateway.structures.get_versioned_structures","text":"GET /gateways/{gateway_id}/{version}/structures Same as GET /gateways/{gateway_id}/structures . Source code in optimade_gateway/routers/gateway/structures.py @ROUTER . get ( \"/gateways/ {gateway_id} / {version} /structures\" , response_model = Union [ StructureResponseMany , ErrorResponse ], response_model_exclude_defaults = False , response_model_exclude_none = False , response_model_exclude_unset = True , tags = [ \"Structures\" ], include_in_schema = False , ) async def get_versioned_structures ( request : Request , gateway_id : str , version : str , params : EntryListingQueryParams = Depends (), ) -> StructureResponseMany : \"\"\"`GET /gateways/{gateway_id}/{version}/structures` Same as `GET /gateways/{gateway_id}/structures`. \"\"\" await validate_version ( version ) return await get_structures ( request , gateway_id , params )","title":"get_versioned_structures()"},{"location":"api_reference/routers/gateway/utils/","text":"utils \u00b6 validate_version ( version ) async \u00b6 Validate version according to optimade package. Parameters: Name Type Description Default version str The OPTIMADE API version. required Source code in optimade_gateway/routers/gateway/utils.py async def validate_version ( version : str ) -> None : \"\"\"Validate version according to `optimade` package. Parameters: version: The OPTIMADE API version. \"\"\" valid_versions = [ _ [ 1 :] for _ in BASE_URL_PREFIXES . values ()] if version not in valid_versions : if version . startswith ( \"v\" ): raise VersionNotSupported ( detail = f \"version { version } is not supported. Supported versions: { valid_versions } \" ) else : raise BadRequest ( title = \"Not Found\" , status_code = 404 , detail = f \"version MUST be one of { valid_versions } \" , )","title":"utils"},{"location":"api_reference/routers/gateway/utils/#utils","text":"","title":"utils"},{"location":"api_reference/routers/gateway/utils/#optimade_gateway.routers.gateway.utils.validate_version","text":"Validate version according to optimade package. Parameters: Name Type Description Default version str The OPTIMADE API version. required Source code in optimade_gateway/routers/gateway/utils.py async def validate_version ( version : str ) -> None : \"\"\"Validate version according to `optimade` package. Parameters: version: The OPTIMADE API version. \"\"\" valid_versions = [ _ [ 1 :] for _ in BASE_URL_PREFIXES . values ()] if version not in valid_versions : if version . startswith ( \"v\" ): raise VersionNotSupported ( detail = f \"version { version } is not supported. Supported versions: { valid_versions } \" ) else : raise BadRequest ( title = \"Not Found\" , status_code = 404 , detail = f \"version MUST be one of { valid_versions } \" , )","title":"validate_version()"},{"location":"api_reference/routers/gateway/versions/","text":"versions \u00b6 /gateways/{id}/versions This file describes the router for: /gateways/{id}/versions get_gateway_versions ( request , gateway_id ) async \u00b6 GET /gateways/{gateway_id}/versions Return the result of the function used to GET /versions from the optimade package. Source code in optimade_gateway/routers/gateway/versions.py @ROUTER . get ( \"/gateways/ {gateway_id} /versions\" , response_class = CsvResponse , tags = [ \"Versions\" ], ) async def get_gateway_versions ( request : Request , gateway_id : str ) -> CsvResponse : \"\"\"`GET /gateways/{gateway_id}/versions` Return the result of the function used to `GET /versions` from the `optimade` package. \"\"\" from optimade.server.routers.versions import get_versions from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.utils import validate_resource await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) return get_versions ( request )","title":"versions"},{"location":"api_reference/routers/gateway/versions/#versions","text":"/gateways/{id}/versions This file describes the router for: /gateways/{id}/versions","title":"versions"},{"location":"api_reference/routers/gateway/versions/#optimade_gateway.routers.gateway.versions.get_gateway_versions","text":"GET /gateways/{gateway_id}/versions Return the result of the function used to GET /versions from the optimade package. Source code in optimade_gateway/routers/gateway/versions.py @ROUTER . get ( \"/gateways/ {gateway_id} /versions\" , response_class = CsvResponse , tags = [ \"Versions\" ], ) async def get_gateway_versions ( request : Request , gateway_id : str ) -> CsvResponse : \"\"\"`GET /gateways/{gateway_id}/versions` Return the result of the function used to `GET /versions` from the `optimade` package. \"\"\" from optimade.server.routers.versions import get_versions from optimade_gateway.routers.gateways import GATEWAYS_COLLECTION from optimade_gateway.routers.utils import validate_resource await validate_resource ( GATEWAYS_COLLECTION , gateway_id ) return get_versions ( request )","title":"get_gateway_versions()"}]}